<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>immunogrep_db_query_api &mdash; IGREP 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="IGREP 1.0.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">IGREP 1.0.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for immunogrep_db_query_api</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Query API made for interacting with the igrep mongodb database</span>

<span class="sd">10-4-2015:</span>
<span class="sd">	Seperated the api into two parts:</span>

<span class="sd">		Main part - Class name = RunQuery (this file/module): a method for interacting with the immunogrep mongodb database. This is the main class and will assume you have credentials for accessing</span>
<span class="sd">		the exps and seqs collection.</span>

<span class="sd">		Part two - Class name = QueryProxy (new file/module immunogrep_query_dbproxy_api): a proxy class for calling the main class above (Main part). This is for users you do not know the password for access to each collection,</span>
<span class="sd">		but have experiments in the database or want to query publicly available data. They just would need to know the address of the proxy to the database</span>
<span class="sd">		and optionally their login credentials (if they have their own experiments on that database)</span>

<span class="sd">	Current design for a user who has access to the seqs and exps collection (usually an administrator):</span>

<span class="sd">		User -&gt; RunQuery Class (API for optimizing/standardizing queries to seqs and exps collection) -&gt; Pymongo -&gt; Immunogrep DB using MongoDB</span>
<span class="sd">		RunQuery Class will require:</span>

<span class="sd">			1) MongoDB database address</span>
<span class="sd">			2) MongoDB Username/password authentication to the seqs/exps collections</span>

<span class="sd">	Current design for a user who wants to query database without access (non-administrator):</span>
<span class="sd">		User -&gt; QueryProxy Class -&gt; Proxy to controlling access to database -&gt; RunQuery Class -&gt; Pymongo -&gt; Immunogrep DB using MongoDB</span>

<span class="sd">6/25/2015:</span>

<span class="sd">	new version for querying:</span>

<span class="sd">		allows conversions to CSV, TAB, JSON, IGREP,</span>
<span class="sd">		allows queries across multiple anotation methods</span>
<span class="sd">		allows user to query the NGS sequence and sequence header for any seqs collection query</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">bson.json_util</span> <span class="kn">import</span> <span class="n">dumps</span> <span class="k">as</span> <span class="n">bson_dumps</span>
<span class="kn">from</span> <span class="nn">bson.json_util</span> <span class="kn">import</span> <span class="n">loads</span> <span class="k">as</span> <span class="n">bson_loads</span>
<span class="kn">from</span> <span class="nn">bson.objectid</span> <span class="kn">import</span> <span class="n">ObjectId</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="c"># immunogrep modules:</span>
<span class="c"># variables/characters we will use</span>

<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">idIdentifier</span>  <span class="c"># currently idIdentifier = &#39;SEQ_ID&#39;, but check global_variables for changes</span>
<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">expIdentifier</span>  <span class="c"># currently expIdentifier = &#39;EXP_ID&#39; , but check global_variables for changes</span>
<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">seqRawData</span>  <span class="c"># currently seqRawData = &#39;@SEQ&#39;</span>
<span class="c"># currently fasta_file_delimiter = &#39;&lt; &#39;. We use this for seperating a fasta header, from our internal data. For example, here is a possible FASTQ/FASTA header with JSON data:</span>
<span class="c"># &gt;sequence_1&lt; {&#39;SEQ_ID&#39;:ObjectId(),&#39;PROJECT_NAME&#39;:&#39;demo&#39;}; or @sequence_1&lt; {&#39;SEQ_ID&#39;:ObjectId(),&#39;PROJECT_NAME&#39;:&#39;demo&#39;}</span>
<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">fasta_file_delimiter</span>

<span class="kn">import</span> <span class="nn">immunogrep_database_schema</span> <span class="kn">as</span> <span class="nn">schema</span>
<span class="kn">import</span> <span class="nn">immunogrep_useful_functions</span> <span class="kn">as</span> <span class="nn">useful</span>

<span class="kn">from</span> <span class="nn">mongo_igdb_tools</span> <span class="kn">import</span> <span class="n">connectToIgDatabase</span>
<span class="kn">from</span> <span class="nn">mongo_igdb_tools</span> <span class="kn">import</span> <span class="n">convert_to_objectid</span>
<span class="kn">from</span> <span class="nn">mongo_igdb_tools</span> <span class="kn">import</span> <span class="n">convert_text_to_index_field_text</span>
<span class="kn">from</span> <span class="nn">mongo_igdb_tools</span> <span class="kn">import</span> <span class="n">default_fields_data_types</span>
<span class="kn">from</span> <span class="nn">mongo_igdb_tools</span> <span class="kn">import</span> <span class="n">AttemptToConvertToBool</span>
<span class="kn">from</span> <span class="nn">mongo_igdb_tools</span> <span class="kn">import</span> <span class="n">default_metadata_fields</span>

<span class="k">try</span><span class="p">:</span>
	<span class="c"># cython-ized version of the functions from immunogrep_useful functions. These versions are about 2X faster</span>
	<span class="kn">from</span> <span class="nn">immunogrep_cython_db_tools</span> <span class="kn">import</span> <span class="n">flatten_dictionary</span>
	<span class="kn">from</span> <span class="nn">immunogrep_cython_db_tools</span> <span class="kn">import</span> <span class="n">RemoveObjId</span>
<span class="k">except</span><span class="p">:</span>
	<span class="c"># it wont work if there is no cython module (currently immunogrep_cython_db_tools). when it doesnt work, import non cyhton version</span>
	<span class="kn">from</span> <span class="nn">immunogrep_useful_functions</span> <span class="kn">import</span> <span class="n">flatten_dictionary</span>
	<span class="kn">from</span> <span class="nn">immunogrep_useful_functions</span> <span class="kn">import</span> <span class="n">RemoveObjId</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Not using cython&#39;</span><span class="p">)</span>

<span class="c"># NOTE1 :PYMONGO AGGREGATION SORT REQUIRES BSON OR ORDEREDDICT! -&gt; http://api.mongodb.org/python/current/examples/aggregation.html</span>

<span class="c"># ######GLOBAL VARIABLE DEFINITIONS###############</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Defining global variables used in module</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="n">oid_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">ObjectId</span><span class="p">())</span>

<span class="c"># these variables assume a default structure for our SEQS collection</span>
<span class="c"># We assume that any AB data with regard to a specific NGS read (SEQ_ID) is included as a subdocument under the key called &#39;DATA&#39; (DATA.CDR3.NT).</span>
<span class="c"># The following list defines fields that are NOT fields within DATA</span>
<span class="n">fields_above_data_key</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">,</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">,</span> <span class="s">&#39;EXP_ID&#39;</span><span class="p">,</span> <span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">,</span> <span class="s">&#39;SEQ_ID&#39;</span><span class="p">,</span> <span class="s">&#39;DATE_UPDATED&#39;</span><span class="p">,</span> <span class="s">&#39;SETTINGS&#39;</span><span class="p">]</span>

<span class="c"># The following lists defines fields within the DATA key that exist for raw NGS data (not AB annotated data; analysis_name = &quot;@SEQ&quot;)</span>
<span class="n">data_fields_for_raw_data</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;SEQUENCE_HEADER&#39;</span><span class="p">,</span> <span class="s">&#39;SEQUENCE&#39;</span><span class="p">,</span> <span class="s">&#39;QUALITY_SCORE&#39;</span><span class="p">,</span> <span class="s">&#39;FILENAME&#39;</span><span class="p">]</span>

<span class="c"># This key name is a hardcode key that exists in the SEQS collection. It is used to store information in a document that IS NOT wanted by the user,</span>
<span class="c"># but is added in by the us when inserting sequence data to the database. It is meant to only be used for improving queries on specific fields.</span>
<span class="c"># It should barely be used in projections. It should also rarely be used as a field in queries, because this API is meant to re-route any fields</span>
<span class="c"># automatically. For example, any queries on DATA.VREGION.VGENES will be re-routed to QUERY_DATA.VREGION.VGENES.PARSED_ALLELES (see redirect_seq_collection_fields)</span>
<span class="n">query_data_key_name</span> <span class="o">=</span> <span class="s">&#39;QUERY_DATA&#39;</span>

<span class="c"># These next three variables are currently untested and not implemented</span>
<span class="c"># Initial tests on Biotseq showed this method was not faster than running single processes</span>
<span class="c"># When true, the results in a cursor from a specific query are loaded into lists and processed in parallel.</span>
<span class="n">allow_multithreading</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">max_multithreading_processes</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1</span>


<span class="c"># a harcoded variable controlling the preferred order of fields output to delimited files (that is, if the user does not define an order, then these fields will always appear first)</span>
<span class="c"># also shows the default schema as of 6/26/2015</span>
<span class="n">default_sorting_order</span> <span class="o">=</span> <span class="p">[</span>
	<span class="n">idIdentifier</span><span class="p">,</span>
	<span class="s">&#39;SEQUENCE_HEADER&#39;</span><span class="p">,</span> <span class="s">&#39;SEQUENCE&#39;</span><span class="p">,</span> <span class="s">&#39;QUALITY_SCORE&#39;</span><span class="p">,</span>
	<span class="s">&#39;PREDICTED_AB_SEQ.AA&#39;</span><span class="p">,</span> <span class="s">&#39;PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span> <span class="s">&#39;STRAND&#39;</span><span class="p">,</span> <span class="s">&#39;PRODUCTIVE&#39;</span><span class="p">,</span>
	<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">,</span> <span class="s">&#39;PREDICTED_CHAIN_TYPE&#39;</span><span class="p">,</span> <span class="s">&#39;LOCUS_NAME&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.VGENES&#39;</span><span class="p">,</span> <span class="s">&#39;DREGION.DGENES&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.JGENES&#39;</span><span class="p">,</span>
	<span class="s">&#39;FULL_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;STOP_CODONS&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.FR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR3.AA&#39;</span><span class="p">,</span> <span class="s">&#39;CDR3.AA&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.FR4.AA&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.FR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;CDR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.FR4.NT&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.CDR1.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR1.NT_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.NT_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;CDR3.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;CDR3.NT_LENGTH&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.VGENE_SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.JGENE_SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;DREGION.DGENE_SCORES&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.SHM.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.SHM.AA&#39;</span><span class="p">,</span>
	<span class="s">&#39;GAPPED.VREGION.FR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR3.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.CDR3.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.JREGION.FR4.AA&#39;</span><span class="p">,</span>
	<span class="s">&#39;GAPPED.VREGION.FR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.CDR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.JREGION.FR4.NT&#39;</span><span class="p">,</span>
	<span class="s">&#39;VREGION.VGENE_QUERY_START&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.VGENE_QUERY_END&#39;</span><span class="p">,</span>
	<span class="s">&#39;JREGION.JGENE_QUERY_START&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.JGENE_QUERY_END&#39;</span><span class="p">,</span>
	<span class="s">&#39;NOTES&#39;</span><span class="p">,</span>
	<span class="n">expIdentifier</span><span class="p">,</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">,</span> <span class="s">&#39;DATE_UPDATED&#39;</span><span class="p">,</span> <span class="s">&#39;FILENAME&#39;</span><span class="p">,</span> <span class="s">&#39;SETINGS&#39;</span>
<span class="p">]</span>


<span class="c"># ###########END OF GLOBAL VARIABLES DEFINITIONS ########################</span>

<span class="c"># GLOBAL FUNCTIONS USED BY THE QUERY CLASS #################3</span>

<span class="k">def</span> <span class="nf">get_allowed_file_types</span><span class="p">():</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Results from the query can be saved in many different file formats. This summarizes each of the file formats we currently support.</span>

<span class="sd">		.. note::</span>

<span class="sd">			The word &#39;flattened&#39; refers to how we handle documents returned from the database. Documents from cursors are returned as dictionaries.</span>
<span class="sd">			But most documents are nested using JSON format. For example DATA.JGENES would be a nested dictionary of:</span>
<span class="sd">				{&#39;DATA&#39;:</span>
<span class="sd">					&#39;JGENES&#39;:[]</span>
<span class="sd">				}</span>
<span class="sd">			So when we refer to flattened dictionaries as those whose dictionaries have only one level of keys. All sub-documents are seperated using</span>
<span class="sd">			&#39;.&#39; as a string in the key name. So the example above becomes:</span>
<span class="sd">				{&#39;DATA.JGENES&#39;:[]}</span>

<span class="sd">		..TAB::</span>

<span class="sd">			TAB delimited file.</span>
<span class="sd">			Results from a database query will always be flattened prior to saving to file.</span>
<span class="sd">			All field value types will be converted to strings. Lists are converted to strings using &#39;,&#39;.join(x)</span>

<span class="sd">		..CSV::</span>

<span class="sd">			Comma delimited file.</span>
<span class="sd">			Results from a database query will always be flattened prior to saving to file.</span>
<span class="sd">			All field value types will be converted to strings. Lists are converted to strings using &#39;|&#39;.join(x)</span>

<span class="sd">		..FLATJSON::</span>

<span class="sd">			Our custom JSON format where ever line in a file represents a &#39;flattened&#39; document in JSON format.</span>

<span class="sd">		..JSON::</span>

<span class="sd">			Our custom JSON forma where each line in a file represents a document in JSON format.</span>
<span class="sd">			Does not modify the results from a query. Only json.dumps is used to save results to file.</span>
<span class="sd">			Field value types are maintained (i.e. lists remain lists)</span>

<span class="sd">		..FASTA::</span>

<span class="sd">			FASTA file format.</span>
<span class="sd">			Results from a database query will always be flattened prior to saving to file.</span>
<span class="sd">			All field value types will be converted to strings.</span>
<span class="sd">			Any results that are not defined to be part of the sequence header will be reported in json format using the &#39;fasta_file_delimiter&#39; field</span>
<span class="sd">			(i.e. &gt;SEQHEADER &lt;{&#39;SEQ_ID&#39;:ObjectId()}</span>

<span class="sd">		..FASTQ::</span>

<span class="sd">			FASTQ file format.</span>
<span class="sd">			Results from a database query will always be flattened prior to saving to file.</span>
<span class="sd">			All field value types will be converted to strings.</span>
<span class="sd">			For results that do not have a QUALITY_SCORE, we will output a default quality value for each character</span>
<span class="sd">			Any results that are not defined to be part of the sequence header will be reported in json format using the &#39;fasta_file_delimiter&#39; field</span>
<span class="sd">			(i.e. @SEQHEADER &lt;{&#39;SEQ_ID&#39;:ObjectId()}</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">allowed_file_types</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;TAB&#39;</span><span class="p">,</span> <span class="s">&#39;JSON&#39;</span><span class="p">,</span> <span class="s">&#39;IGREP&#39;</span><span class="p">,</span> <span class="s">&#39;CSV&#39;</span><span class="p">,</span> <span class="s">&#39;FASTA&#39;</span><span class="p">,</span> <span class="s">&#39;FASTQ&#39;</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">allowed_file_types</span>


<span class="c"># ###### FUNCTIONS AND VARIABLES USED FOR MODIFYING QUERIES ###############</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	This section defines a series of variables and functions that will be used when modifying user queries.</span>

<span class="sd">	Some variables are used to redefine field names and query data types. It is used alongside the function process_field_value</span>
<span class="sd">	These variables define what are mongo-operators as compared to user defined field names, how to rename field names, and how to change the datatypes of select queires</span>

<span class="sd">	Flow of functions will go as follows:</span>
<span class="sd">	Key function, Parse_Mongo_Query_Expression -&gt; uses the parameter redirection_fields and calls the function Process_Field_Value</span>
<span class="sd">		The parameter, redirection_fields will either be set to:</span>
<span class="sd">			(a) redirect_seq_collection_fields OR</span>
<span class="sd">			(b) redirect_exp_collection_fields</span>
<span class="sd">	Key function Process_Field_Value -&gt; uses the parameter dict_defining_value_transformation</span>
<span class="sd">		The parameter dict_defining_value_transformation will either be set to:</span>
<span class="sd">			(a) fields_for_queries_seqs_collection (defined in modifying_seqs_collection_queries) OR</span>
<span class="sd">			(b) fields_for_queries_exps_collection</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="c"># FIRST LETS DEFINE HOW WE WANT TO ADDRESS/HANDLE QUERIES ON SPECIFIC FIELD NAMES</span>

<span class="c"># Any time a user wants to perform a query on the seqs collection using any of these fieldnames defined as keys, we will change the field name to the key&#39;s value</span>
<span class="c"># For example, DATA.VREGION.VGENES will be convereted to QUERY_DATA.VREGION.VGENES.PARSED_ALLELES</span>
<span class="c"># USAGE: new_field = redirect_seq_collection_fields[&#39;DATA.VREGION.VGENES&#39;] ==&gt; new_field is now equal to: &#39;QUERY_DATA.VREGION.VGENES.PARSED_ALLELES</span>
<span class="n">redirect_seq_collection_fields</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&#39;DATA.VREGION.VGENES&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;QUERY_&#39;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.PARSED_ALLELES&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;QUERY_DATA.&#39;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.PARSED_ALLELES&#39;</span><span class="p">,</span>
	<span class="s">&#39;DATA.DREGION.DGENES&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;QUERY_&#39;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.PARSED_ALLELES&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;QUERY_DATA.&#39;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.PARSED_ALLELES&#39;</span><span class="p">,</span>
	<span class="s">&#39;DATA.JREGION.JGENES&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;QUERY_&#39;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.PARSED_ALLELES&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;QUERY_DATA.&#39;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.PARSED_ALLELES&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c"># lets say a user wants to query for an experiment called &quot;MyFirstExp&quot;. Unfortunately, the user actually called their experiment &quot;My first exp&quot;.</span>
<span class="c"># We want to make sure that the user can still find his/her proper experiment without having to remember to use &#39;regular expressions&#39; or case insensitivity.</span>
<span class="c"># This is where this variable is useful. When creating experiments, we create duplicated fields of select fields in the experiments collection.</span>
<span class="c"># Any time a user wants to perform a query on the exps collection using any of the fields we know are duplicated (defined as keys in this variable), then we will change the field name to the key&#39;s value</span>
<span class="c"># For example, a user may request a query on EXPERIMENT_NAME : &#39;MyFirstExp&#39;. This query will be converted to &#39;DUPLICATED_FIELDS.EXPERIMENT_NAME&#39;:&#39;MyFirstExp&#39;. This will ensure that his/her query is found</span>

<span class="n">metadata_duplicated_fields</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Exps_Collection</span><span class="p">()[</span><span class="s">&#39;duplicated_fields&#39;</span><span class="p">]</span>
<span class="n">redirect_exp_collection_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">field_name</span><span class="p">:</span> <span class="s">&#39;DUPLICATED_FIELDS.&#39;</span> <span class="o">+</span> <span class="n">field_name</span> <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">metadata_duplicated_fields</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">Process_Field_Value</span><span class="p">(</span><span class="n">db_field_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function converts the queries provided for specific database field names into the format defined by the dictionary dict_defining_value_transformation</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		db_field_name : The field name of the database query. The field name should be in &#39;.&#39; notation (i.e. DATA.VREGION.VGENES)</span>
<span class="sd">		values : The specific query requested for that field name. Allowed formats: are str, list, int, float or lists of those formats</span>
<span class="sd">		dict_defining_value_transformation : A key-value pair defining how to transform values for each db_field_name. Unless modified by user, this variable will be equal to either fields_for_queries_seqs_collection or fields_for_queries_exps_collection (see functions below)</span>

<span class="sd">	&#39;&#39;&#39;</span>

	<span class="p">[</span><span class="n">db_field_name</span><span class="p">,</span> <span class="n">outer_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">Remove_Numbers_From_Field_Name</span><span class="p">(</span><span class="n">db_field_name</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">list_element</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>  <span class="c"># use a try/except, because we assume that teh user may have a better knowledge of the query. so if it should be an int, but now its a string, then default to what user passed in. worst case scenario, the query will return no results</span>
				<span class="c"># always ignore types that are REGULAR EXPRESSIONS. Cannot compile those to match datatype</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)))))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">({</span><span class="s">&#39;$regex&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">})))):</span>
					<span class="c"># this means that the value is a regular expression.</span>
					<span class="c"># in order to convert a re format from python object to a dictionary, do the following:</span>
					<span class="n">re_dict_format</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">list_element</span><span class="p">))</span>  <span class="c"># first dump the object to a string using bson, then load it as a dic using json</span>
					<span class="c"># now we can actually modify the string that has been made into a regular expression (it is found in &#39;$regex key&#39;)</span>
					<span class="n">re_dict_format</span><span class="p">[</span><span class="s">&#39;$regex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_defining_value_transformation</span><span class="p">[</span><span class="n">db_field_name</span><span class="p">](</span><span class="n">re_dict_format</span><span class="p">[</span><span class="s">&#39;$regex&#39;</span><span class="p">])</span>
					<span class="c"># now that we have formated the variable correctly, lets update v, but convert  this dict back into python re format</span>
					<span class="n">v</span> <span class="o">=</span> <span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">re_dict_format</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">v</span> <span class="o">=</span> <span class="n">dict_defining_value_transformation</span><span class="p">[</span><span class="n">db_field_name</span><span class="p">](</span><span class="n">list_element</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="k">print</span> <span class="s">&quot;Error in compiling fields values: {0}. Error {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
				<span class="n">v</span> <span class="o">=</span> <span class="n">list_element</span>
			<span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>  <span class="c"># use a try/except, because we assume that the user may have a better knowledge of the query. so if it should be an int, but now its a string, then default to what user passed in. worst case scenario, the query will return no results</span>
			<span class="c"># always ignore types that are REGULAR EXPRESSIONS. Cannot compile those to match datatype</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)))))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">({</span><span class="s">&#39;$regex&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">})))):</span>
					<span class="c"># this means that the value is a regular expression.</span>
					<span class="c"># in order to convert a re format from python object to a dictionary, do the following:</span>
					<span class="n">re_dict_format</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>  <span class="c"># first dump the object to a string using bson, then load it as a dic using json</span>
					<span class="c"># now we can actually modify the string that has been made into a regular expression (it is found in &#39;$regex key&#39;</span>
					<span class="n">re_dict_format</span><span class="p">[</span><span class="s">&#39;$regex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_defining_value_transformation</span><span class="p">[</span><span class="n">db_field_name</span><span class="p">](</span><span class="n">re_dict_format</span><span class="p">[</span><span class="s">&#39;$regex&#39;</span><span class="p">])</span>

					<span class="c"># now that we have formated the variable correctly, lets update v, but convert  this dict back into python re format</span>
					<span class="n">temp</span> <span class="o">=</span> <span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">re_dict_format</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="n">dict_defining_value_transformation</span><span class="p">[</span><span class="n">db_field_name</span><span class="p">](</span><span class="n">values</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">print</span> <span class="s">&quot;Error in compiling fields values: {0}. Error {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">values</span>
	<span class="k">return</span> <span class="n">temp</span>


<span class="k">def</span> <span class="nf">Modify_Key_Name_To_Include_Data</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Adds a &#39;DATA&#39; string before a field name. i.e. &#39;VREGION.VGENES&#39; becomes &#39;DATA.VREGION.VGENES&#39;</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields_above_data_key</span><span class="p">:</span>
		<span class="n">first_field</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">first_field</span> <span class="o">!=</span> <span class="n">query_data_key_name</span> <span class="ow">and</span> <span class="n">first_field</span> <span class="o">!=</span> <span class="s">&#39;DATA&#39;</span><span class="p">:</span>
			<span class="n">key</span> <span class="o">=</span> <span class="s">&#39;DATA.&#39;</span> <span class="o">+</span> <span class="n">key</span>
	<span class="k">return</span> <span class="n">key</span>


<span class="k">def</span> <span class="nf">Parse_Mongo_Query_Expression</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">field_name</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="o">=</span><span class="p">{},</span> <span class="n">redirection_fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function will attempt to ensure that the values for each field name are properly formatted.</span>
<span class="sd">		It will redirect field names to make sure they use indexed fields. It will ensure that the values for each query are in the proper format.</span>

<span class="sd">		For example: It will always make sure queries on CDR3.AA are uppercased, and that any queries involving DATA.VREGION.VGENES to QUERY_DATA.VREGION.VGENES.PARSED_ALLELES</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		query : dict</span>
<span class="sd">			This should be a dictionary used as a MongoDB query</span>
<span class="sd">		field_name : string</span>
<span class="sd">			name of the current &#39;parent&#39; document. Should start as empty string when first calling function.</span>
<span class="sd">		dict_defining_value_transformation : dict</span>
<span class="sd">			A key-value pair defining how to transform values for each db_field_name. Unless modified by user, this variable will be equal to either fields_for_queries_seqs_collection or fields_for_queries_exps_collection (see functions below)</span>
<span class="sd">		redirection_fields : dict</span>
<span class="sd">			key-value pair where fields/keys defined in this dictionary will be redirected to their values. If not defined by user then it would be equal to redirect_seq_collection_fields or redirect_exp_collection_fields</span>
<span class="sd">		modify_query_values_to_follow_db_schema : boolean</span>
<span class="sd">			If True, then it will modify the values in a database query to match those defined by dict_defining_value_transformation</span>
<span class="sd">		redirect_fields_for_improved_queries : boolean</span>
<span class="sd">			If True, then change/rename the field names of the query using the values defined by redirection_fields</span>

<span class="sd">	&#39;&#39;&#39;</span>

	<span class="c"># do not change the values to any keys in a query in the following list. these values are standard numbers/booleans based on a mongodb query and not the field it self (for example fields that are strings still will use True/False for $exists)</span>
	<span class="n">operators_do_not_modify</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;$size&#39;</span><span class="p">,</span> <span class="s">&#39;$exists&#39;</span><span class="p">,</span> <span class="s">&#39;$mod&#39;</span><span class="p">,</span> <span class="s">&#39;$options&#39;</span><span class="p">,</span> <span class="s">&#39;$type&#39;</span><span class="p">,</span> <span class="s">&#39;$meta&#39;</span><span class="p">,</span> <span class="s">&#39;$language&#39;</span><span class="p">,</span> <span class="s">&#39;$geoWithin&#39;</span><span class="p">,</span> <span class="s">&#39;$geoIntersects&#39;</span><span class="p">,</span> <span class="s">&#39;$near&#39;</span><span class="p">,</span> <span class="s">&#39;$minDistance&#39;</span><span class="p">,</span> <span class="s">&#39;$maxDistance&#39;</span><span class="p">,</span> <span class="s">&#39;$geometry&#39;</span><span class="p">,</span> <span class="s">&#39;$nearSphere&#39;</span><span class="p">]</span>

	<span class="c"># 1) we do not use a &#39;text&#39; index in our schema currently, so we are not handling how to parse this query; without a &#39;text index&#39; on a specific field then any query that defines this field will raise an error in mongodb</span>
	<span class="c"># 2) the &#39;$where&#39; command uses javascript functions to perform a query. again we will not parse these, and leave these special cases to the user</span>
	<span class="c"># 3) comment mongo operator is just for adding comments to a query</span>
	<span class="n">operators_do_not_parse</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;$text&#39;</span><span class="p">,</span> <span class="s">&#39;$where&#39;</span><span class="p">,</span> <span class="s">&#39;$comment&#39;</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">RunParser</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">,</span> <span class="n">redirection_fields</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="p">):</span>
		<span class="n">ignore_mongo_operators</span> <span class="o">=</span> <span class="n">operators_do_not_modify</span> <span class="o">+</span> <span class="n">operators_do_not_parse</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
			<span class="n">copied_query</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()}</span>
			<span class="c"># loop through all keys in dictionary</span>
			<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">copied_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="c"># rename keys that should be redirected. this will only work if the field is explicitly written in dot notation. For example, it will not work if its CDR3:{&#39;AA&#39;:&#39;APPL&#39;}. we cannot redirect this field to  QUERY_DATA.CDR3.AA</span>
				<span class="k">if</span> <span class="n">redirect_fields_for_improved_queries</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;$&#39;</span><span class="p">:</span>
					<span class="c"># key = Modify_Key_Name_To_Include_Data(key) ===&gt; was attempting to add &#39;DATA&#39; key to queries, but this would make confusing problems with exp collection vs seqs collection</span>

					<span class="p">[</span><span class="n">key_no_int</span><span class="p">,</span> <span class="n">outer_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Remove_Numbers_From_Field_Name</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">key_no_int</span> <span class="ow">in</span> <span class="n">redirection_fields</span><span class="p">:</span>
						<span class="n">popped_value</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
						<span class="n">key</span> <span class="o">=</span> <span class="n">redirection_fields</span><span class="p">[</span><span class="n">key_no_int</span><span class="p">](</span><span class="n">key</span><span class="p">)</span>
						<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">popped_value</span>

				<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ignore_mongo_operators</span><span class="p">:</span>  <span class="c"># operators_do_not_modify:</span>
					<span class="c"># do not change the values passed in for this field</span>
					<span class="c"># i.e. {&#39;field_name_a&#39;:{&#39;$exists&#39;:True}} =&gt; even if field name is a string, obviously the value to exists is only True/False, so do not modify the value of this field</span>
					<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>  <span class="c"># just reutrn the original query</span>
					<span class="k">continue</span>
				<span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;$&#39;</span><span class="p">:</span>  <span class="c"># key is a specific mongo operator</span>
					<span class="n">sub_field_name</span> <span class="o">=</span> <span class="n">field_name</span>  <span class="c"># sub_field_name stays the same, because a specific mongo operator does not add to a field name, just the mongo function</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># its not a mongo operator, so it must be a field name, add this as a subdocument in the query command using &#39;.&#39; notation</span>
					<span class="c"># for exampple if we are querying: {CDR3:{AA:&#39;ALPHA&#39;,&#39;NT&#39;:&#39;BETA&#39;}} then we will want to LOOK AT THE FOLLOWING FIELD NAMES: CDR3.AA, CDR3.NT</span>
					<span class="n">sub_field_name</span> <span class="o">=</span> <span class="n">field_name</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="k">if</span> <span class="n">field_name</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span> <span class="k">else</span> <span class="n">key</span>

				<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">each_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
						<span class="c"># if its a list, then recursively parse through each value of list</span>
						<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunParser</span><span class="p">(</span><span class="n">each_value</span><span class="p">,</span> <span class="n">sub_field_name</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">,</span> <span class="n">redirection_fields</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="p">)</span>
				<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
					<span class="c"># now that we always load dictionary using bson in above/parent fucntion, then the following if/elif statements should</span>
					<span class="c"># not occur. there should no longer be keys that say {&#39;$oid&#39;] or {&#39;$regex&#39;}. instead, they exist as ObjectId and re.copmile</span>
					<span class="c"># hardcoding object id conversions...</span>
					<span class="c"># no need to check recursifely this dictionary. it is an object id</span>
					<span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s">&#39;$oid&#39;</span><span class="p">]:</span>
						<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Process_Field_Value</span><span class="p">(</span><span class="n">sub_field_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">)</span>
					<span class="k">elif</span> <span class="s">&#39;$regex&#39;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
						<span class="c"># hardocindg regular expressions</span>
						<span class="c"># again the user requested using regular expressions , so no need to recursively check this dictionary.</span>
						<span class="c"># first process the regular epxression using process_field_value (only process &#39;$regex&#39; key</span>
						<span class="c"># once complete, use bson_loads to convert it into a python re variable</span>
						<span class="n">values</span><span class="p">[</span><span class="s">&#39;$regex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Process_Field_Value</span><span class="p">(</span><span class="n">sub_field_name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;$regex&#39;</span><span class="p">],</span> <span class="n">dict_defining_value_transformation</span><span class="p">)</span>
						<span class="c"># first uson json.dump to dump dictionary, then RELOAD IT using bson</span>
						<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bson_loads</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="c"># if its a dict, then just recursively pass in the dictionary rather than each index  in a list as above</span>
						<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunParser</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">sub_field_name</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">,</span> <span class="n">redirection_fields</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>  <span class="c"># assume anythign else is a specific query parameter/value. therefore, prcoess its field value</span>
					<span class="k">if</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="p">:</span>  <span class="c"># modify the value for this query</span>
						<span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Process_Field_Value</span><span class="p">(</span><span class="n">sub_field_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">)</span>

		<span class="k">else</span><span class="p">:</span>  <span class="c"># if the query was not actually a dictionary then it is probably from values in a list, or just singular values, so just process each field name</span>
			<span class="n">values</span> <span class="o">=</span> <span class="n">query</span>
			<span class="k">if</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="p">:</span>  <span class="c"># modify teh value for this query</span>
				<span class="n">query</span> <span class="o">=</span> <span class="n">Process_Field_Value</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">query</span>

	<span class="c"># first take the provided query and ENSURE that it will be in BSON format:</span>
	<span class="c"># dump query as a string using bson dumps =&gt; handles ObjectIds, and regular expression values</span>
	<span class="c"># once dumped, reload is as a bson to ensure that any previous dictionaries which should be objects (such as object id and regex) are represtend properly</span>
	<span class="n">query</span> <span class="o">=</span> <span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">query</span><span class="p">))</span>

	<span class="c"># now that we have an ensured BSON format dictoinary, run the parsing function if user wants to modify field names or values</span>
	<span class="k">if</span> <span class="n">modify_query_values_to_follow_db_schema</span> <span class="ow">or</span> <span class="n">redirect_fields_for_improved_queries</span><span class="p">:</span>
		<span class="n">query</span> <span class="o">=</span> <span class="n">RunParser</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="p">,</span> <span class="n">redirection_fields</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">query</span>


<span class="k">def</span> <span class="nf">Remove_Numbers_From_Field_Name</span><span class="p">(</span><span class="n">db_field_name</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function is for handling MULTIKEY STRUCTURES IN MONGODB</span>
<span class="sd">		This will parse a field name provided in a query. If the field contains numbers, then it will remove the number.</span>
<span class="sd">		For example: &#39;VREGION.VGENES.1&#39;:&#39;IGHV3-2&#39; will be changed to &#39;VREGION.VGENES&#39;:&#39;IGHV3-2&#39;</span>
<span class="sd">		We remove the number because when modifying/redirecting a query to QUERY_DATA, we are not interested in the specific array element,</span>
<span class="sd">		but instead, we are interested in the main field name &#39;VREGION.VGENES&#39;</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		db_field_name : string</span>
<span class="sd">			This variable corresponds to the field name in the query</span>

<span class="sd">		Outputs</span>
<span class="sd">		------</span>
<span class="sd">		db_field_name : string</span>
<span class="sd">			Returns fieldname without number (i.e. VREGION.VGENE.1.AB returns VREGION.VGENE.AB)</span>
<span class="sd">		outer_fields : string</span>
<span class="sd">			Returns fieldname before the first number was encountered (i.e. VREGION.VGENE.1.AB returns VREGION.VGENE )</span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c"># first split the db_field_name by &#39;.&#39;</span>
	<span class="n">db_sub_fields</span> <span class="o">=</span> <span class="n">db_field_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>

	<span class="n">outer_field</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">reached_integer</span> <span class="o">=</span> <span class="bp">False</span>
	<span class="n">db_field_name</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">db_sub_fields</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="c"># test if integer</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
				<span class="n">reached_integer</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="c"># if its not a number, then it must be a string so , this is part of the field name we care about</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">reached_integer</span><span class="p">):</span>
				<span class="c"># keep track of any field before a number is reached</span>
				<span class="n">outer_field</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
			<span class="c"># keep track of string where numbers are removed</span>
			<span class="n">db_field_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
	<span class="n">db_field_name</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_field_name</span><span class="p">)</span>
	<span class="n">outer_field</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outer_field</span><span class="p">)</span>
	<span class="c"># outer_fields =&gt; fields name before the first number was encountered</span>
	<span class="c"># db_field_name = &gt; fieldname wihtout number</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">db_field_name</span><span class="p">,</span> <span class="n">outer_field</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">modifying_seqs_collection_queries</span><span class="p">():</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Outputs</span>
<span class="sd">		-------</span>
<span class="sd">		This function just returns a global variable that is used for handling user queries on the SEQS collection.</span>

<span class="sd">		We need to ensure that the queries on the seqs collection are in the proper data types for select fields.</span>
<span class="sd">		For example, we need to ensure that queries on VREGION.VGENE_SCORES are numbers, whereas queries on VREGION.VGENES are strings that are uppercased.</span>

<span class="sd">		This variable is meant to greatly help the user in getting the proper query result returned. It will define how to modify the value of any field</span>
<span class="sd">		quieried by the user. For each defined field in a query, the datatype of the query will be transformed to match the datatype of the requested field.</span>

<span class="sd">		Examples:</span>
<span class="sd">			This variable can be used to handle the following query:</span>
<span class="sd">				{DATA.VREGION.VGENES:&#39;3&#39;,&#39;DATA.CDR3.NT&#39;:&#39;aacg&#39;}</span>
<span class="sd">			will be converted to:</span>
<span class="sd">				{DATA.VREGION.VGENES:3,&#39;DATA.CDR3.NT&#39;:&#39;AACG&#39;}</span>

<span class="sd">		The structure of this variable is as follows: dict</span>
<span class="sd">			key: the field name whose datatype must be modified</span>
<span class="sd">			value: a lambda function defining how to modify the value in the query</span>

<span class="sd">			If a key is not defined in this variable, then those values will be handled by the function: default_fields_data_types</span>

<span class="sd">	&#39;&#39;&#39;</span>

	<span class="c"># these keys from mongo-db will usually be reported as an ObjectId.</span>
	<span class="n">keys_with_object_id</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">,</span> <span class="s">&#39;SEQ_ID&#39;</span><span class="p">,</span> <span class="s">&#39;EXP_ID&#39;</span><span class="p">]</span>
	<span class="c"># this will modify &#39;_id&#39;, &#39;EXP_ID&#39;, idIdentifier (anything that needs to be an object id)</span>
	<span class="n">fields_that_should_query_using_objectids</span> <span class="o">=</span> <span class="p">{</span><span class="n">oid_field</span><span class="p">:</span> <span class="n">convert_to_objectid</span> <span class="k">for</span> <span class="n">oid_field</span> <span class="ow">in</span> <span class="n">keys_with_object_id</span><span class="p">}</span>

	<span class="c"># this will modify any queries on the following fields by making them uppercase</span>
	<span class="n">fields_with_strings</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;DATE_UPDATED&#39;</span><span class="p">,</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">,</span> <span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">,</span>
		<span class="s">&#39;QUERY_DATA.VREGION.VGENES.PARSED_ALLELES&#39;</span><span class="p">,</span> <span class="s">&#39;QUERY_DATA.DREGION.DGENES.PARSED_ALLELES&#39;</span><span class="p">,</span> <span class="s">&#39;QUERY_DATA.JREGION.JGENES.PARSED_ALLELES&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.COMMAND&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.NOTES&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.PREDICTED_AB_SEQ.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.STRAND&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.PREDICTED_CHAIN_TYPE&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.PRODUCTIVE&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.LOCUS&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.VREGION.FR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.FR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.FR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.FR2.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.VREGION.CDR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.FR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.FR3.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.CDR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.CDR3.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.FR4.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.FR4.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.VREGION.VGENES&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.JGENES&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.DREGION.DGENES&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.ISOTYPE.GENE&#39;</span>

	<span class="p">]</span>
	<span class="n">fields_that_should_query_using_uppercase_strings</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_with_strings</span><span class="p">}</span>

	<span class="c"># this will modify any queries on the following fields by making them into floats</span>
	<span class="n">fields_with_floats</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;DATA.VREGION.SHM.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.SHM.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.SHM.NT_PER&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.SHM.AA_PER&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.JREGION.SHM.NT&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.SHM.AA&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.SHM.NT_PER&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.SHM.AA_PER&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.VREGION.VGENE_SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.JGENE_SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.DREGION.DGENE_SCORES&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.ISOTYPE.SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.ISOTYPE.PER_ID&#39;</span>
	<span class="p">]</span>
	<span class="n">fields_that_should_query_using_floats</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_with_floats</span><span class="p">}</span>	

	<span class="c"># this will modify any queries on the following fields by making them into int</span>
	<span class="n">fields_with_ints</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;DATA.VREGION.VGENE_QUERY_START&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.VGENE_QUERY_END&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.JREGION.JGENE_QUERY_START&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.JREGION.JGENE_QUERY_END&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.CDR3.NT_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR1.NT_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR2.NT_LENGTH&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.CDR3.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR1.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;DATA.VREGION.CDR2.AA_LENGTH&#39;</span><span class="p">,</span>
		<span class="s">&#39;DATA.ISOTYPE.MISMATCHES&#39;</span>
	<span class="p">]</span>
	<span class="n">fields_that_should_query_using_int</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_with_ints</span><span class="p">}</span>

	<span class="c"># combine all defined fields into a global variable; any fields not defined in these lists will be treated by the defaultdict function: schema.default_fields_data_types</span>
	<span class="n">fields_for_queries_seqs_collection</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">default_fields_data_types</span><span class="p">)</span>
	<span class="n">fields_for_queries_seqs_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_objectids</span><span class="p">)</span>
	<span class="n">fields_for_queries_seqs_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_uppercase_strings</span><span class="p">)</span>
	<span class="n">fields_for_queries_seqs_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_floats</span><span class="p">)</span>
	<span class="n">fields_for_queries_seqs_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_int</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">fields_for_queries_seqs_collection</span>


<span class="k">def</span> <span class="nf">modifying_exps_collection_queries</span><span class="p">():</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		outputs</span>
<span class="sd">		-------</span>
<span class="sd">		This function just returns a global variable that is used for handling user queries on the EXPS collection.</span>

<span class="sd">		We need to ensure that the queries on the exps collection are in the proper data types for select fields.</span>

<span class="sd">		This variable is meant to greatly help the user in getting the proper query result returned. It will define how to modify the value of any field</span>
<span class="sd">		quieried by the user. For each defined field in a query, the datatype of the query will be transformed to match the datatype of the requested field.</span>

<span class="sd">		Examples:</span>
<span class="sd">			This variable can be used to handle the following query:</span>
<span class="sd">				{&#39;DUPLICATED_FIELDS.EXPERIMENT_NAME&#39;:&#39;hOWDY THere&#39;}</span>
<span class="sd">			will be converted to:</span>
<span class="sd">				{&#39;DUPLICATED_FIELDS.EXPERIMENT_NAME&#39;:&#39;howdythere&#39;}</span>

<span class="sd">		The structure of this variable is as follows: dict</span>
<span class="sd">			key: the field name whose datatype must be modified</span>
<span class="sd">			value: a lambda function defining how to modify the value in the query</span>

<span class="sd">			If a key is not defined in this variable, then those values will be handled by the function: default_fields_data_types</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="c"># these keys from mongo-db will usually be reported as an ObjectId.</span>
	<span class="n">keys_with_object_id</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span>
	<span class="c"># this will modify &#39;_id&#39;, &#39;EXP_ID&#39;, idIdentifier (anything that needs to be an object id)</span>
	<span class="n">fields_that_should_query_using_objectids</span> <span class="o">=</span> <span class="p">{</span><span class="n">oid_field</span><span class="p">:</span> <span class="n">convert_to_objectid</span> <span class="k">for</span> <span class="n">oid_field</span> <span class="ow">in</span> <span class="n">keys_with_object_id</span><span class="p">}</span>

	<span class="c"># this will modify any queries on the following fields by making them lowercase</span>
	<span class="n">fields_to_lower</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;SEQUENCING_PLATFORM&#39;</span><span class="p">,</span> <span class="s">&#39;LAB&#39;</span><span class="p">,</span> <span class="s">&#39;OWNERS_OF_EXPERIMENT&#39;</span><span class="p">,</span> <span class="s">&#39;READ_ACCESS&#39;</span><span class="p">,</span>
		<span class="s">&#39;CHAIN_TYPES_SEQUENCED&#39;</span><span class="p">,</span> <span class="s">&#39;CELL_MARKERS_USED&#39;</span><span class="p">,</span> <span class="s">&#39;LIST_OF_POLYMERASES_USED&#39;</span><span class="p">,</span> <span class="s">&#39;PRIMER_SET_NAME&#39;</span><span class="p">,</span>
	<span class="p">]</span>
	<span class="n">fields_that_should_query_using_lowercase_strings</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_to_lower</span><span class="p">}</span>

	<span class="c"># this will modify any queries on the following fields by removing spaces and then lowercasign them</span>
	<span class="n">fields_to_lower_no_spaces</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;MID_TAG&#39;</span>
	<span class="p">]</span>
	<span class="n">fields_that_should_query_using_lowercase_strings_no_spaces</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_to_lower_no_spaces</span><span class="p">}</span>

	<span class="c"># this will handle how to modify a species name query</span>
	<span class="n">species_query</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;SPECIES&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">word</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">))])}</span>  <span class="c"># seperate value by spaces, then only capitalize the first word and lowercase all other words</span>

	<span class="c"># this will moidfy any queries on the following fields to booleans</span>
	<span class="n">fields_to_boolean</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;CONTAINS_RNA_SEQ_DATA&#39;</span><span class="p">,</span> <span class="s">&#39;VH:VL_PAIRED&#39;</span><span class="p">,</span> <span class="s">&#39;POST_SEQUENCING_PROCESSING:PHI_X_FILTER&#39;</span><span class="p">,</span> <span class="s">&#39;REVERSE_PRIMER_USED_IN_RT_STEP&#39;</span>
	<span class="p">]</span>
	<span class="n">fields_that_should_query_using_boolean</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="n">AttemptToConvertToBool</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_to_boolean</span><span class="p">}</span>

	<span class="c"># this will handle how a name should be queried</span>
	<span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;PERSON_WHO_PREPARED_LIBRARY&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()}</span>

	<span class="c"># this will modify any queries on the following fields by making them into int</span>
	<span class="n">fields_with_ints</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;CELL_NUMBER&#39;</span><span class="p">,</span> <span class="s">&#39;TARGET_READS&#39;</span>
	<span class="p">]</span>
	<span class="c"># should we consider using locale???</span>
	<span class="n">fields_that_should_query_using_int</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)))</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_with_ints</span><span class="p">}</span>

	<span class="c"># this will modify any queries on the fields that are present within the DUPLICATED_FIELDS subdocument of the exps metadata</span>
	<span class="n">fields_that_are_duplicated</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;DUPLICATED_FIELDS.&#39;</span> <span class="o">+</span> <span class="n">field_name</span><span class="p">:</span> <span class="n">convert_text_to_index_field_text</span> <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">schema</span><span class="o">.</span><span class="n">Exps_Collection</span><span class="p">()[</span><span class="s">&#39;duplicated_fields&#39;</span><span class="p">]}</span>

	<span class="n">fields_for_queries_exps_collection</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">default_metadata_fields</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_are_duplicated</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_objectids</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_int</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_boolean</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">species_query</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_lowercase_strings_no_spaces</span><span class="p">)</span>
	<span class="n">fields_for_queries_exps_collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fields_that_should_query_using_lowercase_strings</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">fields_for_queries_exps_collection</span>


<span class="c"># see function above to see how these variables work</span>
<span class="n">fields_for_queries_exps_collection</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">modifying_exps_collection_queries</span><span class="p">())</span>
<span class="n">fields_for_queries_seqs_collection</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">modifying_seqs_collection_queries</span><span class="p">())</span>


<span class="c"># #############END OF VARIABLES AND FUNCTION USED TO MODIFY QUERIES #########################</span>

<span class="c"># ##################FUNCTIONS USED WHEN SAVING QUERY RESULTS TO FILE ####################</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">	The following functions help the query class determine how to handle different fields when saving results to file.</span>
<span class="sd">	For example, TAB files must always have strings variables saved to file, so these function will assist in determining how to convert fields to strings</span>

<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">default_fields_to_file</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">splitter</span><span class="o">=</span><span class="s">&#39;,&#39;</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Converts all text in x into strings</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		x : dict/mongo document</span>
<span class="sd">		splitter : char, the character defines what will be used as the delimiter</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>
	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">splitter</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="s">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">default_fields_to_file_no_commas</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Converts all text in x into strings, but wants to avoid a comma delimiter (used for CSV files). </span>
<span class="sd">		The delimiter will always be &#39;|&#39;</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		x : dict/mongo document</span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>
	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="s">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ReturnStr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Convert x to str</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>
	<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ReturnListStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Converts a list into a delimited string</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		x : list of string characters</span>
<span class="sd">		d : char, the character defines what will be used as the delimiter</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ReturnListNotStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Converts a list of non-strings into a delimited string</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		x : list of non string values</span>
<span class="sd">		d : char, the character defines what will be used as the delimiter</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c"># v = str(x[0])</span>
	<span class="c"># for j in range(1,len(x)):</span>
	<span class="c"># v+=d+str(x[j])</span>
	<span class="c"># return v</span>
	<span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="s">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">define_saving_fields_to_file</span><span class="p">():</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function will define variables we will use to determine how to save non-string fields to a Non-JSON file.</span>
<span class="sd">		For example, VREGION.VGENES exists as a list of strings whereas VREGION.VGENE_SCORES exists as a list of numbers.</span>
<span class="sd">		When saving as a tab file we would want VREGION.VGENES to appear as a &#39;,&#39; or &#39;|&#39; (if using CSV format) seperated strings</span>
<span class="sd">		In this function we will create two variables:</span>

<span class="sd">			1) schema_fields_to_file -&gt; A key-value dictionary</span>
<span class="sd">				keys: represent fields from the database that we will save to the file</span>
<span class="sd">				values: a lambda function defining how to save the values from they field names</span>

<span class="sd">			2) schema_fields_to_file_avoid_commas -&gt; this is identical to the variable above (schema_fields_to_file) except it has special</span>
<span class="sd">				operations on fields that may have commas. So rather than using a &#39;,&#39; delimiter it uses a | delimiter for lists. This is useful</span>
<span class="sd">				when saving results as a CSV</span>

<span class="sd">		Usage</span>
<span class="sd">		-----</span>
<span class="sd">		Assuming the query returns the following document q={&#39;VREGION.VGENES:[&#39;A&#39;,&#39;B,&#39;C&#39;]}</span>
<span class="sd">		Then the following transformation will convert the query document:</span>

<span class="sd">			a = schema_fields_to_file[&#39;VREGION.VGENES&#39;](q[&#39;VREGION.VGENES&#39;])</span>
<span class="sd">			a is now equal to a string &#39;A&#39;,&#39;B&#39;,&#39;C&#39;</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c"># schema_fields_to_file =&gt; for each key, transforms the value from the database to the defined after getting a query result</span>
	<span class="c"># default functionality : use default_fields_to_file function</span>

	<span class="c"># these fields in the database should already be strings</span>
	<span class="n">should_be_strings</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;COMMAND&#39;</span><span class="p">,</span> <span class="s">&#39;NOTES&#39;</span><span class="p">,</span> <span class="s">&#39;DATE_UPDATED&#39;</span><span class="p">,</span>
		<span class="s">&#39;PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span> <span class="s">&#39;PREDICTED_AB_SEQ.AA&#39;</span><span class="p">,</span> <span class="s">&#39;STRAND&#39;</span><span class="p">,</span> <span class="s">&#39;PREDICTED_CHAIN_TYPE&#39;</span><span class="p">,</span> <span class="s">&#39;PRODUCTIVE&#39;</span><span class="p">,</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">,</span> <span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">,</span>
		<span class="s">&#39;VREGION.FR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR2.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;VREGION.CDR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.FR3.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;CDR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;CDR3.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;JREGION.FR4.NT&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.FR4.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;GAPPED.VREGION.FR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR1.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR1.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR2.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;GAPPED.VREGION.CDR2.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.CDR2.AA&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.VREGION.FR3.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;GAPPED.JREGION.FR4.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.JREGION.FR4.AA&#39;</span><span class="p">,</span>
		<span class="s">&#39;GAPPED.CDR3.NT&#39;</span><span class="p">,</span> <span class="s">&#39;GAPPED.CDR3.AA&#39;</span>
	<span class="p">]</span>

	<span class="c"># these fields in the database are not in string format (they are usually numbers)</span>
	<span class="n">convert_to_strings</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;SETTINGS&#39;</span><span class="p">,</span> <span class="s">&#39;FILENAME&#39;</span><span class="p">,</span>  <span class="c"># these are exceptions to the format. they are strings in the exps collection, but numbers in this colleciton. If its done right then they will actually be converted to their values in the exps collection by this API when requested</span>
		<span class="s">&#39;SEQ_ID&#39;</span><span class="p">,</span> <span class="s">&#39;EXP_ID&#39;</span><span class="p">,</span> <span class="s">&#39;_id&#39;</span><span class="p">,</span>
		<span class="s">&#39;VREGION.SHM.NT&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.SHM.AA&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.SHM.NT_PER&#39;</span><span class="p">,</span> <span class="s">&#39;VERGION.SHM.AA_PER&#39;</span><span class="p">,</span>
		<span class="s">&#39;JREGION.SHM.NT&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.SHM.AA&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.SHM.NT_PER&#39;</span><span class="p">,</span> <span class="s">&#39;JERGION.SHM.AA_PER&#39;</span><span class="p">,</span>
		<span class="s">&#39;VREGION.VGENE_QUERY_START&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.VGENE_QUERY_END&#39;</span><span class="p">,</span>
		<span class="s">&#39;JREGION.JGENE_QUERY_START&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.JGENE_QUERY_END&#39;</span>
		<span class="s">&#39;CDR3.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;CDR3.NT_LENGTH&#39;</span><span class="p">,</span>
		<span class="s">&#39;VREGION.CDR1.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR1.NT_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.AA_LENGTH&#39;</span><span class="p">,</span> <span class="s">&#39;VREGION.CDR2.NT_LENGTH&#39;</span><span class="p">,</span>
	<span class="p">]</span>

	<span class="c"># these fields in the database are lists of strings</span>
	<span class="n">convert_liststring_to_strings</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;VREGION.VGENES&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.JGENES&#39;</span><span class="p">,</span> <span class="s">&#39;DREGION.DGENES&#39;</span><span class="p">,</span> <span class="s">&#39;ISOTYPE.GENE&#39;</span>
	<span class="p">]</span>

	<span class="n">convert_nonliststring_to_strings</span> <span class="o">=</span> <span class="p">[</span>
		<span class="s">&#39;VREGION.VGENE_SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;JREGION.JGENE_SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;DREGION.DGENE_SCORES&#39;</span><span class="p">,</span>
		<span class="s">&#39;ISOTYPE.MISMATCHES&#39;</span><span class="p">,</span> <span class="s">&#39;ISOTYPE.SCORES&#39;</span><span class="p">,</span> <span class="s">&#39;ISOTYPE.PER_ID&#39;</span>
	<span class="p">]</span>

	<span class="c"># Initialize the main variable that will define how to transform different fields from the database</span>
	<span class="n">schema_fields_to_file</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">default_fields_to_file</span><span class="p">)</span>

	<span class="c"># WE WILL BE CHANGING THE FORMAT OF LOCUS!!!</span>
	<span class="n">schema_fields_to_file</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

	<span class="c"># If we think this is a waste of computation since they are already strings, then we can remove this line</span>
	<span class="n">schema_fields_to_file</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">should_be_strings</span><span class="p">})</span>

	<span class="c"># Now set the lambda function for making non-string fields</span>
	<span class="n">schema_fields_to_file</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">convert_to_strings</span><span class="p">})</span>

	<span class="c"># Now set the lambda function for making lists of strings into strings</span>
	<span class="n">schema_fields_to_file</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ReturnListStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">convert_liststring_to_strings</span><span class="p">})</span>

	<span class="c"># Now set the lambda function for making lists of numbers into strings</span>
	<span class="n">schema_fields_to_file</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ReturnListNotStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">convert_nonliststring_to_strings</span><span class="p">})</span>

	<span class="c">#</span>
	<span class="c"># Now we need to set a special variable that is identical to the schema_fields_to_file, except is to be used when saving as CSV format</span>
	<span class="n">schema_fields_to_file_avoid_commas</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">default_fields_to_file_no_commas</span><span class="p">)</span>

	<span class="c"># Copy the variable schema_fields_to_file into this variable</span>
	<span class="k">for</span> <span class="n">s_keys</span><span class="p">,</span> <span class="n">s_values</span> <span class="ow">in</span> <span class="n">schema_fields_to_file</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
		<span class="n">schema_fields_to_file_avoid_commas</span><span class="p">[</span><span class="n">s_keys</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_values</span>

	<span class="c"># Now set the lambda function for making list of strings into strings BUT dont use comma delimiter, use &#39;|&#39; instead</span>
	<span class="n">schema_fields_to_file_avoid_commas</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ReturnListStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;|&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">convert_liststring_to_strings</span><span class="p">})</span>

	<span class="c"># Now set the lambda function for making lists of numbers into strings BUT dont use comma delimiter, use &#39;|&#39; instead</span>
	<span class="n">schema_fields_to_file_avoid_commas</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">field</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ReturnListNotStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;|&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">convert_nonliststring_to_strings</span><span class="p">})</span>

	<span class="k">return</span> <span class="n">schema_fields_to_file</span><span class="p">,</span> <span class="n">schema_fields_to_file_avoid_commas</span>

<span class="c"># See the function Process_Cursor_For_Output_File to see how these two variables are used</span>
<span class="p">[</span><span class="n">schema_fields_to_file</span><span class="p">,</span> <span class="n">schema_fields_to_file_avoid_commas</span><span class="p">]</span> <span class="o">=</span> <span class="n">define_saving_fields_to_file</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">Get_Schema_Details</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span> <span class="n">projected_fields</span><span class="p">,</span> <span class="n">allTrue</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function is used to predict what fields will be returned from the database based on the project query.</span>
<span class="sd">		This function assumes the user is using a simple PROJECT command and is not using the aggregation framework methods. See function below for handling aggregation pipelines (Get_Schema_Details_Aggregation_Pipeline).</span>
<span class="sd">		This function is useful because when saving results as TAB or CSV format, then we can predict what fields we should see given the schema and query.</span>
<span class="sd">		So saving to a TAB or CSV file will not create unnecessary columns unless it has to.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		possible_metadata_fields : A list of documents from the exps collection. Each document should have an &#39;anlysis_schema&#39; field if it was annotated.</span>
<span class="sd">		projected_fields : A dictionary that corresponds to a mongo-db projection (see http://docs.mongodb.org/manual/reference/method/db.collection.find/)</span>
<span class="sd">		allTrue	: boolean varaible defining whether all projected_fields have a &#39;1&#39;</span>

<span class="sd">		Outputs</span>
<span class="sd">		-------</span>
<span class="sd">		possible_fields : A list of fields that should appear from the query and therefore should appear in the file</span>
<span class="sd">		analyses_types 	: A list of analyses_types (i.e. IMGT) that will also appear based on the projection</span>
<span class="sd">		recombination_types : A list of recombination types that will appear based on the projection</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">analyses_types</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">recombination_types</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="c"># During database insertion, fields that are stored above &#39;DATA&#39; field (i.e. analysis_name) will not appear in the experiment field &#39;analysis_schema&#39;</span>
	<span class="c"># But because we know about these fields since these fields are added in by our insert function, then we will explicitly state them here</span>
	<span class="n">overall_schema</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_above_data_key</span><span class="p">}</span>

	<span class="c"># Traverse through the list of possible fields (based on the exp ids selected for queries (see function GetIdIntersection))</span>
	<span class="c"># For each experiment, go through the analysis schema, and add to the list of possible fields that can be reported</span>
	<span class="k">for</span> <span class="n">each_metadata</span> <span class="ow">in</span> <span class="n">possible_metadata_fields</span><span class="p">:</span>
		<span class="k">if</span> <span class="s">&#39;ANALYSIS_SCHEMA&#39;</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">:</span>
			<span class="n">schema_keys</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">each_metadata</span><span class="p">[</span><span class="s">&#39;ANALYSIS_SCHEMA&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">schema_keys</span><span class="p">:</span>
				<span class="n">f</span> <span class="o">=</span> <span class="s">&#39;DATA.&#39;</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="c"># Add this field to the overall_schema variable. We expect this field to appear in the output at least once</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

		<span class="k">if</span> <span class="s">&#39;ANALYSES_COUNT&#39;</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">each_analysis</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">[</span><span class="s">&#39;ANALYSES_COUNT&#39;</span><span class="p">]:</span>
				<span class="n">analyses_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">each_analysis</span><span class="p">)</span>
				<span class="c"># Only choose recombination types whose count &gt; 0</span>
				<span class="n">recombination_types</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">recomb</span> <span class="k">for</span> <span class="n">recomb</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">[</span><span class="s">&#39;ANALYSES_COUNT&#39;</span><span class="p">][</span><span class="n">each_analysis</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

	<span class="n">projected_fields</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">projected_fields</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">projected_fields</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="c"># User did not define any fields to project</span>
		<span class="n">projected_fields</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">not_integer_projections</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">projections</span> <span class="ow">in</span> <span class="n">projected_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
		<span class="n">values</span> <span class="o">=</span> <span class="n">projected_fields</span><span class="p">[</span><span class="n">projections</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="n">projected_fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span>
			<span class="c"># Keep track of fields in the projection that are dictionaries instead of integers (again refer to MongoDB find format)</span>
			<span class="n">not_integer_projections</span><span class="p">[</span><span class="n">projections</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

	<span class="k">if</span> <span class="n">projected_fields</span> <span class="o">==</span> <span class="p">{}:</span>
		<span class="c"># If undefined, then mongo will return all possible fields for a document, so we know that all fields that appear in overall_schema should appear</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
			<span class="n">overall_schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="k">elif</span> <span class="n">allTrue</span><span class="p">:</span>
		<span class="c"># All of the fields in the projection are listed to appear, so initialize overall_schema as 0 so that we can convert back fields in projection to 1</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
			<span class="n">overall_schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="c"># All of the fields in the project are listed to not appear, so initialize overall_schema to 1 so that we can convert back fields to 0 based on projections</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
			<span class="n">overall_schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

	<span class="k">for</span> <span class="n">projections</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">projected_fields</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
		<span class="k">if</span> <span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="c"># Suppress these fields/these will not appear in the file</span>
			<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">fields</span> <span class="o">==</span> <span class="n">projections</span><span class="p">:</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">elif</span> <span class="n">fields</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">projections</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">):</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># These fields will appear in the file</span>
			<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">fields</span> <span class="o">==</span> <span class="n">projections</span><span class="p">:</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
				<span class="k">elif</span> <span class="n">fields</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">projections</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">):</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

	<span class="c"># Any field in the projection that was not a number was probably  a complex projection operator (such as slice operator)</span>
	<span class="c"># So for all of these fields, change their schema values to 1 because they will probably APPEAR in the file</span>
	<span class="k">for</span> <span class="n">projections</span> <span class="ow">in</span> <span class="n">not_integer_projections</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">fields</span> <span class="o">==</span> <span class="n">projections</span><span class="p">:</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">elif</span> <span class="n">fields</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">projections</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">):</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

	<span class="c"># When processing results from the database, we alwasy want to remove &#39;DATA&#39; from the results because it just looks ugly, so remove fields that have the DATA prefix.</span>
	<span class="n">possible_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span> <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA.&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">field</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">possible_fields</span><span class="p">))),</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">analyses_types</span><span class="p">))),</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">recombination_types</span><span class="p">)))]</span>


<span class="k">def</span> <span class="nf">Get_Schema_Details_Aggregation_Pipeline</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span> <span class="n">aggregation_pipeline_query</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function is used to predict what fields will be returned from the database based on a mongodb aggregation function</span>
<span class="sd">		This function is useful because when saving results as TAB or CSV format, then we can predict what fields we should see given the schema and query.</span>
<span class="sd">		So saving to a TAB or CSV file will not create unnecessary columns unless it has to.</span>

<span class="sd">		Projections from an aggregation will be slightly more complicated than simple projection from a find command. Therefore we needed a special function to handle aggregation functions.</span>
<span class="sd">		For example, fields in an aggregation function can be renamed, or projected, or new fields can be added.</span>
<span class="sd">		We need to keep track of all possible fields so that we can predict proper field names that appear in TAB/CSV file.</span>
<span class="sd">		It would be annoying to a have a file with a different number of tabs in each line; this function helps prevent that by saying before hand what fields should appear.</span>

<span class="sd">		Understanding this function requires a good undestanding of mongodb aggreagation methods.</span>
<span class="sd">		Reference: http://docs.mongodb.org/manual/aggregation/</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		possible_metadata_fields : A list of documents from the exps collection. Each document should have an &#39;anlysis_schema&#39; field if it was annotated.</span>
<span class="sd">		projected_fields : A dictionary that corresponds to a mongo-db projection (see http://docs.mongodb.org/manual/reference/method/db.collection.find/)</span>
<span class="sd">		allTrue	: boolean varaible defining whether all projected_fields have a &#39;1&#39;</span>

<span class="sd">		Outputs</span>
<span class="sd">		-------</span>
<span class="sd">		possible_fields : A list of fields that should appear from the query and therefore should appear in the file</span>
<span class="sd">		analyses_types 	: A list of analyses_types (i.e. IMGT) that will also appear based on the projection</span>
<span class="sd">		recombination_types : A list of recombination types that will appear based on the projection</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="k">def</span> <span class="nf">get_new_field_name</span><span class="p">(</span><span class="n">new_field_name</span><span class="p">,</span> <span class="n">original_field</span><span class="p">,</span> <span class="n">overall_schema</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Parses a projection given by new_field_name which contains a  mixture of a field to project and mongod-db operators on how to project the field</span>
<span class="sd">			Once successfully parsed and the actual field name being projected is determined, updates overall_schema variable </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">new_field</span> <span class="o">=</span> <span class="n">new_field_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.$&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">original_field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;$&#39;</span><span class="p">:</span>
			<span class="n">found_a_value</span> <span class="o">=</span> <span class="bp">False</span>
			<span class="k">if</span> <span class="n">original_field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;$$CURRENT.&#39;</span><span class="p">):</span>
				<span class="n">old_field</span> <span class="o">=</span> <span class="n">original_field</span><span class="p">[</span><span class="mi">10</span><span class="p">:]</span>
			<span class="c"># id field has to start with $ mongo operator</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">old_field</span> <span class="o">=</span> <span class="n">original_field</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
			<span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="c"># so we found all values that contain the old key name</span>
				<span class="k">if</span> <span class="n">each_key</span> <span class="o">==</span> <span class="n">old_field</span><span class="p">:</span>
					<span class="n">found_a_value</span> <span class="o">=</span> <span class="bp">True</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">new_field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># new field name</span>
				<span class="k">elif</span> <span class="n">each_key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">old_field</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">):</span>
					<span class="n">found_a_value</span> <span class="o">=</span> <span class="bp">True</span>
					<span class="n">new_key</span> <span class="o">=</span> <span class="n">new_field</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">old_field</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">each_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">old_field</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="n">found_a_value</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="n">new_field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">overall_schema</span><span class="p">[</span><span class="n">new_field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

	<span class="n">possible_fields</span> <span class="o">=</span> <span class="n">fields_above_data_key</span>
	<span class="n">overall_schema</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">possible_fields</span><span class="p">:</span>
		<span class="n">overall_schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="n">analyses_types</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">recombination_types</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="c"># Traverse through the list of possible fields (based on the exp ids selected for queries (see function GetIdIntersection))</span>
	<span class="c"># For each experiment, go through the analysis schema, and add to the list of possible fields that can be reported</span>
	<span class="k">for</span> <span class="n">each_metadata</span> <span class="ow">in</span> <span class="n">possible_metadata_fields</span><span class="p">:</span>
		<span class="k">if</span> <span class="s">&#39;ANALYSIS_SCHEMA&#39;</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">:</span>
			<span class="n">schema</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">each_metadata</span><span class="p">[</span><span class="s">&#39;ANALYSIS_SCHEMA&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)):</span>
				<span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="s">&#39;DATA.&#39;</span> <span class="o">+</span> <span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

		<span class="k">if</span> <span class="s">&#39;ANALYSES_COUNT&#39;</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">each_analysis</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">[</span><span class="s">&#39;ANALYSES_COUNT&#39;</span><span class="p">]:</span>
				<span class="n">analyses_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">each_analysis</span><span class="p">)</span>
				<span class="c"># Only choose recombination types whose count &gt; 0</span>
				<span class="n">recombination_types</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">recomb</span> <span class="k">for</span> <span class="n">recomb</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">each_metadata</span><span class="p">[</span><span class="s">&#39;ANALYSES_COUNT&#39;</span><span class="p">][</span><span class="n">each_analysis</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

	<span class="c"># Traverse through the users aggregation pipeline query</span>
	<span class="k">for</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="n">aggregation_pipeline_query</span><span class="p">:</span>
		<span class="c"># Fields are only projected when the pipeline query = $project. so when this occurs, keep track of what fields are being reported.</span>
		<span class="k">if</span> <span class="n">pipe</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;$project&#39;</span><span class="p">:</span>
			<span class="c"># Flatten the projection</span>
			<span class="n">sub_project_query</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">pipe</span><span class="p">[</span><span class="s">&#39;$project&#39;</span><span class="p">])</span>
			<span class="c"># Turn off all key fields by setting value to 0 (by default nothing is projected, unless explicitiley defined)</span>
			<span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="c"># By defaault, &#39;_id&#39; is always shown</span>
			<span class="n">overall_schema</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="c"># Traverse the key/values of the projection. The keys or fields SHOULD either be a fieldname to project or a mongodb project operator</span>
			<span class="c"># We need to extract just the fieldname parts of the projection and ignore mongo operators</span>
			<span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">sub_project_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="s">&#39;.$literal.&#39;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;.$literal.&#39;</span><span class="p">,</span> <span class="s">&#39;.&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
				<span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">each_key</span> <span class="o">==</span> <span class="n">field</span> <span class="ow">or</span> <span class="n">each_key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">field</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">):</span>
							<span class="n">overall_schema</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="c"># Include these fields from overall schema</span>
					<span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">each_key</span> <span class="o">==</span> <span class="n">field</span> <span class="ow">or</span> <span class="n">each_key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">field</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span><span class="p">):</span>
							<span class="n">overall_schema</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
				<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="n">operator</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;$&#39;</span><span class="p">:</span>
					<span class="c"># Get the field name from this operator</span>
					<span class="n">get_new_field_name</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">overall_schema</span><span class="p">)</span>	
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># It is most likely using a mongo operator to project a NEW FIELD, so add the NEW field to overall_schema</span>
					<span class="c"># Only consider the field name up until MONGO operator &#39;$&#39;</span>
					<span class="n">new_field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.$&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">new_field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="c"># Fields can be renamed in the $group stage of the aggregation pipeline, so try to predict any time that happens</span>
		<span class="k">elif</span> <span class="n">pipe</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;$group&#39;</span><span class="p">:</span>
			<span class="c"># Turn off all key fields (by default nothing is projected, unless explicitiley defined)</span>
			<span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="p">:</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">operation_keys</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">pipe</span><span class="p">[</span><span class="s">&#39;$group&#39;</span><span class="p">])</span>
			<span class="c"># Traverse the ID operator. ID determines how to group sequences together</span>
			<span class="n">id_field</span> <span class="o">=</span> <span class="n">operation_keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;_id&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

			<span class="c"># Analyze the field names under &#39;_id&#39; for grouping</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">id_field</span><span class="p">:</span>
				<span class="c"># User said in the group stage that:{_id:null}.</span>
				<span class="c"># Only an id field will be made</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_field</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
				<span class="c"># User is only grouping by specific field. this field will be called &#39;ID&#39;</span>
				<span class="c"># Id must appear in data now</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c"># Id is a complex dictionary that groups values by multiple fields</span>
				<span class="n">overall_schema</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="n">id_field</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">id_field</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">id_keys</span><span class="p">,</span> <span class="n">id_values</span> <span class="ow">in</span> <span class="n">id_field</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_values</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
						<span class="n">get_new_field_name</span><span class="p">(</span><span class="s">&#39;_id.&#39;</span> <span class="o">+</span> <span class="n">id_keys</span><span class="p">,</span> <span class="n">id_values</span><span class="p">,</span> <span class="n">overall_schema</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="c"># No idea, so must rename the fields based on the new field name </span>
						<span class="n">new_field</span> <span class="o">=</span> <span class="n">id_keys</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.$&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">overall_schema</span><span class="p">[</span><span class="s">&#39;_id.&#39;</span> <span class="o">+</span> <span class="n">new_field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

			<span class="c"># Analyze all other field names under group</span>
			<span class="n">operation_keys</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">operation_keys</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">operation_keys</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
					<span class="n">get_new_field_name</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">overall_schema</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># No idea, so must rename the fields based on the new field name</span>
					<span class="n">new_field</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.$&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
					<span class="n">overall_schema</span><span class="p">[</span><span class="n">new_field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

	<span class="c"># Remove fields that have the DATA prefix</span>
	<span class="n">possible_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span> <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA.&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">field</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">overall_schema</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">possible_fields</span><span class="p">))),</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">analyses_types</span><span class="p">))),</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">recombination_types</span><span class="p">)))]</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	These next two function define how to process documents in a database cursor. We will pass each document from a cursor</span>
<span class="sd">	into one of these functions before saving results to a file. The cursor will modify the document based on the variables above</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">Simple_Process_Output</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="n">dump_to_string</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This is the simplest method that we use to process documents resulting from a database query.</span>
<span class="sd">		In this function, the following operations are performed on a query document:</span>
<span class="sd">		1) Remove the &#39;DATA&#39; key from documents. So every field under &#39;DATA&#39; are now raised one level -&gt; &#39;DATA.VREGION.VGENES&#39; becomes &#39;VREGION.VGENES&#39;</span>
<span class="sd">		2) Convert an object id from a document into a string</span>
<span class="sd">		3) Concatenate the SeqId and ExpId field into a single string</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		document : dict</span>
<span class="sd">			A query document</span>
<span class="sd">		dump_to_string : boolean</span>
<span class="sd">			If true, then a string is returned</span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">RemoveObjId</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
	<span class="n">data_info</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;DATA&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">data_info</span><span class="p">:</span>
		<span class="n">document</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_info</span><span class="p">)</span>
	<span class="c"># Concatenate the exp id to the seq id</span>
	<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">document</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">document</span><span class="p">:</span>
		<span class="n">document</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">document</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;::&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">])</span>
	<span class="k">if</span> <span class="n">dump_to_string</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">document</span>
	<span class="c"># Dump data</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
	<span class="k">except</span><span class="p">:</span>
		<span class="c"># Try to use bson dump</span>
		<span class="k">return</span> <span class="n">bson_dumps</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Process_Cursor_For_Output_File</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="n">schema_output_fnc</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function is another method used for processing mongo documents resuling from a database query.</span>
<span class="sd">		It is meant to be used when saving a document as a flattened dictionary in a specific file format only: Either FASTQ, FASTA, TAB, CSV, or IGREP files.</span>
<span class="sd">		It is not used when saving results as a JSON format.</span>

<span class="sd">		In this function, the following operation are performed on a query document:</span>

<span class="sd">		1) Remove the &#39;DATA&#39; key from documents. So every field under &#39;DATA&#39; are now raised one level -&gt; &#39;DATA.VREGION.VGENES&#39; becomes &#39;VREGION.VGENES&#39;</span>

<span class="sd">		2) Flatten all documents so that they are no longer nested; while flattenign documents, convert any objectids to strings</span>

<span class="sd">		3) Use the variable &#39;schema_output_fnc&#39; to define exactly how to convert specific fields in the document to string format</span>

<span class="sd">		4) Concatenate the SeqId and ExpId field into a single string</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		document : A document or dictionary from a mongo db query</span>
<span class="sd">		schema_output_fnc : A dictionary whose keys refer to a specific database field and whose value is a lamda function defining how to convert that field to a string</span>
<span class="sd">		See the global variables schema_fields_to_file and schema_fields_to_file_avoid_commas</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="k">if</span> <span class="n">schema_output_fnc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">schema_output_fnc</span> <span class="o">=</span> <span class="n">schema_fields_to_file</span>

	<span class="n">data_info</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;DATA&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">data_info</span><span class="p">:</span>
		<span class="n">document</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_info</span><span class="p">)</span>
	<span class="c"># 1 million lines =&gt; takes 30 seconds to perform step using CYTHON, takes 1 minute to perform step using python code</span>
	<span class="n">document</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>

	<span class="c"># Force values from docs to be strings</span>
	<span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">document</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="c"># Its not a string, we need to modify value to string using schema_fields_to_file</span>
			<span class="n">document</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">schema_output_fnc</span><span class="p">[</span><span class="n">field</span><span class="p">](</span><span class="n">value</span><span class="p">)</span>

	<span class="c"># Concatenate the exp id to the seq id</span>
	<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">document</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">document</span><span class="p">:</span>
		<span class="n">document</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">document</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;::&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">])</span>

	<span class="k">return</span> <span class="n">document</span>
<span class="c"># ### END OF FUNCTIONS USED FOR HANDLING METHODS FOR SAVING RESULTS TO A FILE ######</span>

<span class="c"># ####FUNCTIONS FOR FILTERING QUERIES BASED ON USER PERMISSIONS #####</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	This following section are function(s) we use to filter out results from users based on their permissions.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">GetIdIntersection</span><span class="p">(</span><span class="n">list_of_allowed_ids</span><span class="p">,</span> <span class="n">id_query</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function will take the intersection of all possible experiments the user wants to search AND has access to</span>
<span class="sd">		So it will make sure that the user only runs a query on the seqs collection using exp_ids defined by the intersection of all exp_ids requested</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		list_of_allowed_ids : It corresponds to all experiments the user has access to</span>
<span class="sd">								The following values are allowed for list_of_allowed_ids: (a) a single object ID, (b) a list of ObjectIds, (c) a list of lists of ObjectIds</span>
<span class="sd">		id_query : A mongo query on &#39;_id&#39; (exps collection) or &#39;EXP_ID&#39; (seqs collection)</span>
<span class="sd">					The following values are allowed for id_query: (a) single value that can be converted to an ObjectId, (b) dictionary containing the following keys only: &#39;$eq&#39;,&#39;$in&#39;,&#39;$ne&#39;, &#39;$nin&#39;,</span>

<span class="sd">		Summary</span>
<span class="sd">		-------</span>
<span class="sd">			a) First, it takes the intersection of all values in list_of_allowed_ids</span>
<span class="sd">			b) Then once this id list has been filtered down, it will analyze the input &#39;id_query&#39; using the rules discussed above</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="c"># single element passed in for list_of_allowed_ids</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_of_allowed_ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
		<span class="c"># convert to lists of lists...</span>
		<span class="n">list_of_allowed_ids</span> <span class="o">=</span> <span class="p">[[</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">list_of_allowed_ids</span><span class="p">)]]</span>
	<span class="c"># list passed in for list_of_allowed_ids</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="c"># make sure if the user wants a LIST OF LISTS, then every elment in TOP list is LIST; DO NOT allow a &#39;MIXTURE&#39; of some lists, some not lists</span>
		<span class="n">are_elements_lists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">list_of_allowed_ids</span><span class="p">]</span>

		<span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">are_elements_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="c"># no element was a list, so convert it into a list of lists</span>
			<span class="n">list_of_allowed_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">list_of_allowed_ids</span><span class="p">]</span>
		<span class="k">elif</span> <span class="nb">sum</span><span class="p">(</span><span class="n">are_elements_lists</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_allowed_ids</span><span class="p">):</span>
			<span class="c"># at least one elmeent was A LIST, but NOT ALL elements</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The list variable &#39;list_of_allowed_ids&#39; is improperly formatted. You may only pass in 1) a single value, 2) a list of possible values, or 3) a list of LISTS of possitble values. You passed in the following &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">list_of_allowed_ids</span><span class="p">))</span>

	<span class="c"># List_of_allowed_ids has been properly formatted as list of lists of object_ids</span>

	<span class="c"># First convert all values into a unique set of ObjectId format</span>
	<span class="n">combined_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">list_of_allowed_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

	<span class="c"># Now obtain intersection of all ids defined in list_of_allowed_ids</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_allowed_ids</span><span class="p">)):</span>
		<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">list_of_allowed_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

	<span class="c"># Now if the user also passed in an id_query, calculate the intersection of that value</span>
	<span class="k">if</span> <span class="n">id_query</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_query</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">id_query</span><span class="p">])</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_query</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="c"># First we need to ensure that the id_query has been properly loaded into ObjectId&#39;s using bson_loads.</span>
			<span class="c"># To ensure this, we will first use dumps on the dictionary, and then reload using loads (So if an object id is {&#39;oid:&quot;&quot;} , this function will make it into a proper object =&gt; ObjectId(&quot;&quot;))</span>
			<span class="n">id_query</span> <span class="o">=</span> <span class="n">bson_loads</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">id_query</span><span class="p">))</span>
			<span class="n">operators_supported</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;$in&#39;</span><span class="p">,</span> <span class="s">&#39;$eq&#39;</span><span class="p">,</span> <span class="s">&#39;$ne&#39;</span><span class="p">,</span> <span class="s">&#39;$nin&#39;</span><span class="p">]</span>  <span class="c"># We only alow dictionaries with these keys</span>
			<span class="k">for</span> <span class="n">each_key</span><span class="p">,</span> <span class="n">query_val</span> <span class="ow">in</span> <span class="n">id_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="c"># Perform set intersection</span>
				<span class="k">if</span> <span class="n">each_key</span> <span class="o">==</span> <span class="s">&#39;$in&#39;</span><span class="p">:</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
						<span class="n">query_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">query_val</span><span class="p">]</span>
					<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">query_val</span><span class="p">])</span>
				<span class="k">elif</span> <span class="n">each_key</span> <span class="o">==</span> <span class="s">&#39;$eq&#39;</span><span class="p">:</span>
					<span class="c"># For &#39;_id&#39; and &#39;EXP_ID&#39; the value can never be EQUAL to a list</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
						<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The ObjectId can never be equal (&#39;$eq&#39;) to a list. If you want to allow a range of posible object id&#39;s, use &#39;$in&#39; operator</span><span class="se">\n</span><span class="s">Passed in query: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">id_query</span><span class="p">)))</span>
					<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">query_val</span><span class="p">)])</span>
				<span class="k">elif</span> <span class="n">each_key</span> <span class="o">==</span> <span class="s">&#39;$ne&#39;</span><span class="p">:</span>
					<span class="c"># For &#39;_id&#39; and &#39;EXP_ID&#39; the value can never be EQUAL to a list</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
						<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The ObjectId can never be not-equal (&#39;$ne&#39;) to a list. If you want to allow a range of posible object id&#39;s, use &#39;$in&#39; operator</span><span class="se">\n</span><span class="s">Passed in query: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">id_query</span><span class="p">)))</span>
					<span class="c"># Perform  the set difference between object ids (because we are saying != or $ne)</span>
					<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">query_val</span><span class="p">)])</span>
				<span class="k">elif</span> <span class="n">each_key</span> <span class="o">==</span> <span class="s">&#39;$nin&#39;</span><span class="p">:</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
						<span class="n">query_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">query_val</span><span class="p">]</span>
					<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">query_val</span><span class="p">])</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;You have requested the following query on experiment id: {0}. Currently we only support the following mongo operators on the exp id: {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">(</span><span class="n">id_query</span><span class="p">),</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">operators_supported</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">combined_ids</span> <span class="o">=</span> <span class="n">combined_ids</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">id_query</span><span class="p">)])</span>

	<span class="n">combined_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combined_ids</span><span class="p">)</span>

	<span class="c"># Return a proprely formatted mongo query: use $in if we have a range of ids to search, or just use a single value if we have only one object id to search</span>
	<span class="k">return</span> <span class="n">combined_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">combined_ids</span><span class="p">}</span>

<span class="c"># #####END OF FUNCTIONS FOR FILTER RESULTS BASED ON USER PERMISSIONS ####</span>


<span class="c"># Creating an instance of the class</span>
<div class="viewcode-block" id="RunQuery"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery">[docs]</a><span class="k">class</span> <span class="nc">RunQuery</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		A class for interacting with the BIGG Lab MongoDB database for NGS sequencing immunological repertoires.</span>
<span class="sd">		To run this query you need to define the path to the database with proper admin credentials,</span>
<span class="sd">		Optionally, you can define the name of the user requesting access to the database.</span>
<span class="sd">		If the name of the user is not provided, then it will automatically treat this person as an admin since the person accessing this class already knows admin privelages to the database.</span>
<span class="sd">		The name of the user requesting access to the database can be used to filter results from the database using the proxy query-class (See immunogrep_query_dbproxy_api.py)</span>

<span class="sd">		.. note::</span>

<span class="sd">			We assume that users directly using this class knows the admin username and password required to access the exps and seqs collections of the database.</span>
<span class="sd">		If this is not true, then users need to access the database via the proxy. Refer to module immunogrep_query_dbproxy_api.py</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		db_connect_data : three element tuple. Mandatory.</span>
<span class="sd">			The tuple defines how to connect to the mongodb instance: (username with access to seqs and exps collections, username password, path to database)</span>
<span class="sd">		dbuser : string. Optional. default = None</span>
<span class="sd">			This string should refer to a specific database user. If this string is defined, then all requested queries will be filtered based on experiments this user has access to.</span>
<span class="sd">			This is how the proxy (see immunogrep_query_dbproxy_api) handles requests from different users.</span>
<span class="sd">			.. important::</span>

<span class="sd">				If it is equal to None then it will assume that the user is an administrator</span>
<span class="sd">			If it is equal to an empty string then it will assume that the user is a public user (basically has the minimium access to the database)</span>
<span class="sd">		modify_query_values_to_follow_db_schema : boolean. Optional. default = True</span>
<span class="sd">			When set to true, this will ensure that any queries on fields we define in our default schema are in the proper format. For example, if a user</span>
<span class="sd">			queries for &#39;VREGION.VGENE_SCORES&#39;: {$gt:&#39;3&#39;} where &#39;3&#39; is a string, when set to true, it will modify the query to ensure that it is a number =&gt; &#39;VREGION.VGENE_SCORES&#39;: {$gt:3}</span>
<span class="sd">		redirect_fields_for_improved_queries : boolean. Optional. default = True</span>
<span class="sd">			When set to true, this will modify some queries to use fields optimized to return better results. For example, if a user wants to query for experiments whose name is</span>
<span class="sd">			&#39;Experiment 1 test&#39;, then they would write &#39;EXPERIMENT_NAME&#39;:&#39;Experment 1 test&#39;. However, if it actually exists in the database as Experiment_1_test or Experiment 1 Test, then their</span>
<span class="sd">			query will not work. When creating experiments, we add extra fields for common fields that may have idiosyncracies in spacing and case sensitivity; these duplicated fields are stored in a new field called &#39;DUPLICATED_FIELDS&#39;</span>
<span class="sd">			Therefore, when set to true, the query above will become &#39;DUPLICATED_FIELDS.EXPERIMENT_NAME&#39;:&#39;Experiment 1 test&#39;. In this situation, the query would work.</span>

<span class="sd">		Attributes</span>
<span class="sd">		----------</span>
<span class="sd">		query_results : int, list, dict, db cursor, generator</span>
<span class="sd">			This attribute stores the result from the latest query run. Iterating through the class, saving results to file, or running get_results,</span>
<span class="sd">			will return values stored in this attribute.</span>
<span class="sd">			The format of query_results will vary depending on the type of query run by the user.</span>
<span class="sd">		db_path : mongodb path to collections</span>
<span class="sd">			Stores the current mongodb connection to the database. Access to the exps, seqs, and users collections can be provided from this attribute</span>
<span class="sd">			i.e. db_path.seqs, db_path.exps, etc..</span>
<span class="sd">		user : dict defining current user querying database</span>
<span class="sd">			Using the value from dbuser, this is a dict containing all information about that db_user. keys for this attribute are: &#39;user&#39;, &#39;administrator&#39;, &#39;write_access&#39;, &#39;curator&#39;, &#39;email&#39;</span>
<span class="sd">		allowed_experiment_ids : list of strings</span>
<span class="sd">			A list containing the _id of all experiments the user has access to</span>
<span class="sd">		exp_metadata : dict</span>
<span class="sd">			A dictionary storing all experiment metadata the user has read access to. Key of dictionary = the _id field of each experiment in the exps collection</span>
<span class="sd">		delim_file_headers : list of strings</span>
<span class="sd">			This will store all fields from the most current query that can be reported as columns to a delimited file. We use this attribute when saving results to</span>
<span class="sd">			a delimited file</span>
<span class="sd">		default_filename : string</span>
<span class="sd">			A string representing a default filename to use for saving query results to a file when not defined by user</span>
<span class="sd">		to_file : boolean</span>
<span class="sd">			A boolean keeping track of whether a query was saved to a file or not (currently not used)</span>
<span class="sd">		files_created : Write_Files object</span>
<span class="sd">			This creates a default_dict for keeping track of all files currently created when saving results from queries</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		Query for experiments whose experiment name is Demo 1, return the project name for each experiment</span>

<span class="sd">		&gt;&gt;&gt; myquery = RunQuery((&#39;biotseq.icmb.utexas.edu&#39;,&#39;someadminuser&#39;,&#39;somepassword&#39;),&#39;cchrysostomou&#39;)</span>
<span class="sd">		&gt;&gt;&gt; exp_results = [exp for exp in myquery.query_exps_collection(exps_query={&#39;EXPERIMENT_NAME&#39;:&#39;Demo 1&#39;},project_fields={&#39;PROJECT_NAME&#39;:1})]</span>

<span class="sd">		Query for sequences from experiments whose experiment name is Demo 1, annotated by IMGT, and whose VGENE is IGHV3-2; Convert the results into FASTQ format, and save the results to a file</span>
<span class="sd">		&gt;&gt;&gt; myquery.query_seqs_collection(exps_query={&#39;EXPERIMENT_NAME&#39;:&#39;Demo 1&#39;},analysis_name = [&#39;IMGT&#39;], seqs_query={&#39;DATA.VREGION.VGENES&#39;:&#39;IGHV3-2&#39;}).save_as_fastq(prefix_file_path=&#39;tesetquery&#39;)</span>

<span class="sd">		Get the amino acid CDR3 length distribution for the experiment, Demo 1, of sequences annotated by IMGT and containing the VGENE IGHV3-2</span>
<span class="sd">		&gt;&gt;&gt; myquery.cdr3_length_distribution(feature=&#39;AA&#39;, analysis_name=&#39;IMGT&#39;, metadata_query = {&#39;EXPERIMENT_NAME&#39;:&#39;Demo 1&#39;}, filter_by_query={&#39;DATA.VREGION.VGENES&#39;:&#39;IGHV3-2&#39;}).save_as_json(prefix_file_path=&#39;cdr3dist&#39;)</span>

<span class="sd">		See also</span>
<span class="sd">		--------</span>
<span class="sd">		immunogrep_query_dbproxy_api</span>

<span class="sd">	&#39;&#39;&#39;</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_connect_data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dbuser</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">file_prefix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="c"># Store values user passed into as attributes</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">modify_query_values_to_follow_db_schema</span> <span class="o">=</span> <span class="n">modify_query_values_to_follow_db_schema</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">redirect_fields_for_improved_queries</span> <span class="o">=</span> <span class="n">redirect_fields_for_improved_queries</span>

		<span class="c"># All query results will be stored in this db cursor</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="c"># This variable will be used to figure out what fields are present in delimited files (CSV/TAB).  See the function(s) Get_Schema_* above. They will fill in this variable</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">process_cursor_fnc</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">debug_file</span> <span class="o">=</span> <span class="s">&#39;query_debug_log.txt&#39;</span>
		<span class="c"># A dictionary of metadata that the user has access to</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="c"># A list of experiment ids, the user has access to</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c"># Connect to database using path, username, password</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">db_path</span> <span class="o">=</span> <span class="n">connectToIgDatabase</span><span class="p">(</span><span class="n">db_connect_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">db_connect_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">db_connect_data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">default_filename</span> <span class="o">=</span> <span class="s">&#39;IGREP_Query_&#39;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&#39;[\:_\- ]&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span> <span class="o">=</span> <span class="n">Write_Files</span><span class="p">()</span>  <span class="c"># This is basically a default dict for writing results to files (see the class definition below)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">to_file</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="c"># Get user permissions</span>
		<span class="k">if</span> <span class="n">dbuser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="c"># if it was not explicitly said, then assume its an administrator</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;user&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;administrator&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
			<span class="n">dbuser</span> <span class="o">=</span> <span class="s">&#39;admin&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&#39;user&#39;</span><span class="p">:</span> <span class="n">dbuser</span><span class="p">})</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">no_user_found</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">no_user_found</span> <span class="o">=</span> <span class="bp">False</span>

		<span class="c"># Create a log file</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dbuser</span><span class="p">):</span>
			<span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dbuser</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dbuser</span><span class="p">,</span> <span class="s">&#39;logfile.txt&#39;</span><span class="p">),</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{1}: User {0} has accessed database</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dbuser</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())))</span>

		<span class="c"># Get all metadata user has access to</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_exp_docs_with_read_access</span><span class="p">()</span>
		<span class="c"># Get a list of experiments user has access to</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ObjectId</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>

	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Creates an iterator for the class. When run, it will iterate throug the query results</span>
<span class="sd">			attribute, self.query_results</span>

<span class="sd">			yields</span>
<span class="sd">			------</span>
<span class="sd">			See function iterresults() below</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterresults</span><span class="p">()</span>

<div class="viewcode-block" id="RunQuery.get_results"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.get_results">[docs]</a>	<span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flatten_documents</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Method for return results from a query. This will return results, from the query results</span>
<span class="sd">			attribute self.query_results, to memory and not to a file.</span>
<span class="sd">			Results can be returned in chunks, or once at a time</span>

<span class="sd">			.. important::</span>
<span class="sd">				If you would like to save results to a file please see the &#39;save_as_*&#39; functions below</span>

<span class="sd">			.. note::</span>
<span class="sd">				The DATA key will always be removed from the query results (DATA.VREGION becomes just VREGION)</span>

<span class="sd">			.. note::</span>
<span class="sd">				The database cursor from a query will be exhausted when running this function because we do not use iter tools tee</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			chunk_size : int, default=None</span>
<span class="sd">				This defines how to return results back</span>
<span class="sd">				When chunk_size is None, then results are returned based on their format in self.query_results</span>
<span class="sd">					i.e. If a dict, returns a dict; if a cursor returns a cursor, if a list returns list</span>
<span class="sd">				When chunk_size is an integer, then results are loaded into chunks inside a list.</span>
<span class="sd">					When chunk_size is 1, each iterator of generator will return [result1]</span>
<span class="sd">					When chunk_size is 5, each iterator of generator will return [result1,result2,result3,result4,result5]</span>
<span class="sd">					When chunk_size is 0, then all results will be returned one-by-one but NOT inside of a list</span>
<span class="sd">					.. warning::</span>
<span class="sd">						a chunk_size of 0 will NOT yield results in a list</span>
<span class="sd">			flatten_documents : boolean, default=False</span>
<span class="sd">				When True, all documents from a query will be flattened so that they are not nested:</span>
<span class="sd">				i.e. &#39;VREGION&#39;:{CDR1:{AA:&#39;ACT&#39;}} becomes &#39;VREGION.CDR1.AA&#39;: &#39;ACT&#39;</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			int, long, float, complex</span>
<span class="sd">				Returns a single number when self.query_results is a number (i.e. when using count function) and chunk_size is None</span>
<span class="sd">			dict</span>
<span class="sd">				Returns a dictionary (flattened if flatten_documents is true) when self.query_results is a dict and chunk_size is None</span>
<span class="sd">			generator</span>
<span class="sd">				1) Returns a generator when self.query_results is a db cursor or a generator and chunk_size is none</span>
<span class="sd">				2) Returns a generator for iterating through self.query_results when chunk_size is 0 </span>
<span class="sd">				3) Returns a generator for any format of self.query_results when chunk_size &gt; 0.</span>

<span class="sd">					.. note:: List of results</span>
<span class="sd">					In this case (chunk_size &gt; 0), all results from this generator will be yielded inside a list</span>

<span class="sd">			Examples</span>
<span class="sd">			--------</span>
<span class="sd">			&gt;&gt;&gt; import immunogrep_db_query_api as query</span>
<span class="sd">			&gt;&gt;&gt; myquery = query.RunQuery((user,password,&#39;biotseq.icmb.utexas.edu&#39;))</span>
<span class="sd">			&gt;&gt;&gt; for results in myquery.get_user_access_info().get_results():</span>
<span class="sd">			... 	print(results)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">chunk_size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="c"># Return results precisely as we see them</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">flatten_documents</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_results</span><span class="p">(</span><span class="n">flatten_documents</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">chunk_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">iterresults</span><span class="p">(</span><span class="n">flatten_documents</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_chunks</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">flatten_documents</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.iterresults"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.iterresults">[docs]</a>	<span class="k">def</span> <span class="nf">iterresults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flatten_documents</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Iterator function for parsing results from the query results attribute: self.query_results</span>
<span class="sd">			This function returns a generator that can be iterated in a for loop</span>

<span class="sd">			.. note::</span>
<span class="sd">				The DATA key will always be removed from the query results (DATA.VREGION becomes just VREGION)</span>

<span class="sd">			.. note::</span>
<span class="sd">				The database cursor from a query will be exhausted when running this function because we do not use iter tools tee</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			flatten_documents : boolean, default=False</span>
<span class="sd">				When True, all documents from a query will be flattened so that they are not nested:</span>
<span class="sd">				i.e. &#39;VREGION&#39;:{CDR1:{AA:&#39;ACT&#39;}} becomes &#39;VREGION.CDR1.AA&#39;: &#39;ACT&#39;</span>

<span class="sd">			Yields</span>
<span class="sd">			------</span>
<span class="sd">			dict</span>
<span class="sd">				1) If self.query_results is equal to a dict (i.e. from a find_one command)</span>
<span class="sd">				2) self.query_results is equal to a db cursor or generator (i.e. from query_seqs_collection or query_exps_collection)</span>
<span class="sd">			int, float, complex, long</span>
<span class="sd">				If self.query_results is equal to a number (i.e. from a count command)</span>
<span class="sd">			list</span>
<span class="sd">				If self.query_results is equal to a list (i.e. output from allowed_experiment_ids)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">flatten_documents</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
				<span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
				<span class="k">yield</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
				<span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
				<span class="k">yield</span> <span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">Simple_Process_Output</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.get_created_files"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.get_created_files">[docs]</a>	<span class="k">def</span> <span class="nf">get_created_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Returns the filenames of all queries saved to a file</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			list of dict</span>
<span class="sd">				Each element in the list represents a file that was created</span>
<span class="sd">				[{&#39;filename&#39;: path_of_files_created, &#39;doc_count&#39;: documents per file}]</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">get_files</span><span class="p">()</span>
</div>
	<span class="k">def</span> <span class="nf">_yield_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">flatten_documents</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">flatten_documents</span><span class="p">:</span>
				<span class="k">yield</span> <span class="p">[</span><span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">))]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">yield</span> <span class="p">[</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">current_chunk</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">return_chunks</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
				<span class="n">doc</span> <span class="o">=</span> <span class="n">Simple_Process_Output</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">flatten_documents</span><span class="p">:</span>
					<span class="n">doc</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
				<span class="n">return_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
				<span class="n">current_chunk</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">if</span> <span class="n">current_chunk</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">return_chunks</span>
					<span class="n">return_chunks</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="n">current_chunk</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="n">return_chunks</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">return_chunks</span>

	<span class="k">def</span> <span class="nf">_yield_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flatten_documents</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">flatten_documents</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">Simple_Process_Output</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

	<span class="c"># #############QUERY CURSOR FUNCTIONS##########################</span>

	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		The following methods add in some mongo cursor functions to a set of query commands</span>
<span class="sd">		i.e. You can do query_seqs_collection().count() or .limit()</span>
<span class="sd">	&#39;&#39;&#39;</span>

<div class="viewcode-block" id="RunQuery.count"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.count">[docs]</a>	<span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_limit_and_skip</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Count the number of results in a query</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			with_limit_and_skip : boolean, default = False</span>
<span class="sd">				When performing the count, consider limit and skip settings.</span>
<span class="sd">				For example, if a limit of 100 was set on the query, and you perform a count where with_limit_and_skip is True,</span>
<span class="sd">				then this function will return 100; If False it would ignore any limit or skip settings set and count the entire query.</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">with_limit_and_skip</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The count function can only be used on a mongodb cursor! Error message: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.limit"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.limit">[docs]</a>	<span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Sets a limit for the number of documents to return.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			limit : integer</span>
<span class="sd">				.. note::</span>
<span class="sd">					A limit of 0 is the same as not setting a limit</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Limit function can only be used on a mongodb cursor! Error message: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.skip"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.skip">[docs]</a>	<span class="k">def</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_skip</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Skips the first set of documents in a query</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			num_skip : integer</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="n">num_skip</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Skip function can only be used on a mongodb cursor! Error message: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># set up a sort command for general queries</span></div>
<div class="viewcode-block" id="RunQuery.sort"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.sort">[docs]</a>	<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_tuples</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Sorts documents in a query by a set of tuples</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			sort_tuples : list of tuples</span>
<span class="sd">				A list of (key, direction) pairs specifying the sort order for this query.</span>
<span class="sd">				Direction is 1 for ascending or -1 for descending (or pymongo.ascending/descending)</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sort_tuples</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Sort function can only be used on a mongodb cursor! Error message: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># For debugging mongo queries debugging</span></div>
<div class="viewcode-block" id="RunQuery.explain"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.explain">[docs]</a>	<span class="k">def</span> <span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Gets a dict explaining the query performance</span>

<span class="sd">			.. note::</span>
<span class="sd">			Refer to mongodb explain function</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="o">.</span><span class="n">explain</span><span class="p">()</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Explain function can only be used on a mongodb cursor! Error message: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.distinct"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.distinct">[docs]</a>	<span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Adds a distinct function to the query. This will collapse the results into a list of distinct values based on a field_name</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			field_name : a string defining what field we want to find distinct values for</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Distinct function can only be used on a mongodb cursor! Error message: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># QUERIES ON USERS COLLECTION# ########################################################################</span></div>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		The following methods run queries on the users collection in the database</span>
<span class="sd">	&#39;&#39;&#39;</span>

<div class="viewcode-block" id="RunQuery.get_db_user_list_info"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.get_db_user_list_info">[docs]</a>	<span class="k">def</span> <span class="nf">get_db_user_list_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Queries users collection for a list of documents containing information of all users currently registered with the database</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of dictionaries to the query results attribute, self.query_results</span>
<span class="sd">				At a minimum, each dictionary will contain the following keys: _id, user, name, lab</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="o">.</span><span class="n">users</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">find</span><span class="p">()]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># If not administrator then just report username, full name, and lab</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">find</span><span class="p">({},</span> <span class="p">{</span><span class="s">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;user&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;lab&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;administrator&#39;</span><span class="p">,</span> <span class="s">&#39;curator&#39;</span><span class="p">,</span> <span class="s">&#39;write_access&#39;</span><span class="p">,</span> <span class="s">&#39;lab&#39;</span><span class="p">,</span> <span class="s">&#39;email&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.get_user_access_info"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.get_user_access_info">[docs]</a>	<span class="k">def</span> <span class="nf">get_user_access_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Queries users collection for a dictionary containing information about the current user</span>
<span class="sd">			i.e. returns the following in key-value of user: {username:, name:, administrator:, curator:, write_access:, lab:, email:, }</span>

<span class="sd">			Datatype returned to self.query_results : dict</span>
<span class="sd">				This function returns a single dictionary to the query results attribute, self.query_results</span>
<span class="sd">				The dictionary will contain the following keys: username, name, administrator, curator, write_access, lab, email</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_user_found</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;administrator&#39;</span><span class="p">,</span> <span class="s">&#39;curator&#39;</span><span class="p">,</span> <span class="s">&#39;write_access&#39;</span><span class="p">,</span> <span class="s">&#39;lab&#39;</span><span class="p">,</span> <span class="s">&#39;email&#39;</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># QUERIES ON metadata/exps COLLECTION# ###############################################################</span></div>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		The following methods correspond to queries performed on the exps collection</span>
<span class="sd">	&#39;&#39;&#39;</span>

<div class="viewcode-block" id="RunQuery.get_accessible_exp_ids"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.get_accessible_exp_ids">[docs]</a>	<span class="k">def</span> <span class="nf">get_accessible_exp_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Queries for a list of all experiment ids where the current user has read access</span>

<span class="sd">			.. note::</span>
<span class="sd">				ObjectIds are converted into strings</span>

<span class="sd">			Datatype returned to self.query_results : list of strings</span>
<span class="sd">				This function returns a list of object ids converted to strings to the query results attribute, self.query_results</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;EXPERIMENT_IDS&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.query_exp_ids_owned_by_current_user"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_exp_ids_owned_by_current_user">[docs]</a>	<span class="k">def</span> <span class="nf">query_exp_ids_owned_by_current_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Return a list of all experiment ids where the user is explicity defined as an &#39;owner of the experiment&#39;</span>

<span class="sd">			.. note::</span>
<span class="sd">				ObjectIds are converted into strings</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">exp_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">)</span>
		<span class="n">write_access_exps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">exp_data</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">exp_data</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="s">&#39;OWNERS_OF_EXPERIMENT&#39;</span><span class="p">]]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">write_access_exps</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;EXPERIMENT_IDS&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.get_write_accessible_exp_ids"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.get_write_accessible_exp_ids">[docs]</a>	<span class="k">def</span> <span class="nf">get_write_accessible_exp_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Return a list of all experiment ids the user has write access to</span>

<span class="sd">			.. note::</span>
<span class="sd">				ObjectIds are converted into strings</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]:</span>
			<span class="c"># Return all allowed experiments</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># Only return experiments with write access</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_exp_ids_owned_by_current_user</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;EXPERIMENT_IDS&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.query_exp_docs"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_exp_docs">[docs]</a>	<span class="k">def</span> <span class="nf">query_exp_docs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_id_list</span><span class="o">=</span><span class="p">[],</span> <span class="n">write_access_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Queries for all metadata from exps collection that the user has read-access to</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			object_id_list : list of strings</span>
<span class="sd">				Filters results such that only experiments whose &#39;_id&#39; is listed in this list is considered</span>
<span class="sd">			write_access_only : boolean</span>
<span class="sd">				When true, filters results by only considering experiments where user is listed as one of the &#39;OWNERS_OF_EXPERIMENT&#39;</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of documents to the query results attribute, self.query_results</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">object_id_list</span><span class="p">:</span>
			<span class="n">object_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">object_id_list</span><span class="p">]))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">object_id_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="k">if</span> <span class="n">ObjectId</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="n">object_id_list</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">write_access_only</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="k">if</span> <span class="n">ObjectId</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="n">object_id_list</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s">&#39;OWNERS_OF_EXPERIMENT&#39;</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="k">if</span> <span class="n">ObjectId</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="n">object_id_list</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">each_doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">each_doc</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.query_exp_docs_with_ownership"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_exp_docs_with_ownership">[docs]</a>	<span class="k">def</span> <span class="nf">query_exp_docs_with_ownership</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_id_list</span><span class="o">=</span><span class="p">[]):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Queries for all metadata from exps collection that the user has write access to/is listed as one of the &#39;OWNERS_OF_EXPERIMENT&#39;</span>

<span class="sd">			.. note::</span>
<span class="sd">			This function is identical to the preceeding function query_exp_docs where write_access_only is True</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			object_id_list : list of strings</span>
<span class="sd">				Filters results such that only experiments whose &#39;_id&#39; is listed in this list is considered</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of documents to the query results attribute, self.query_results</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">object_id_list</span><span class="p">:</span>
			<span class="n">object_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">([</span><span class="n">convert_to_objectid</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">object_id_list</span><span class="p">]))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">object_id_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="k">if</span> <span class="n">ObjectId</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="n">object_id_list</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s">&#39;OWNERS_OF_EXPERIMENT&#39;</span><span class="p">]]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">each_doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">each_doc</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.query_exp_docs_containing_sequences"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_exp_docs_containing_sequences">[docs]</a>	<span class="k">def</span> <span class="nf">query_exp_docs_containing_sequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">write_access_only</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">analyses</span><span class="o">=</span><span class="p">[]):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Queries for all metadata from all experiments in exps collection that contain sequences in the seqs collection</span>
<span class="sd">			(Queries for experiments where SEQ_COUNT is &gt; 0)</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			write_access_only : boolean</span>
<span class="sd">				When true, filters results by only considering experiments where user is listed as one of the &#39;OWNERS_OF_EXPERIMENT&#39;</span>
<span class="sd">			analyses : list of strings</span>
<span class="sd">				When not empty, then this parameter will filter results by only returning documents that contain annotated information listed in the list</span>
<span class="sd">				i.e. when analyses = [&#39;IMGT&#39;,&#39;IBLAST&#39;], will only return experiments that contain annotation information from either IMGT or IGBLAST</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of documents to the query results attribute, self.query_results</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span>
		<span class="n">object_id_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="n">query</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;_id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">object_id_list</span><span class="p">},</span> <span class="s">&#39;SEQ_COUNT&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;$gt&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}</span>
		<span class="k">if</span> <span class="n">write_access_only</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
			<span class="n">query</span><span class="p">[</span><span class="s">&#39;OWNERS_OF_EXPERIMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">analyses</span> <span class="ow">and</span> <span class="n">analyses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
			<span class="n">analyses</span> <span class="o">=</span> <span class="p">[</span><span class="n">analyses</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">analyses</span><span class="p">:</span>
			<span class="n">query</span><span class="p">[</span><span class="s">&#39;ANALYSES_COUNT.{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">upper</span><span class="p">())]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$gt&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;DUPLICATED_FIELDS&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">each_doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">each_doc</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">list_to_gen</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.query_exps_collection"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_exps_collection">[docs]</a>	<span class="k">def</span> <span class="nf">query_exps_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exps_query</span><span class="o">=</span><span class="p">{},</span> <span class="n">project_fields</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;DUPLICATED_FIELDS&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="n">include_duplicated_fields</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Runs a general query on the exps collection using a standard mongo query .find() function</span>

<span class="sd">			Parameter</span>
<span class="sd">			----------</span>
<span class="sd">			exp_id : list of strings, defaut = None</span>
<span class="sd">				Filters results such that only experiments whose &#39;_id&#39; is listed in this list is considered</span>
<span class="sd">			exps_query : dict, default = {}</span>
<span class="sd">				A mongo query using mongo operators</span>
<span class="sd">			project_fields : dict, default = {&#39;DUPLICATED_FIELDS&#39;: 0}</span>
<span class="sd">				A mongo projection query. Fields to project are represented as keys, and values are 0 or 1 depending on whether to suppress or include field</span>
<span class="sd">			include_duplicated_fields : boolean, default = False</span>
<span class="sd">				If true, then will include the added in field DUPLICATED_FIELDS to the projection query</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of documents to the query results attribute, self.query_results</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">exp_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="c"># Default var which means undefined, so pass in allowed_experiment_ids</span>
			<span class="c"># Basically assume that user does not knwo what to search,so wants to search all avaialabe experiments</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_id</span><span class="p">]</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span>
		<span class="c"># Modify the query to improve success of a match</span>
		<span class="c"># 1) Redirect select fieldname to fields created by server to imporve queries</span>
		<span class="c"># 2) Ensure that the format of the values provided to the field matches the format of the field put in database</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">Parse_Mongo_Query_Expression</span><span class="p">(</span><span class="n">exps_query</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="o">=</span><span class="n">fields_for_queries_exps_collection</span><span class="p">,</span> <span class="n">redirection_fields</span><span class="o">=</span><span class="n">redirect_exp_collection_fields</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redirect_fields_for_improved_queries</span><span class="p">)</span>
		<span class="c"># We will always add a range query on &#39;_id&#39; for each query (this ensures that it only searches allowed experiments)</span>
		<span class="n">q</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetIdIntersection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">,</span> <span class="n">exp_id</span><span class="p">],</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;_id&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Query was modified to: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
		<span class="n">project</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">project_fields</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">project</span><span class="p">:</span>
			<span class="n">allTrue</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">project</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
			<span class="k">if</span> <span class="n">allTrue</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">project</span><span class="p">):</span>  <span class="c"># The user projected fields using &#39;1&#39;. they listed select fields to project</span>
				<span class="n">project</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Also always project &#39;_id&#39; field</span>
				<span class="k">if</span> <span class="n">include_duplicated_fields</span><span class="p">:</span>
					<span class="n">project</span><span class="p">[</span><span class="s">&#39;DUPLICATED_FIELDS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">elif</span> <span class="n">allTrue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># The user suppressed feilds using &#39;0&#39;</span>
				<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">include_duplicated_fields</span><span class="p">):</span>
					<span class="n">project</span><span class="p">[</span><span class="s">&#39;DUPLICATED_FIELDS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># Just incase user explicityl said to include_duplicated_fields</span>
					<span class="n">project</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;DUPLICATED_FIELDS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">project</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following values will be projected: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">project</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;ERROR: query_command must be a dictionary for query experiment collection&quot;</span><span class="p">)</span>

		<span class="n">query</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">project</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="RunQuery.query_distinct_exp_collection_values"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_distinct_exp_collection_values">[docs]</a>	<span class="k">def</span> <span class="nf">query_distinct_exp_collection_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique_fields</span><span class="o">=</span><span class="p">[]):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Returns distinct values for select fields from CURATED experiments in the exps collection</span>

<span class="sd">			.. note::Filtered results</span>
<span class="sd">			If the current user is not an administrator, then it only returns distinct values from fields found within experiments user has read access to.</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of documents to the query results attribute, self.query_results</span>


<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			unique_fields : dict</span>
<span class="sd">				The keys of the dict corresponds to fields defined by unique_fields, and the values of each key is a list of unique values for that field in curated experiments</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span>
		<span class="n">allow_unique_metadata</span> <span class="o">=</span> <span class="p">[</span>
			<span class="s">&#39;PAIRING_TECHNIQUE&#39;</span><span class="p">,</span> <span class="s">&#39;CELL_MARKERS_USED&#39;</span><span class="p">,</span> <span class="s">&#39;LIST_OF_POLYMERASES_USED&#39;</span><span class="p">,</span> <span class="s">&#39;POST_SEQUENCING_PROCESSING: PHI_X_FILTER&#39;</span><span class="p">,</span>
			<span class="s">&#39;POST_SEQUENCING_PROCESSING: QUALITY_FILTER&#39;</span><span class="p">,</span> <span class="s">&#39;POST_SEQUENCING_PROCESSING: PROCESS_R1_R2_FILE&#39;</span><span class="p">,</span>
			<span class="s">&#39;SPECIES&#39;</span><span class="p">,</span> <span class="s">&#39;SEQUENCING_PLATFORM&#39;</span><span class="p">,</span> <span class="s">&#39;CHAIN_TYPES_SEQUENCED&#39;</span><span class="p">,</span> <span class="s">&#39;CELL_TYPES_SEQUENCED&#39;</span><span class="p">,</span> <span class="s">&#39;ISOTYPES_SEQUENCED&#39;</span><span class="p">,</span>
			<span class="s">&#39;TEMPLATE_TYPE&#39;</span><span class="p">,</span> <span class="s">&#39;REVERSE_PRIMER_USED_IN_RT_STEP&#39;</span>
		<span class="p">]</span>

		<span class="c"># Get a list of curated experiments</span>
		<span class="n">all_experiments_metadata</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;CURATED&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
		<span class="c"># Determine which curated experiments current user has access to</span>
		<span class="n">allowed_experiments_metadata</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;_id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">},</span> <span class="s">&#39;CURATED&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
		<span class="k">if</span> <span class="n">unique_fields</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">unique_fields</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
				<span class="n">unique_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_fields</span><span class="p">]</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]:</span>
				<span class="n">allow_unique_metadata</span> <span class="o">=</span> <span class="n">unique_fields</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="n">all_experiments_metadata</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">allow_unique_metadata</span> <span class="k">else</span> <span class="n">allowed_experiments_metadata</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">unique_fields</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="n">unique_fields</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># PRIVATE FUNCTION...should not be used by user</span></div>
	<span class="k">def</span> <span class="nf">_query_exp_docs_with_read_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Get all experiments user has read access to</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]:</span>
			<span class="n">exp_docs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({})}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">read_access_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;all&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;lab_&#39;</span> <span class="o">+</span> <span class="n">lab</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;lab&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">lab</span><span class="p">]</span>
			<span class="n">exp_docs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;READ_ACCESS&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">read_access_names</span><span class="p">}})}</span>
		<span class="k">return</span> <span class="n">exp_docs</span>

	<span class="c"># PRIVATE FUNCTION...should not be used by user</span>
	<span class="k">def</span> <span class="nf">_query_exp_docs_with_write_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Get all experiments user has write access to</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;administrator&#39;</span><span class="p">]:</span>
			<span class="n">exp_docs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({})}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">write_access_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
			<span class="n">exp_docs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;OWNERS_OF_EXPERIMENT&#39;</span><span class="p">:</span> <span class="n">write_access_name</span><span class="p">})}</span>
		<span class="k">return</span> <span class="n">exp_docs</span>

	<span class="c"># QUERIES ON seqs COLLECTION# ###############################################################</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		The following methods correspond to queries performed on the seqs collection. It will query for NGS and annotated data.</span>
<span class="sd">	&#39;&#39;&#39;</span>

<div class="viewcode-block" id="RunQuery.query_seqs_collection"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.query_seqs_collection">[docs]</a>	<span class="k">def</span> <span class="nf">query_seqs_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">analysis_name</span><span class="o">=</span><span class="p">[],</span> <span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span> <span class="n">seqs_query</span><span class="o">=</span><span class="p">{},</span> <span class="n">project_fields</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;QUERY_DATA&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="n">exps_query</span><span class="o">=</span><span class="p">{},</span> <span class="n">include_original_ngs_seq</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Runs a general query on the seqs collection using a standard mongo query .find() function</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			exp_id : list of strings, defaut = None</span>
<span class="sd">				Filters results such that only seqs results whose &#39;EXP_ID&#39; is listed in this list is considered</span>
<span class="sd">			analysis_name : list of strings, default = []</span>
<span class="sd">				When not empty, filters results to only include documents whose ANALYSIS_NAME is within this list</span>
<span class="sd">			recombination_type : list of strings, default = []</span>
<span class="sd">				When not empty, filters results to only include documents whose RECOMBINATION_TYPE is within this list</span>
<span class="sd">			seqs_query : dict, default = {}</span>
<span class="sd">				A mongo query on the seqs collection using mongo operators</span>
<span class="sd">			project_fields : dict, default = {&#39;QUERY_DATA&#39;: 0}</span>
<span class="sd">				A mongo projection query. Fields to project are represented as keys, and values are 0 or 1 depending on whether to suppress or include field</span>
<span class="sd">			exps_query : dict, default = {}</span>
<span class="sd">				A mongo query on the exps collection using mongo operators</span>
<span class="sd">			include_original_ngs_seq : boolean,</span>
<span class="sd">				When true, will also include the RAW NGS read and sequence header document for each queried document</span>
<span class="sd">			limit : integer</span>
<span class="sd">				Sets a limit on the number of documents to return. A limit of 0 is the same as not setting a limit.</span>

<span class="sd">			Datatype returned to self.query_results : list of dicts</span>
<span class="sd">				This function returns a list of documents to the query results attribute, self.query_results</span>

<span class="sd">			Returns</span>
<span class="sd">			-------</span>
<span class="sd">			self</span>

<span class="sd">			Examples</span>
<span class="sd">			--------</span>
<span class="sd">			Return the CDR3 field from of 100 IMGT documents from experiments in project Demo that contain the VGENE IGHV1-3</span>

<span class="sd">			&gt;&gt;&gt; query_seqs_collection(analysis_name[&#39;IMGT&#39;], seqs_query={&#39;DATA.VREGION.VGENES&#39;:&#39;IGHV1-3&#39;}, exps_query={&#39;PROJECT_NAME&#39;:&#39;Demo&#39;}, project_fields={&#39;DATA.CDR3&#39;:1}, limit=100)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following query in function &quot;Query_Seqs_Collection&quot; was desired: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span> <span class="n">exp_id</span><span class="p">,</span> <span class="s">&#39;seqs_query&#39;</span><span class="p">:</span> <span class="n">seqs_query</span><span class="p">,</span> <span class="s">&#39;exps_query&#39;</span><span class="p">:</span> <span class="n">exps_query</span><span class="p">})))</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span>
		<span class="n">q</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seqs_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()}</span>  <span class="c"># make a copy of query</span>
		<span class="n">fields_to_project</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">project_fields</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">fields_to_project</span><span class="p">:</span>
			<span class="n">allTrue</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">counts_in</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fields_to_project</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
					<span class="k">pass</span>
				<span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">counts_in</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">counts_in</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="n">allTrue</span> <span class="o">+=</span> <span class="mi">1</span>

			<span class="k">if</span> <span class="n">allTrue</span> <span class="o">==</span> <span class="n">counts_in</span><span class="p">:</span>
				<span class="c"># The user projected fields using &#39;1&#39;. they listed select fields to project</span>
				<span class="n">allTrue</span> <span class="o">=</span> <span class="bp">True</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Also always project &#39;_id&#39; field</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Also always project &#39;SEQ_ID&#39; field</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Also always project &#39;EXP_ID&#39; field</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Also always project &#39;EXP_ID&#39; field</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Also always project &#39;EXP_ID&#39; field</span>
			<span class="k">elif</span> <span class="n">allTrue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="c"># The user suppressed feilds using &#39;0&#39;</span>
				<span class="n">allTrue</span> <span class="o">=</span> <span class="bp">False</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;QUERY_DATA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">allTrue</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="n">fields_to_project</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="k">if</span> <span class="n">exp_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="c"># If exp_id is passed in as empty, then make it self.allowed_experiment_ids</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_id</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">exps_query</span><span class="p">:</span>
			<span class="c"># Query exp_collection</span>
			<span class="c"># Result of query will be stored in class name &#39;self.query_results&#39;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_exps_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">exps_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()})</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="k">if</span> <span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">}</span>
				<span class="c"># Erase metadata query</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">meta</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{}</span>
				<span class="c"># No experiments to searchby. no experiments were found !</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">analysis_name</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_name</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">analysis_name</span><span class="p">}</span>
		<span class="k">if</span> <span class="n">recombination_type</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recombination_type</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">recombination_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recombination_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">recombination_type</span><span class="p">}</span>

		<span class="c"># Modify the query to improve success of a match</span>
		<span class="c"># 1) redirect select fieldname to fields created by server to imporve queries</span>
		<span class="c"># 2) ensure that the format of the values provided to the field matches the format of the field put in database</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">Parse_Mongo_Query_Expression</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dict_defining_value_transformation</span><span class="o">=</span><span class="n">fields_for_queries_seqs_collection</span><span class="p">,</span> <span class="n">redirection_fields</span><span class="o">=</span><span class="n">redirect_seq_collection_fields</span><span class="p">,</span> <span class="n">modify_query_values_to_follow_db_schema</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span> <span class="n">redirect_fields_for_improved_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redirect_fields_for_improved_queries</span><span class="p">)</span>

		<span class="c"># We will always add a range query on &#39;_id&#39; for each query (this ensures that it only searches allowed experiments)</span>
		<span class="c"># There are exp_ids passed in by users OR found by the metadata_query above</span>
		<span class="c"># Therefore, find the intersection between results and allowed id&#39;s</span>
		<span class="c"># THIS WILL ALSO CONSIDER ANY TOP_LEVEL EXP_ID requests in the query field</span>
		<span class="n">q</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetIdIntersection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">,</span> <span class="n">exp_id</span><span class="p">],</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">expIdentifier</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

		<span class="c"># Based on the actual experiment IDs used in query, figure out which fields will be projected by using analysis schema in metadata</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c"># The query is dictionary using &#39;$in&#39; command</span>
			<span class="n">possible_ids</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">][</span><span class="s">&#39;$in&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">possible_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]]</span>
		<span class="n">possible_metadata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">possible_ids</span><span class="p">]</span>
		<span class="p">[</span><span class="n">schema_fields</span><span class="p">,</span> <span class="n">possible_analyses</span><span class="p">,</span> <span class="n">possible_recombination_types</span><span class="p">]</span> <span class="o">=</span> <span class="n">Get_Schema_Details</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span> <span class="n">fields_to_project</span><span class="p">,</span> <span class="n">allTrue</span><span class="p">)</span>

		<span class="k">if</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">possible_analyses</span> <span class="o">!=</span> <span class="p">[]:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_analyses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">possible_analyses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">possible_analyses</span><span class="p">}</span>
		<span class="k">if</span> <span class="s">&#39;RECOMBINATION_TYPE&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">possible_recombination_types</span> <span class="o">!=</span> <span class="p">[]:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_recombination_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">possible_recombination_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">q</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">possible_recombination_types</span><span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Query was modified to: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following values will be projected: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fields_to_project</span><span class="p">)))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="n">schema_fields</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fields_to_project</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">include_original_ngs_seq</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data_fields_for_raw_data</span><span class="p">)</span>
			<span class="c"># For every result in the query, also get the raw sequence data associated with result</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">get_rawseq_info</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span>


	<span class="c">#GENERAL AGGREGATION PIPELINE FUNCTION#</span>
	<span class="c">#QUERY seq collections using standard pymongo find function</span>
	<span class="c">#exp_id = &gt; filter results by experiemnts with ObjectId listed in exp_id	</span>
	<span class="c">#aggregation_fxn =&gt; a list of mongo aggregation commands to run pipeline </span>
		<span class="c">#IMPORTANT=&gt; FIRST ELEMENT IN AGGREGATION FUNCTION MUST BE &#39;$MATCH&#39;. IF THE USER DOES NTO PASS IT IN, THEN THIS FUNCTION WILL ADD A $MATCH FILTER USE EXP_ID</span>
	
	<span class="c">#initial_limit =&gt; this value tells the program to insert a &#39;$limit&#39; command right after the first filter/$match command in the aggregation function</span>
	
	<span class="c">#analysis_name =&gt; a list of analysis types to filter by. note -&gt; more complex queries using analysis_name can be defined in the query field </span>
	<span class="c">#recombination_type =&gt; a list of recombination_types to filter by. note -&gt; more complex queries using recombination_type can be defined in the query field </span>
	<span class="c">#metadata_query =&gt; in addition to explicity passing in a list of ObjectId&#39;s, a user can further filter experiemnts by querying teh exps collection/metadata</span>
		<span class="c">#for example, if metadata_query = {&#39;PROJECT_NAME&#39;:&#39;Demo&#39;}, then first the this metadata will be queried to return exp_ids whose PROJECT_NAME contain &#39;Demo&#39; 	</span>
	</div>
	<span class="k">def</span> <span class="nf">aggregate_seqs_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">analysis_name</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">recombination_type</span> <span class="o">=</span> <span class="p">[],</span><span class="n">aggregation_fxn</span> <span class="o">=</span><span class="p">[],</span><span class="n">initial_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="p">{},</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>	
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following aggregation function in &quot;Aggregate_Seqs_Collection&quot; was desired: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;aggregation&#39;</span><span class="p">:</span><span class="n">aggregation_fxn</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>		
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
		
		<span class="n">aggregate</span> <span class="o">=</span> <span class="p">[</span><span class="n">pipe</span> <span class="k">for</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="n">aggregation_fxn</span><span class="p">]</span> <span class="c">#make a copy of aggregation</span>
		
		<span class="k">if</span> <span class="n">exp_id</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#if exp_id is passed in as empty, then make it self.allowed_experiment_ids</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_id</span><span class="p">]</span>
		
		<span class="c">#FIRST CHECK WHETHER THE FIRST ELEMENT OF AGGREGATION FUNCTION IS A MATCH COMMAND, IF NOT, ADD IN A MATCH COMMAND </span>
		<span class="k">if</span> <span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">!=</span><span class="p">[</span><span class="s">&#39;$match&#39;</span><span class="p">]:</span>			
			<span class="n">aggregate</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,{</span><span class="s">&#39;$match&#39;</span><span class="p">:{}})</span> <span class="c">#prepend and empty filter command to top of list, we will add exp_ids to this later</span>
									
		<span class="k">if</span> <span class="n">metadata_query</span><span class="p">:</span>		
			<span class="c">#query exp_collection</span>
			<span class="c">#result of query will be stored in class name &#39;self.query_results&#39;			</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_exps_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">metadata_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()})</span>				
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="k">if</span> <span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">}</span>
				<span class="c">#erase metadata query 							</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">meta</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{}</span>
				<span class="c">#no experiments to searchby. no experiments were found !</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[]</span>			
						
		<span class="k">if</span> <span class="n">analysis_name</span><span class="p">:</span>
			<span class="c">#add to first fitler in aggregation function</span>
			<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_name</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span><span class="n">analysis_name</span><span class="p">}</span> <span class="c">#if analysis_name is a dict or a string, then we do not modify query. if its a list, we add an &#39;$in&#39; command </span>
									
		<span class="k">if</span> <span class="n">recombination_type</span><span class="p">:</span>
			<span class="c">#add to first fitler in aggregation function</span>
			<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recombination_type</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_type</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span><span class="n">recombination_type</span><span class="p">}</span>
					
		
		<span class="c">#for aggregation functions, we only modify fields and field names in the first MATCH command. </span>
		<span class="c">#We trust the user to handle the remaining match commands. this is mainly assuming that the user will transform document sin aggregation</span>
		<span class="c">#So we will not know how to process the filter commands 		</span>
		<span class="c">#CONVERT query to proper format/objects using bson loads </span>
		<span class="c">#modify the query to improve success of a match </span>
		<span class="c">#redirect select fieldname to fields created by server to imporve queries</span>
		<span class="c">#ensure that the format of the values provided to the field matches the format of the field put in database			</span>
		<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parse_Mongo_Query_Expression</span><span class="p">(</span><span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">],</span> <span class="n">dict_defining_value_transformation</span><span class="o">=</span><span class="n">fields_for_queries_seqs_collection</span><span class="p">,</span><span class="n">redirection_fields</span> <span class="o">=</span> <span class="n">redirect_seq_collection_fields</span><span class="p">,</span><span class="n">modify_query_values_to_follow_db_schema</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modify_query_values_to_follow_db_schema</span><span class="p">,</span><span class="n">redirect_fields_for_improved_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redirect_fields_for_improved_queries</span><span class="p">)</span>
	
		<span class="c">#THIS LINE SHOULD ALWAYS COME AFTER Parse_Mongo_Query_Expression because sometimes object id will be {&#39;oid&#39;:&quot;&quot;} rather than ObjectId(). previousf ucntion fixes it</span>
		
		<span class="c">#we will always add a range query on &#39;_id&#39; for each query (this ensures that it only searches allowed experiments)</span>
		<span class="c">#there are exp_ids passed in by users OR found by the metadata_query above</span>
		<span class="c">#therefore, find the intersection between results and allowed id&#39;s		</span>
		<span class="c">#THIS WILL ALSO CONSIDER ANY TOP_LEVEL EXP_ID requests in the query field </span>
		<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="n">expIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetIdIntersection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">,</span><span class="n">exp_id</span><span class="p">],</span><span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">expIdentifier</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
		
		<span class="c">#based on the actual experiment IDs used in query, figure out which fields will be projected by using analysis schema in metadata</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="n">expIdentifier</span><span class="p">],</span><span class="nb">dict</span><span class="p">):</span> <span class="c">#the query is dictionary using &#39;$in&#39; command</span>
			<span class="n">possible_ids</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="n">expIdentifier</span><span class="p">][</span><span class="s">&#39;$in&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">possible_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="n">expIdentifier</span><span class="p">]]</span>
		<span class="n">possible_metadata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">possible_ids</span><span class="p">]</span>
		
		<span class="p">[</span><span class="n">schema_fields</span><span class="p">,</span><span class="n">possible_analyses</span><span class="p">,</span><span class="n">possible_recombination_types</span><span class="p">]</span> <span class="o">=</span> <span class="n">Get_Schema_Details_Aggregation_Pipeline</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">aggregate</span><span class="p">))</span>
		
			
		<span class="k">if</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possible_analyses</span><span class="o">!=</span><span class="p">[]:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_analyses</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">possible_analyses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">possible_analyses</span><span class="p">}</span>
		
		<span class="k">if</span> <span class="s">&#39;RECOMBINATION_TYPE&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possible_recombination_types</span><span class="o">!=</span><span class="p">[]:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_recombination_types</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">possible_recombination_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">aggregate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;$match&#39;</span><span class="p">][</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span> <span class="n">possible_recombination_types</span><span class="p">}</span>
		
		
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="n">schema_fields</span>
		
		
		<span class="k">if</span> <span class="n">initial_limit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="c">#insert directly after first match </span>
			<span class="n">aggregate</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">initial_limit</span><span class="p">})</span>
		
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;AggregationPipeline was modified to: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span> <span class="k">for</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="n">aggregate</span><span class="p">],</span><span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)))</span>
	
	
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">aggregate</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="n">allowDiskUse</span><span class="p">)</span>			
		
	
		<span class="k">return</span> <span class="bp">self</span>
	
	<span class="c">#SPECIALIZED QUERY FUNCTIONS#</span>
	<span class="c">#function name handles most of the queries, should not be a requirement for mongo-db knowledge#</span>
	<span class="c">#this function will return NGS reads for given experiments defined by exp_id</span>
	<span class="c">#By Default, this function will only query NGS reads for each experiment defined in exp_id query</span>
	<span class="c">#IF all annotated_data for a specific NGS read is desired, then include_all_data_by_seq_id = True</span>
    	<span class="c">#=&gt; IF TRUE, THEN THE FIELDS INCLUDE_ANALYSES AND INCLUDE_RECOMBINATION FIELDS ARE IGNORED</span>
	<span class="c">#IF a select subset of annotated data for a specific NGS read is desired, then include a list of string names for</span>
    	<span class="c">#a) include_analyses (analysis_types) and </span>
    	<span class="c">#b) include_recombination_type (recombniation types)</span>
	<span class="c">#IF RESULTS from this output include annotated data, then results from annotated data will be sorted by SEQ_ID</span>
	
	<span class="c">#PASS in a list of object ids corresponding to a experiments </span>
	<span class="c">#OUTPUTS sequences from each defined experiment and fields defined in &#39;project&#39; variable</span>
	<span class="c">#metadata_query =&gt; in addition to explicity passing in a list of ObjectId&#39;s, a user can further filter experiemnts by querying teh exps collection/metadata</span>
		<span class="c">#for example, if metadata_query = {&#39;PROJECT_NAME&#39;:&#39;Demo&#39;}, then first the this metadata will be queried to return exp_ids whose PROJECT_NAME contain &#39;Demo&#39; 	</span>
	<span class="k">def</span> <span class="nf">get_sequences_from_experiment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">project</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;DATE_UPDATED&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="n">idIdentifier</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="n">expIdentifier</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;DATA&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span> <span class="n">metadata_query</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">,</span><span class="n">include_all_data_by_seq_id</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_analyses</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">include_recombination_type</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">same_document</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>	
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following query in function &quot;Get_Sequences_From_Experiment&quot; was desired: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bson_dumps</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;additional_analyses&#39;</span><span class="p">:</span><span class="n">include_analyses</span><span class="p">,</span><span class="s">&#39;include_recombination&#39;</span><span class="p">:</span><span class="n">include_recombination_type</span><span class="p">,</span><span class="s">&#39;include_all_data&#39;</span><span class="p">:</span><span class="n">include_all_data_by_seq_id</span><span class="p">})))</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
		
		<span class="k">if</span> <span class="n">include_analyses</span><span class="o">!=</span><span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_analyses</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
			<span class="n">include_analyses</span> <span class="o">=</span> <span class="p">[</span><span class="n">include_analyses</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">include_recombination_type</span><span class="o">!=</span><span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_recombination_type</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
			<span class="n">include_recombination_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">include_recombination_type</span><span class="p">]</span>
		
		<span class="n">fields_to_project</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">project</span><span class="p">)</span>		
		
		<span class="k">if</span> <span class="n">fields_to_project</span><span class="p">:</span>
			<span class="n">numTrue</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">counts_in</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">fields_to_project</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
					<span class="k">pass</span>
				<span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">counts_in</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">counts_in</span><span class="o">+=</span><span class="mi">1</span>
					<span class="n">numTrue</span><span class="o">+=</span><span class="mi">1</span>		
			
			<span class="c">#allTrue = sum(fields_to_project.values())</span>
			<span class="k">if</span> <span class="n">numTrue</span><span class="o">==</span><span class="n">counts_in</span><span class="p">:</span> <span class="c">#the user projected fields using &#39;1&#39;. they listed select fields to project</span>
				<span class="n">allTrue</span><span class="o">=</span><span class="bp">True</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#also always project &#39;_id&#39; field </span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#also always project &#39;SEQ_ID&#39; field </span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#also always project &#39;EXP_ID&#39; field 				</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;DATA.SEQUENCE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#for this function, always project sequence</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;DATA.SEQUENCE_HEADER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#for this function, always project sequence</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;DATA.QUALITY_SCORE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#for this function, always project QUALITY_SCORE</span>
			<span class="k">elif</span> <span class="n">numTrue</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span><span class="c">#the user suppressed feilds using &#39;0&#39;</span>
				<span class="n">allTrue</span><span class="o">=</span><span class="bp">False</span>
				<span class="n">fields_to_project</span><span class="p">[</span><span class="s">&#39;QUERY_DATA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">allTrue</span><span class="o">=</span><span class="bp">True</span>
			<span class="n">fields_to_project</span> <span class="o">=</span> <span class="bp">None</span>
		
		
		
		<span class="k">if</span> <span class="n">exp_id</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#if exp_id is passed in as empty, then make it self.allowed_experiment_ids</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
			<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_id</span><span class="p">]</span>				
		
		<span class="k">if</span> <span class="n">metadata_query</span><span class="p">:</span>		
			<span class="c">#query exp_collection</span>
			<span class="c">#result of query will be stored in class name &#39;self.query_results&#39;			</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_exps_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">metadata_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()})</span>				
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="k">if</span> <span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">}</span>
				<span class="c">#erase metadata query 							</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">meta</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{}</span>
				<span class="c">#no experiments to searchby. no experiments were found !</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[]</span>			
				
		<span class="c">#we will always add a range query on &#39;_id&#39; for each query (this ensures that it only searches allowed experiments)</span>
		<span class="c">#there are exp_ids passed in by users OR found by the metadata_query above</span>
		<span class="c">#therefore, find the intersection between results and allowed id&#39;s</span>
		<span class="n">exp_query</span> <span class="o">=</span> <span class="n">GetIdIntersection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">,</span><span class="n">exp_id</span><span class="p">])</span>
				
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following experiments were filtered: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="n">expIdentifier</span><span class="p">:</span><span class="n">exp_query</span><span class="p">})))</span>
		
		<span class="c">#based on the actual experiment IDs used in query, figure out which fields will be projected by using analysis schema in metadata</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_query</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span> <span class="c">#the query is dictionary using &#39;$in&#39; command</span>
			<span class="n">possible_ids</span> <span class="o">=</span> <span class="n">exp_query</span><span class="p">[</span><span class="s">&#39;$in&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">possible_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_query</span><span class="p">]</span>
			
		
		<span class="c">#seqRawData analysis schema: </span>
		<span class="n">seq_analysis_schema</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;ANALYSIS_SCHEMA&#39;</span><span class="p">:{</span><span class="s">&#39;SEQUENCE.ANALYSES&#39;</span><span class="p">:</span><span class="s">&#39;RAW&#39;</span><span class="p">,</span><span class="s">&#39;SEQUENCE_HEADER.ANALYSES&#39;</span><span class="p">:</span><span class="s">&#39;RAW&#39;</span><span class="p">,</span><span class="s">&#39;QUALITY_SCORE.ANALYSES&#39;</span><span class="p">:</span><span class="s">&#39;RAW&#39;</span><span class="p">,</span><span class="s">&#39;FILENAME.ANALYSES&#39;</span><span class="p">:</span><span class="s">&#39;RAW&#39;</span><span class="p">}}</span>
								
		<span class="k">if</span> <span class="n">include_all_data_by_seq_id</span><span class="o">==</span><span class="bp">False</span> <span class="ow">and</span> <span class="n">include_analyses</span><span class="o">==</span><span class="bp">None</span> <span class="ow">and</span> <span class="n">include_recombination_type</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
			<span class="c">#we only want sequences, do not want annotation data </span>
			<span class="n">possible_metadata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">seq_analysis_schema</span><span class="p">]</span>
			<span class="p">[</span><span class="n">schema_fields</span><span class="p">,</span><span class="n">possible_analyses</span><span class="p">,</span><span class="n">possible_recombination_types</span><span class="p">]</span> <span class="o">=</span> <span class="n">Get_Schema_Details</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span><span class="n">fields_to_project</span><span class="p">,</span><span class="n">allTrue</span><span class="p">)</span>						
			
			<span class="c">#only query NGS reads where analysis_name = seqRawData variable</span>
			<span class="c">#NO NEED TO SORT BY SEQID</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">find</span><span class="p">({</span>
				<span class="n">expIdentifier</span><span class="p">:</span><span class="n">exp_query</span><span class="p">,</span>
				<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="n">seqRawData</span>
			<span class="p">},</span><span class="n">fields_to_project</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>			
			
		<span class="k">elif</span> <span class="n">include_all_data_by_seq_id</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
			<span class="c">#we want all data associated with experiment </span>
			<span class="n">possible_metadata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">possible_ids</span><span class="p">]</span>
			<span class="n">possible_metadata_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_analysis_schema</span><span class="p">)</span>
			<span class="p">[</span><span class="n">schema_fields</span><span class="p">,</span><span class="n">possible_analyses</span><span class="p">,</span><span class="n">possible_recombination_types</span><span class="p">]</span> <span class="o">=</span> <span class="n">Get_Schema_Details</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span><span class="n">fields_to_project</span><span class="p">,</span><span class="n">allTrue</span><span class="p">)</span>						
			<span class="n">total_docs_per_seq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_analyses</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>		
			<span class="c">#query ALL DATA from an experiment</span>
			<span class="c">#sort by SEQ_ID</span>
			<span class="c">#process output specially</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">find</span><span class="p">({</span>
				<span class="n">expIdentifier</span><span class="p">:</span><span class="n">exp_query</span>
			<span class="p">},</span><span class="n">fields_to_project</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idIdentifier</span><span class="p">)</span><span class="o">.</span><span class="n">hint</span><span class="p">(</span><span class="s">&#39;exp_seq_id_an_rt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="o">*</span><span class="n">total_docs_per_seq</span><span class="p">)</span>						
			<span class="c">#create a generator to parse the cursor and group together documents by SEQ_ID</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">group_documents_by_seq_id</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span><span class="n">same_document</span><span class="p">)</span>    
			
		<span class="k">elif</span> <span class="n">include_all_data_by_seq_id</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
			<span class="n">possible_metadata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">possible_ids</span><span class="p">]</span>
			<span class="n">possible_metadata_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_analysis_schema</span><span class="p">)</span>
			<span class="p">[</span><span class="n">schema_fields</span><span class="p">,</span><span class="n">possible_analyses</span><span class="p">,</span><span class="n">possible_recombination_types</span><span class="p">]</span> <span class="o">=</span> <span class="n">Get_Schema_Details</span><span class="p">(</span><span class="n">possible_metadata_fields</span><span class="p">,</span><span class="n">fields_to_project</span><span class="p">,</span><span class="n">allTrue</span><span class="p">)</span>						
			<span class="n">total_docs_per_seq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_analyses</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>					
			<span class="c">#QUERY ONLY SEQUENCE DATA OR SEQUENCES WITH </span>
			<span class="c">#SPECIFIED ANALYSIS TYPES AND RECOMBINATION TYPES                        </span>
			<span class="k">if</span> <span class="n">include_recombination_type</span> <span class="ow">and</span> <span class="n">possible_recombination_types</span><span class="o">!=</span><span class="n">include_recombination_type</span><span class="p">:</span> <span class="c">#ADD A RECOMBINATION_TYPE FILTER , but if there is only one recombination type (i.e. include_recombination_type = VDJ and only VDJ is found in possible_recombination_types, then filtering by recombination type is unnecessary)</span>
				<span class="n">or_statement</span> <span class="o">=</span> <span class="p">[</span>
					<span class="p">{</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="n">seqRawData</span><span class="p">},</span> <span class="c">#seqRawData = &#39;@SEQ&#39; currently </span>
					<span class="p">{</span>                
					 <span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span><span class="n">include_recombination_type</span><span class="p">}</span>
					<span class="p">}</span>
				<span class="p">]</span>
				
				<span class="k">if</span> <span class="n">include_analyses</span><span class="p">:</span><span class="c">#update to include analyses names				</span>
					<span class="n">include_analyses</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">include_analyses</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">seqRawData</span><span class="p">]</span>
					<span class="n">or_statement</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span><span class="n">include_analyses</span><span class="p">}</span> <span class="c">#now or statment becomes {&#39;ANALYSIS_NAME&#39;:&#39;seq&#39; or  [analysis_name:$in list, AND RECOMBINATION_TYPE: $in list ]</span>
				
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span>  <span class="n">db</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">find</span><span class="p">({</span>
					<span class="n">expIdentifier</span><span class="p">:</span><span class="n">exp_query</span><span class="p">,</span>
					<span class="s">&#39;$or&#39;</span><span class="p">:</span><span class="n">or_statement</span>
				<span class="p">},</span><span class="n">fields_to_project</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;SEQ_ID&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hint</span><span class="p">(</span><span class="s">&#39;exp_seq_id_an_rt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="o">*</span><span class="n">total_docs_per_seq</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span> <span class="c">#DO NOT FILTER BY RECOMBINATION_TYPE                       </span>
				<span class="k">if</span> <span class="n">seqRawData</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">include_analyses</span><span class="p">:</span>
					<span class="n">include_analyses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqRawData</span><span class="p">)</span>                    
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">find</span><span class="p">({</span>
						<span class="n">expIdentifier</span><span class="p">:</span><span class="n">exp_query</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:{</span><span class="s">&#39;$in&#39;</span><span class="p">:</span><span class="n">include_analyses</span><span class="p">}</span>
				<span class="p">},</span><span class="n">fields_to_project</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;SEQ_ID&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hint</span><span class="p">(</span><span class="s">&#39;exp_seq_id_an_rt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="o">*</span><span class="n">total_docs_per_seq</span><span class="p">)</span>
				
			<span class="c">#create a generator to parse the cursor and group together documents by SEQ_ID</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">group_documents_by_seq_id</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span><span class="n">same_document</span><span class="p">)</span>                  
		
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="n">schema_fields</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following values will be projected: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fields_to_project</span><span class="p">)))</span>		
		
		<span class="k">return</span> <span class="bp">self</span>
		
	<span class="c">#this function will query num_doc_search within each experiment defined for every analysis type possible in that experiment</span>
	<span class="c">#field name =&gt; single string defining unique field to use </span>
	<span class="c">#distinct_fields =&gt; reports which fields we want distinct values from. a list of fields</span>
	<span class="c">#if analyses is not blank, then this function will report distinct values from only those listed analyses</span>
	<span class="c">#num_doc_search =&gt; the query will limit the results to this many results </span>
	<span class="c">#num_doc_skip =&gt; the query will skip the first X documents (useful for preforming back to back functions. i.e. getting first 100 then next) </span>
	<span class="c">#filter_by_query =&gt; a general MONGODB query dictionary that defines hoDw to first filter results from database before counting unique values </span>
	<span class="c">#exp_id =&gt; PASS in a list of object ids corresponding to a experiments 	</span>
	<span class="c">#metadata_query =&gt; in addition to explicity passing in a list of ObjectId&#39;s, a user can further filter experiemnts by querying teh exps collection/metadata</span>
		<span class="c">#for example, if metadata_query = {&#39;PROJECT_NAME&#39;:&#39;Demo&#39;}, then first the this metadata will be queried to return exp_ids whose PROJECT_NAME contain &#39;Demo&#39; 	</span>
	<span class="k">def</span> <span class="nf">get_distinct_values_from_experiment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">field_name</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">analysis_name</span><span class="o">=</span><span class="p">[],</span><span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span><span class="n">filter_by_query</span><span class="o">=</span><span class="p">{},</span><span class="n">metadata_query</span><span class="o">=</span><span class="p">{},</span><span class="n">num_doc_search</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">num_doc_skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">treat_analysis_types_seperate</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following function was desired &quot;get_distinct_values_from_experiment&quot;. The following settings were requested: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;distinct field name&#39;</span><span class="p">:</span><span class="n">field_name</span><span class="p">,</span> <span class="s">&#39;treat analyses seperately&#39;</span><span class="p">:</span><span class="n">treat_analysis_types_seperate</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
	
		<span class="c">#if treat_analysis_types_seperate:</span>
		<span class="c">#	group_by_field = {&#39;ANALYSIS_NAME&#39;:&#39;$ANALYSIS_NAME&#39;,field_name:&#39;$&#39;+field_name}</span>
		<span class="c">#else:</span>
		<span class="n">group_by_field</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;distinct_field&#39;</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">field_name</span><span class="p">}</span>

		<span class="n">compiled_schema_fields</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">):</span>			
			<span class="c">#in this special situation, we do not know which analyses to search by...</span>
			<span class="c">#so we will obtain the list of possible exp_ids using exp_id and metadata_query (normally this is handled in function aggregate_seqs_collection, but we will do it here to get a list of possible experiments</span>
			
			<span class="c">#if exp_id is passed in as empty, then make it self.allowed_experiment_ids</span>
			<span class="k">if</span> <span class="n">exp_id</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> 
				<span class="n">exp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span>
			<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
				<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_id</span><span class="p">]</span>
										
			<span class="k">if</span> <span class="n">metadata_query</span><span class="p">:</span>		
				<span class="c">#query exp_collection</span>
				<span class="c">#result of query will be stored in class name &#39;self.query_results&#39;			</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_exps_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">metadata_query</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()})</span>				
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]):</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="k">if</span> <span class="n">exp</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">}</span>
					<span class="c">#erase metadata query 							</span>
					<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">[</span><span class="s">&#39;_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">meta</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span> <span class="o">=</span> <span class="p">{}</span>
					<span class="c">#no experiments to searchby. no experiments were found !</span>
					<span class="n">exp_id</span> <span class="o">=</span> <span class="p">[]</span>			
										
			<span class="c">#now we have  alist of possible EXP_ID...	</span>
			<span class="k">if</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">filter_by_query</span><span class="p">:</span>					
				<span class="n">possible_exp_id</span> <span class="o">=</span> <span class="n">GetIdIntersection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">,</span><span class="n">exp_id</span><span class="p">],</span><span class="n">filter_by_query</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">])</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">possible_exp_id</span> <span class="o">=</span> <span class="n">GetIdIntersection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_experiment_ids</span><span class="p">,</span><span class="n">exp_id</span><span class="p">])</span>
			
			<span class="c">#using list of possible EXP_ID&#39;s, query for analysis names </span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">exps</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="n">possible_exp_id</span><span class="p">},{</span><span class="s">&#39;ANALYSES_COUNT&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
			<span class="n">list_of_analyses</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">each_exp</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span><span class="c">#go through each query result/exp metadata,</span>
				<span class="k">if</span> <span class="s">&#39;ANALYSES_COUNT&#39;</span> <span class="ow">in</span> <span class="n">each_exp</span><span class="p">:</span>
					<span class="n">list_of_analyses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">each_exp</span><span class="p">[</span><span class="s">&#39;ANALYSES_COUNT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="c">#each key in analyses_count corresponds to a new analyses type put in db</span>
			<span class="n">analysis_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list_of_analyses</span><span class="p">))</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">analysis_name</span><span class="p">:</span> <span class="c">#there are no analysis types for this experiment, so just exit function</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
				<span class="k">return</span> <span class="bp">self</span>

	

		<span class="c">#performs a distinct query search on EACH analysis type SEPERATELY </span>
		<span class="k">if</span> <span class="n">treat_analysis_types_seperate</span><span class="p">:</span>
			<span class="n">analysis_loops</span> <span class="o">=</span> <span class="n">analysis_name</span> <span class="c">#will be used to loop through each analyses_name seperately for performing aggregation </span>
		<span class="k">else</span><span class="p">:</span>				
			<span class="c">#instead of each analysis treated seperately, just group all analysises names in one search</span>
			<span class="n">analysis_loops</span> <span class="o">=</span> <span class="p">[</span><span class="n">analysis_name</span><span class="p">]</span> 
		
		<span class="c">#first QUERY THE seqs collection, using exp_id, filter_by_query command, and metadatQuery		</span>
		<span class="c">#self.query_seqs_collection(exp_id,analysis_name,recombination_type,query=filter_by_query,metadata_query=metadata_query)</span>
		
		<span class="c">#CREATE A MONGODB AGGREGATION FUNCTION RATHER THAN USE DISTINCT FUNCTION  =&gt; had problems using distinct function with skip and limit </span>
		<span class="c">#add cursor function to self.query_results </span>
		<span class="c">#second add a SKIP command to skip X documents</span>
		<span class="c">#third LIMIT command on the query</span>
		<span class="c">#fourth add a DISTINCT command at the end </span>
		<span class="n">chained_results</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#this will turn into a cursor keeping track of each of the curosrs called to the database</span>
		
		<span class="n">all_schema_fields</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">list_of_analyses</span> <span class="ow">in</span> <span class="n">analysis_loops</span><span class="p">:</span> 			
			<span class="c">#BY putting this in a loop, and query multiple times, we ensure that, rather than return the first X results, it will return the first X results for Y analysis names </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">=</span><span class="p">[</span>
				<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:</span><span class="n">filter_by_query</span><span class="p">},</span>			
				<span class="p">{</span><span class="s">&#39;$skip&#39;</span><span class="p">:</span><span class="n">num_doc_skip</span><span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>
					<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="n">group_by_field</span><span class="p">,</span>
					<span class="s">&#39;ANALYSES_NAMES&#39;</span><span class="p">:{</span><span class="s">&#39;$addToSet&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">}</span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;ANALYSES_NAMES&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="n">field_name</span><span class="p">:</span><span class="s">&#39;$_id.distinct_field&#39;</span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:{</span><span class="n">field_name</span><span class="p">:{</span><span class="s">&#39;$ne&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">}}}</span> <span class="c">#ignore null values </span>
			<span class="p">]</span>
			
			<span class="k">if</span> <span class="n">num_doc_search</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">num_doc_search</span><span class="p">})</span>																									
			
			<span class="c">#call aggregation function using this pipelin</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">aggregate_seqs_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">list_of_analyses</span><span class="p">,</span><span class="n">aggregation_fxn</span><span class="o">=</span><span class="n">aggregation_pipeline_query</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="n">metadata_query</span><span class="p">)</span>
			
			<span class="c">#keep running tally of all field names (should in theory be the same everytime)</span>
			<span class="n">compiled_schema_fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">)</span>
			
			<span class="c">#chain together the results for each query...			</span>
			<span class="n">chained_results</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">chained_results</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
			<span class="c">#self.query_results = self.query_results.skip(num_doc_skip).limit(num_doc_search)</span>
		
		<span class="c">#all queries set up, now reset se.fquery reulsts to the CHAIN_TYPES_SEQUENCED</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">compiled_schema_fields</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">chained_results</span>		
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c">#this field will group results from a query into distinct groups based on a specific field in the query result/filtered result  </span>
	<span class="c">#group_by_field_name =&gt; a list of fields from the dtabase that you want to group by. analysis_name and recombination_type will ALWAYS be included in group function </span>
	<span class="c">#analysis_name =&gt; query only results form this analysis type </span>
	<span class="c">#recombination_type =&gt; query only results from this recombination type </span>
	<span class="c">#filter_by_query =&gt; a general MONGODB query dictionary that defines how to first filter results formdatabase before counting unique values </span>
	<span class="c">#include_fields =&gt; in addition to unique fields combinations (in gruop by fields) alo include the first occurrence of any fields defined in this list </span>
	<span class="c">#treat_experiments_seperately =&gt; DO NOT INCLUDE identical values from SEPERATE EXPERIMENTS as same. Seperate them into differnet groups</span>
	<span class="c">#limit =&gt; only count distinct values from this limit . that is LIMIT THE RESULTS FO THE INITIAL FILTER/QUERY </span>
	<span class="c">#filter_counts =&gt; ONLY SHOW RESULTS WHOSE UNIQUE VALUES HAVE A COUNT &gt; THIS VALUE . for example filter_counts = 1=&gt; shows only sequences/unique values found more than one time in query </span>
	<span class="c">#sort_counts =&gt; SORT results by their respective counts</span>
	<span class="k">def</span> <span class="nf">count_unique_values_of_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">group_by_field_name</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">analysis_name</span><span class="o">=</span><span class="p">[],</span><span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span><span class="n">filter_by_query</span> <span class="o">=</span> <span class="p">{},</span><span class="n">metadata_query</span> <span class="o">=</span> <span class="p">{},</span><span class="n">include_fields</span><span class="o">=</span><span class="p">[],</span><span class="n">treat_experiments_seperately</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">filter_counts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sort_counts</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>        		
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following aggregation function was desired &quot;count unique values of a field&quot;. The following settings were requested: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;group_by_these_fields&#39;</span><span class="p">:</span><span class="n">group_by_field_name</span><span class="p">,</span> <span class="s">&#39;seperateByExp&#39;</span><span class="p">:</span><span class="n">treat_experiments_seperately</span><span class="p">,</span><span class="s">&#39;filter_count_results&#39;</span><span class="p">:</span><span class="n">filter_counts</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
				
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">group_by_field_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
			<span class="n">group_by_field_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">group_by_field_name</span><span class="p">]</span>
		
		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">include_fields</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
			<span class="n">include_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">include_fields</span><span class="p">]</span>
			
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">dict</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">):</span>
				<span class="n">analysis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$ne&#39;</span><span class="p">:</span><span class="n">seqRawData</span><span class="p">}</span>
			<span class="k">elif</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>			
				<span class="n">analysis_name</span><span class="o">=</span><span class="p">[</span><span class="n">analysis_name</span><span class="p">]</span>
		
		<span class="c">#for i,f in enumerate(field_name):</span>
		<span class="c">#	if not(f.startswith(&#39;DATA&#39;)):</span>
		<span class="c">#		field_name[i]=&#39;DATA.&#39;+f       </span>
		
			
		<span class="c">#this means we want to treat identical values from different experiments as SEPERATE GROUPS </span>
		<span class="c">#IN OTHER WORDS: do not group together sequences from differnet experiments</span>
		<span class="c">#ADD EXP_ID to group parameters</span>
		<span class="k">if</span> <span class="n">treat_experiments_seperately</span><span class="p">:</span>
			<span class="n">group_by_field_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expIdentifier</span><span class="p">)</span>    
		
		<span class="n">field_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">group_by_field_name</span><span class="p">))</span>
		
		<span class="c">#IMPORTANT, WE ARE GROUPING RESULTS BY SPECIFIC FIELD NAMES, AND THEN PROJECTING THE FIRST OCCURRENCE OF RESULTS (FOR EXAMPLE WE MIGHT WANT TO PROJECT UNIQUE CDR3AA BUT ONLY PROJECT THE FIRST OCCURRENCE OF ALL ANTIBODY FIELDS (DATA = 1). </span>
		<span class="c">#IN THIS CASE , THEN CDR3.AA WILL BE INCLUDED IN THE PROJECT OF DATA, SO WE NEED TO EXLCUDE IT FROM BEING PROJECTED SEPERATELY</span>
		<span class="c">#IF WE DONT EXCLUDE THE SEQUENCE, THEN THE AGGREGATION FUNCTION GENERATES AN ERROR </span>
		<span class="n">included_grouped_field</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">group_by_field_name</span><span class="p">:</span>			
			<span class="n">included_grouped_field</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#bydefault project the field </span>
			<span class="k">for</span> <span class="n">projected_fields</span> <span class="ow">in</span> <span class="n">include_fields</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">projected_fields</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;$$ROOT&#39;</span><span class="p">,</span><span class="s">&#39;$$CURRENT&#39;</span><span class="p">]:</span> <span class="c">#we are projecting the entire document (see mongo documentation), ===&gt; CURRENTLY ROOT OR CURRENT DOES NOT SEEM TO WORK PROPERLY</span>
					<span class="n">included_grouped_field</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 	<span class="c">#so no need to project this field</span>
				<span class="k">elif</span> <span class="n">projected_fields</span> <span class="o">==</span> <span class="n">fields</span> <span class="ow">or</span> <span class="n">fields</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">projected_fields</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="p">):</span> <span class="c">#we are projecting the node/parent that already includes this field</span>
					<span class="n">included_grouped_field</span><span class="p">[</span><span class="n">fields</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 	<span class="c">#so no need to project this field</span>
						
		
		<span class="c">#now build teh aggregation pipeline that we will use </span>
		<span class="c">#note =&gt; analysis names, RECOMBINATION_TYPE, metadata_query, and exp_id will be used in the next function aggregate_seqs_collection</span>
		<span class="c">#this just getnerates the aggregation function that we pass into aggregate_seqs_collection</span>
		
		<span class="c">#first define teh &#39;MATCH&#39;/filter command of the pipeline</span>
		<span class="n">aggregation_pipeline_query</span> <span class="o">=</span> <span class="p">[</span>
			<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:</span><span class="n">filter_by_query</span><span class="p">},</span> <span class="c">#return only docs that match this query </span>
			<span class="c">#GROUP BY DEFINED FIELDNAME</span>
			<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span>
					<span class="p">{</span>
						<span class="c">#group results by 1) analysis name, 2) recombination type, 3) all other fields defined by field_name</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">({</span>
								<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
								<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
								<span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span>
								<span class="p">{</span><span class="s">&quot;FIELDNAME_{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span><span class="s">&quot;${0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_name</span><span class="p">)}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c">#these are all the fields we use for grouping</span>
							<span class="p">),</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="c">#create a new COUNTS field that will add one for every member added into group (basically count num unique)</span>
					<span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span>
					<span class="p">{</span><span class="n">each_field</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span><span class="s">&#39;____&#39;</span><span class="p">):{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">each_field</span><span class="p">}</span> <span class="k">for</span> <span class="n">each_field</span> <span class="ow">in</span> <span class="n">include_fields</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c">#project the FIRST OCCURRENCE of any field defined by include_fields			</span>
				<span class="p">)</span>
			<span class="p">},</span>
			<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">({</span><span class="c">#RENAME THE RESULTING GROUPS, BASICALLY SEPERATE GROUPS FROM THE ID field </span>
				<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span><span class="c">#this is first key under &#39;_id&#39; formed from group fxn above</span>
				<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span><span class="c">#this is the second key under &#39;_id&#39; fromed from group fxn above</span>
				<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="c">#include &#39;COUNTS&#39; field </span>
				<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="c">#exclude id field</span>
				<span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span>
				<span class="c">#the custom dictionary of all other ekys in &#39;id&#39;/group field. </span>
				<span class="p">{</span><span class="s">&quot;{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">):</span><span class="s">&quot;$_id.FIELDNAME_{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">included_grouped_field</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span> <span class="c">#these are all the fields we project after grouping. take them outside of the &#39;ID&#39; field, makes results prettier    </span>
				<span class="p">{</span><span class="s">&quot;{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">):</span><span class="s">&quot;${0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span><span class="s">&#39;____&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">include_fields</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c">#project the ORIGINAL FIELD NAME of the projected field taken from groouping</span>
				<span class="p">)</span>
			<span class="p">}</span>			
		<span class="p">]</span>
		
		<span class="k">if</span> <span class="n">limit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="c">#add a limit command to second index position in array </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">limit</span><span class="p">})</span>
			    								
		<span class="c">#add a FINAL filter step if the value, &#39;filter_counts&#39; &gt; 0 </span>
		<span class="k">if</span> <span class="n">filter_counts</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>			
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;$match&#39;</span><span class="p">:{</span><span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$gt&#39;</span><span class="p">:</span><span class="n">filter_counts</span><span class="p">}}})</span>
		
		<span class="c">#add a sort stage at the end to sort by most occuring values</span>
		<span class="k">if</span> <span class="n">sort_counts</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;$sort&#39;</span><span class="p">:{</span><span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}})</span>
					
		<span class="c">#RUN THE QUERY using the custom aggregation function </span>
		<span class="c">#THIS FUNCION WILL use the exp_id value and the metadata_query value </span>
		<span class="bp">self</span><span class="o">.</span><span class="n">aggregate_seqs_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">analysis_name</span><span class="p">,</span><span class="n">recombination_type</span><span class="p">,</span><span class="n">aggregation_pipeline_query</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="n">metadata_query</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="n">allowDiskUse</span><span class="p">)</span>
	
		
	<span class="k">def</span> <span class="nf">v_allele_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">analysis_name</span><span class="o">=</span><span class="p">[],</span><span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span><span class="n">filter_by_query</span><span class="o">=</span><span class="p">{},</span><span class="n">metadata_query</span><span class="o">=</span><span class="p">{},</span><span class="n">only_consider_first_allele_element</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">treat_experiments_seperately</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sort_counts</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following aggregation function was desired &quot;v_allele_usage&quot;. The following settings were requested: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;only_consider_first_allele_element&#39;</span><span class="p">:</span><span class="n">only_consider_first_allele_element</span><span class="p">,</span> <span class="s">&#39;seperateByExp&#39;</span><span class="p">:</span><span class="n">treat_experiments_seperately</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>
		
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
									
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">dict</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">):</span>
				<span class="n">analysis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$ne&#39;</span><span class="p">:</span><span class="n">seqRawData</span><span class="p">}</span>
			<span class="k">elif</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>			
				<span class="n">analysis_name</span><span class="o">=</span><span class="p">[</span><span class="n">analysis_name</span><span class="p">]</span>
		
		<span class="n">aggregation_pipeline_query</span><span class="o">=</span><span class="p">[</span>
			<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:</span><span class="n">filter_by_query</span><span class="p">},</span><span class="c">#filter results by query </span>
			<span class="p">{</span><span class="s">&#39;$unwind&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.VREGION.VGENES&#39;</span><span class="p">},</span><span class="c">#unwind all vgene elements in list 			</span>
		<span class="p">]</span>
		
		<span class="k">if</span> <span class="n">only_consider_first_allele_element</span><span class="p">:</span> <span class="c">#so we want to ignore all other vgenes selected from the unwind command (cannot use slice, to only project first...yet?)</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span><span class="c">#group all &#39;unwound elements&#39; by &#39;_id. all vgene from list in same documetn should have same &#39;_id&#39;</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="s">&#39;$_id&#39;</span><span class="p">,</span>
						<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.VREGION.VGENES&#39;</span><span class="p">},</span> <span class="c">#store the FIRST occurrence of a V GENE 						</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">},</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span><span class="p">},</span>
						 <span class="n">expIdentifier</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c">#instead of just taking the first element, just rename the v elements </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>					
						<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.VREGION.VGENES&#39;</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						 <span class="n">expIdentifier</span><span class="p">:</span><span class="mi">1</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">)</span>
		
		<span class="c">#NO complette the piipeline by grouping together documents with identical V ALLELE </span>
		<span class="k">if</span> <span class="n">treat_experiments_seperately</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>			
						<span class="s">&#39;_id&#39;</span><span class="p">:{</span>
							<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$V_ALLELE&#39;</span><span class="p">,</span>
							 <span class="n">expIdentifier</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">,</span>
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
						<span class="p">},</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="c">#count each unique vallele/exp occurrence </span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span>
						 <span class="n">expIdentifier</span><span class="p">:</span><span class="s">&#39;$_id.&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">,</span>
						<span class="s">&#39;DATA.VREGION.VGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.V_ALLELE&#39;</span>						
					<span class="p">}</span>					
				<span class="p">}</span>
			<span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>			
						<span class="s">&#39;_id&#39;</span><span class="p">:{</span>
							<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$V_ALLELE&#39;</span><span class="p">,</span>							
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
						<span class="p">},</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="c">#count each unique vallele occurrence </span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span>					
						<span class="s">&#39;DATA.VREGION.VGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.V_ALLELE&#39;</span>						
					<span class="p">}</span>					
				<span class="p">}</span>
			<span class="p">])</span>
		
		<span class="k">if</span> <span class="n">limit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="c">#add a limit command to second index position in array </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">limit</span><span class="p">})</span>
		
		<span class="c">#add a sort stage at the end to sort by most occuring values</span>
		<span class="k">if</span> <span class="n">sort_counts</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;$sort&#39;</span><span class="p">:{</span><span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}})</span>
					
		<span class="c">#RUN THE QUERY using the custom aggregation function </span>
		<span class="c">#THIS FUNCION WILL use the exp_id value and the metadata_query value </span>
		<span class="bp">self</span><span class="o">.</span><span class="n">aggregate_seqs_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">analysis_name</span><span class="p">,</span><span class="n">recombination_type</span><span class="p">,</span><span class="n">aggregation_pipeline_query</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="n">metadata_query</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="n">allowDiskUse</span><span class="p">)</span>
		
		<span class="k">return</span> <span class="bp">self</span>
	
	<span class="k">def</span> <span class="nf">j_allele_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">analysis_name</span><span class="o">=</span><span class="p">[],</span><span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span><span class="n">filter_by_query</span><span class="o">=</span><span class="p">{},</span><span class="n">metadata_query</span><span class="o">=</span><span class="p">{},</span><span class="n">only_consider_first_allele_element</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">treat_experiments_seperately</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sort_counts</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following aggregation function was desired &quot;j_allele_usage&quot;. The following settings were requested: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;only_consider_first_allele_element&#39;</span><span class="p">:</span><span class="n">only_consider_first_allele_element</span><span class="p">,</span> <span class="s">&#39;seperateByExp&#39;</span><span class="p">:</span><span class="n">treat_experiments_seperately</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>
		
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
									
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">dict</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">):</span>
				<span class="n">analysis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$ne&#39;</span><span class="p">:</span><span class="n">seqRawData</span><span class="p">}</span>
			<span class="k">elif</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>			
				<span class="n">analysis_name</span><span class="o">=</span><span class="p">[</span><span class="n">analysis_name</span><span class="p">]</span>
		
		<span class="n">aggregation_pipeline_query</span><span class="o">=</span><span class="p">[</span>
			<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:</span><span class="n">filter_by_query</span><span class="p">},</span><span class="c">#filter results by query </span>
			<span class="p">{</span><span class="s">&#39;$unwind&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.JREGION.JGENES&#39;</span><span class="p">},</span><span class="c">#unwind all Jgene elements in list 			</span>
		<span class="p">]</span>
		
		<span class="k">if</span> <span class="n">only_consider_first_allele_element</span><span class="p">:</span> <span class="c">#so we want to ignore all other Jgenes selected from the unwind command (cannot use slice, to only project first...yet?)</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span><span class="c">#group all &#39;unwound elements&#39; by &#39;_id. all Jgene from list in same documetn should have same &#39;_id&#39;</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="s">&#39;$_id&#39;</span><span class="p">,</span>
						<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.JREGION.JGENES&#39;</span><span class="p">},</span> <span class="c">#store the FIRST occurrence of a J GENE 						</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">},</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span><span class="p">},</span>
						 <span class="n">expIdentifier</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c">#instead of just taking the first element, just rename the J elements </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>					
						<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.JREGION.JGENES&#39;</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						 <span class="n">expIdentifier</span><span class="p">:</span><span class="mi">1</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">)</span>
		
		<span class="c">#NO complette the piipeline by grouping together documents with identical J ALLELE </span>
		<span class="k">if</span> <span class="n">treat_experiments_seperately</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>			
						<span class="s">&#39;_id&#39;</span><span class="p">:{</span>
							<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$J_ALLELE&#39;</span><span class="p">,</span>
							 <span class="n">expIdentifier</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">,</span>
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
						<span class="p">},</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="c">#count each unique Jallele/exp occurrence </span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span>
						 <span class="n">expIdentifier</span><span class="p">:</span><span class="s">&#39;$_id.&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">,</span>
						<span class="s">&#39;DATA.JREGION.JGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.J_ALLELE&#39;</span>						
					<span class="p">}</span>					
				<span class="p">}</span>
			<span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>			
						<span class="s">&#39;_id&#39;</span><span class="p">:{</span>
							<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$J_ALLELE&#39;</span><span class="p">,</span>							
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
						<span class="p">},</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="c">#count each unique Jallele occurrence </span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span>					
						<span class="s">&#39;DATA.JREGION.JGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.J_ALLELE&#39;</span>						
					<span class="p">}</span>					
				<span class="p">}</span>
			<span class="p">])</span>
		
		<span class="k">if</span> <span class="n">limit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="c">#add a limit command to second index position in array </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">limit</span><span class="p">})</span>
		
		<span class="c">#add a sort stage at the end to sort by most occuring values</span>
		<span class="k">if</span> <span class="n">sort_counts</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;$sort&#39;</span><span class="p">:{</span><span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}})</span>
					
		<span class="c">#RUN THE QUERY using the custom aggregation function </span>
		<span class="c">#THIS FUNCION WILL use the exp_id value and the metadata_query value </span>
		<span class="bp">self</span><span class="o">.</span><span class="n">aggregate_seqs_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">analysis_name</span><span class="p">,</span><span class="n">recombination_type</span><span class="p">,</span><span class="n">aggregation_pipeline_query</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="n">metadata_query</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="n">allowDiskUse</span><span class="p">)</span>
	
		<span class="k">return</span> <span class="bp">self</span>
	
	<span class="k">def</span> <span class="nf">vj_allele_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">analysis_name</span><span class="o">=</span><span class="p">[],</span><span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span><span class="n">filter_by_query</span><span class="o">=</span><span class="p">{},</span><span class="n">metadata_query</span><span class="o">=</span><span class="p">{},</span><span class="n">only_consider_first_allele_element</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">treat_experiments_seperately</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sort_counts</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following aggregation function was desired &quot;v_allele_usage&quot;. The following settings were requested: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;only_consider_first_allele_element&#39;</span><span class="p">:</span><span class="n">only_consider_first_allele_element</span><span class="p">,</span> <span class="s">&#39;seperateByExp&#39;</span><span class="p">:</span><span class="n">treat_experiments_seperately</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>
		
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
									
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">dict</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">):</span>
				<span class="n">analysis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$ne&#39;</span><span class="p">:</span><span class="n">seqRawData</span><span class="p">}</span>
			<span class="k">elif</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>			
				<span class="n">analysis_name</span><span class="o">=</span><span class="p">[</span><span class="n">analysis_name</span><span class="p">]</span>
		
		<span class="n">aggregation_pipeline_query</span><span class="o">=</span><span class="p">[</span>
			<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:</span><span class="n">filter_by_query</span><span class="p">},</span><span class="c">#filter results by query </span>
			<span class="p">{</span><span class="s">&#39;$unwind&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.VREGION.VGENES&#39;</span><span class="p">},</span><span class="c">#unwind all vgene elements in list 			</span>
			<span class="p">{</span><span class="s">&#39;$unwind&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.JREGION.JGENES&#39;</span><span class="p">},</span><span class="c">#unwind all Jgene elements in list 			</span>
		<span class="p">]</span>
		
		<span class="k">if</span> <span class="n">only_consider_first_allele_element</span><span class="p">:</span> <span class="c">#so we want to ignore all other vgenes selected from the unwind command (cannot use slice, to only project first...yet?)</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span><span class="c">#group all &#39;unwound elements&#39; by &#39;_id. all vgene from list in same documetn should have same &#39;_id&#39;</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="s">&#39;$_id&#39;</span><span class="p">,</span>
						<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.VREGION.VGENES&#39;</span><span class="p">},</span> <span class="c">#store the FIRST occurrence of a V GENE 						</span>
						<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.JREGION.JGENES&#39;</span><span class="p">},</span> <span class="c">#store the FIRST occurrence of a J GENE 						</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">},</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span><span class="p">},</span>
						 <span class="n">expIdentifier</span><span class="p">:{</span><span class="s">&#39;$first&#39;</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c">#instead of just taking the first element, just rename the v elements </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>					
						<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.VREGION.VGENES&#39;</span><span class="p">,</span>
						<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$DATA.JREGION.JGENES&#39;</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						 <span class="n">expIdentifier</span><span class="p">:</span><span class="mi">1</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">)</span>
		
		<span class="c">#NOW complette the piipeline by grouping together documents with identical V ALLELE </span>
		<span class="k">if</span> <span class="n">treat_experiments_seperately</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>			
						<span class="s">&#39;_id&#39;</span><span class="p">:{</span>
							<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$V_ALLELE&#39;</span><span class="p">,</span>
							<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$J_ALLELE&#39;</span><span class="p">,</span>
							 <span class="n">expIdentifier</span><span class="p">:</span><span class="s">&#39;$&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">,</span>
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
						<span class="p">},</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="c">#count each unique vallele/exp occurrence </span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span>
						 <span class="n">expIdentifier</span><span class="p">:</span><span class="s">&#39;$_id.&#39;</span><span class="o">+</span><span class="n">expIdentifier</span><span class="p">,</span>
						<span class="s">&#39;DATA.VREGION.VGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.V_ALLELE&#39;</span><span class="p">,</span>						
						<span class="s">&#39;DATA.JREGION.JGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.J_ALLELE&#39;</span>						
					<span class="p">}</span>					
				<span class="p">}</span>
			<span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
				<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>			
						<span class="s">&#39;_id&#39;</span><span class="p">:{</span>
							<span class="s">&#39;V_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$V_ALLELE&#39;</span><span class="p">,</span>							
							<span class="s">&#39;J_ALLELE&#39;</span><span class="p">:</span><span class="s">&#39;$J_ALLELE&#39;</span><span class="p">,</span>							
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
						<span class="p">},</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="c">#count each unique vallele occurrence </span>
					<span class="p">}</span>
				<span class="p">},</span>
				<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:{</span>
						<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
						<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
						<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span>
						<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span>					
						<span class="s">&#39;DATA.VREGION.VGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.V_ALLELE&#39;</span><span class="p">,</span>
						<span class="s">&#39;DATA.JREGION.JGENES&#39;</span><span class="p">:</span><span class="s">&#39;$_id.J_ALLELE&#39;</span>						
					<span class="p">}</span>					
				<span class="p">}</span>
			<span class="p">])</span>
		
		<span class="k">if</span> <span class="n">limit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="c">#add a limit command to second index position in array </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">limit</span><span class="p">})</span>
		
		<span class="c">#add a sort stage at the end to sort by most occuring values</span>
		<span class="k">if</span> <span class="n">sort_counts</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;$sort&#39;</span><span class="p">:{</span><span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}})</span>
					
		<span class="c">#RUN THE QUERY using the custom aggregation function </span>
		<span class="c">#THIS FUNCION WILL use the exp_id value and the metadata_query value </span>
		<span class="bp">self</span><span class="o">.</span><span class="n">aggregate_seqs_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">analysis_name</span><span class="p">,</span><span class="n">recombination_type</span><span class="p">,</span><span class="n">aggregation_pipeline_query</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="n">metadata_query</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="n">allowDiskUse</span><span class="p">)</span>
	
		<span class="k">return</span> <span class="bp">self</span>
		
	<span class="c">#this field will group results from a query into by the field CDR3_AA_LENGTH	</span>
	<span class="c">#feature=&gt; allowed values &#39;NT&#39;, or &#39;AA&#39; =&gt; whether or not to perform length distribution on cdr3 aa or cdr3 nt </span>
	<span class="c">#analysis_name =&gt; query only results form this analysis type </span>
	<span class="c">#recombination_type =&gt; query only results from this recombination type </span>
	<span class="c">#filter_by_query =&gt; a general MONGODB query dictionary that defines how to first filter results formdatabase before counting unique values 	</span>
	<span class="c">#treat_experiments_seperately =&gt; DO NOT INCLUDE identical values from SEPERATE EXPERIMENTS as same. Seperate them into differnet groups</span>
	<span class="c">#limit =&gt; only count distinct values from this limit . that is LIMIT THE RESULTS FO THE INITIAL FILTER/QUERY 	</span>
	<span class="c">#sort_counts =&gt; SORT CDR3_LENGTHS by their respective counts	</span>
	<span class="k">def</span> <span class="nf">cdr3_length_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">exp_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">feature</span><span class="o">=</span><span class="s">&#39;AA&#39;</span><span class="p">,</span><span class="n">analysis_name</span> <span class="o">=</span> <span class="p">[],</span><span class="n">recombination_type</span><span class="o">=</span><span class="p">[],</span><span class="n">filter_by_query</span><span class="o">=</span><span class="p">{},</span><span class="n">metadata_query</span> <span class="o">=</span> <span class="p">{},</span><span class="n">treat_experiments_seperately</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sort_counts</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">exclude_cdr3_lengths_not_multiple_three</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">exclude_empty_cdr3_strings</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="n">feature</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">feature</span><span class="o">==</span><span class="s">&#39;NT&#39;</span><span class="p">:</span>
			<span class="n">field_name</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;DATA.CDR3.NT_LENGTH&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">exclude_empty_cdr3_strings</span><span class="p">:</span><span class="c">#only select cdr3 lengths &gt; 2 (only length of 3 or more is releveant AA) </span>
				<span class="k">if</span> <span class="n">exclude_cdr3_lengths_not_multiple_three</span><span class="p">:</span>
					<span class="c">#also only choose values whose cdr3 nt length is a factor of 3 </span>
					<span class="n">filter_by_query</span><span class="p">[</span><span class="s">&#39;DATA.CDR3.NT_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$gt&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;$mod&#39;</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">filter_by_query</span><span class="p">[</span><span class="s">&#39;DATA.CDR3.NT_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$gt&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
		<span class="k">elif</span> <span class="n">feature</span><span class="o">==</span><span class="s">&#39;AA&#39;</span><span class="p">:</span>
			<span class="n">field_name</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;DATA.CDR3.AA_LENGTH&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">exclude_empty_cdr3_strings</span><span class="p">:</span><span class="c">#only select cdr3 lengths &gt; 0 </span>
				<span class="n">filter_by_query</span><span class="p">[</span><span class="s">&#39;DATA.CDR3.AA_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$gt&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span> 
				<span class="k">if</span> <span class="n">exclude_cdr3_lengths_not_multiple_three</span><span class="p">:</span>				
					<span class="c">#also only choose values whose cdr3 nt length is a factor of 3 </span>
					<span class="n">filter_by_query</span><span class="p">[</span><span class="s">&#39;DATA.CDR3.NT_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$mod&#39;</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span>
			
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The variable feature can only be a string with the value &#39;NT&#39; or &#39;AA&#39;&quot;</span><span class="p">)</span>
		
		<span class="bp">self</span><span class="o">.</span><span class="n">logged_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following aggregation function was desired &quot;cdr3_length_distribution&quot;. The following settings were requested: {0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">({</span><span class="s">&#39;experiments&#39;</span><span class="p">:</span><span class="n">exp_id</span><span class="p">,</span><span class="s">&#39;cdr3_feature&#39;</span><span class="p">:</span><span class="n">feature</span><span class="p">,</span> <span class="s">&#39;seperateByExp&#39;</span><span class="p">:</span><span class="n">treat_experiments_seperately</span><span class="p">,</span><span class="s">&#39;metadata_query&#39;</span><span class="p">:</span><span class="n">metadata_query</span><span class="p">})))</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="c">#db_reader						</span>
				
					
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">dict</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">):</span>
				<span class="n">analysis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;$ne&#39;</span><span class="p">:</span><span class="n">seqRawData</span><span class="p">}</span>
			<span class="k">elif</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">analysis_name</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>			
				<span class="n">analysis_name</span><span class="o">=</span><span class="p">[</span><span class="n">analysis_name</span><span class="p">]</span>
		
							
		<span class="c">#this means we want to treat identical values from different experiments as SEPERATE GROUPS </span>
		<span class="c">#IN OTHER WORDS: do not group together sequences from differnet experiments</span>
		<span class="c">#ADD EXP_ID to group parameters		</span>
		<span class="k">if</span> <span class="n">treat_experiments_seperately</span><span class="p">:</span>
			<span class="n">field_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expIdentifier</span><span class="p">)</span>    
		
		<span class="c">#now build teh aggregation pipeline that we will use </span>
		<span class="c">#note =&gt; analysis names, RECOMBINATION_TYPE, metadata_query, and exp_id will be used in the next function aggregate_seqs_collection</span>
		<span class="c">#this just getnerates the aggregation function that we pass into aggregate_seqs_collection</span>
		
		<span class="c">#first define teh &#39;MATCH&#39;/filter command of the pipeline</span>
		<span class="n">aggregation_pipeline_query</span> <span class="o">=</span> <span class="p">[</span>
			<span class="p">{</span><span class="s">&#39;$match&#39;</span><span class="p">:</span><span class="n">filter_by_query</span><span class="p">},</span> <span class="c">#return only docs that match this query </span>
			<span class="c">#GROUP BY DEFINED FIELDNAME</span>
			<span class="p">{</span><span class="s">&#39;$group&#39;</span><span class="p">:{</span>
					<span class="c">#group results by 1) analysis name, 2) recombination type, 3) all other fields defined by field_name</span>
					<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">({</span>
							<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$ANALYSIS_NAME&#39;</span><span class="p">,</span>
							<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$RECOMBINATION_TYPE&#39;</span>
							<span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span>
							<span class="p">{</span><span class="s">&quot;FIELDNAME_{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span><span class="s">&quot;${0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_name</span><span class="p">)}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c">#these are all the fields we use for grouping</span>
						<span class="p">),</span>
					<span class="s">&#39;COUNTS&#39;</span><span class="p">:{</span><span class="s">&#39;$sum&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="c">#create a new COUNTS field that will add one for every member added into group (basically count num unique)</span>
				
				<span class="p">}</span>
			<span class="p">},</span>
			<span class="p">{</span><span class="s">&#39;$project&#39;</span><span class="p">:</span><span class="nb">dict</span><span class="p">({</span><span class="c">#RENAME THE RESULTING GROUPS, BASICALLY SEPERATE GROUPS FROM THE ID field </span>
					<span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">:</span><span class="s">&#39;$_id.ANALYSIS_NAME&#39;</span><span class="p">,</span><span class="c">#this is first key under &#39;_id&#39; formed from group fxn above</span>
					<span class="s">&#39;RECOMBINATION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;$_id.RECOMBINATION_TYPE&#39;</span><span class="p">,</span><span class="c">#this is the second key under &#39;_id&#39; fromed from group fxn above</span>
					<span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="c">#include &#39;COUNTS&#39; field </span>
					<span class="s">&#39;_id&#39;</span><span class="p">:</span><span class="mi">0</span><span class="c">#exclude id field</span>
					<span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span>
					<span class="c">#the custom dictionary of all other ekys in &#39;id&#39;/group field. </span>
					<span class="p">{</span><span class="s">&quot;{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">):</span><span class="s">&quot;$_id.FIELDNAME_{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_name</span><span class="p">)}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c">#these are all the fields we project after grouping. take them outside of the &#39;ID&#39; field, makes results prettier    				</span>
				<span class="p">)</span>
			<span class="p">}</span>
		<span class="p">]</span>
		
		<span class="k">if</span> <span class="n">limit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="c">#add a limit command to second index position in array </span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,{</span><span class="s">&#39;$limit&#39;</span><span class="p">:</span><span class="n">limit</span><span class="p">})</span>
		
		<span class="c">#add a sort stage at the end to sort by most occuring values</span>
		<span class="k">if</span> <span class="n">sort_counts</span><span class="p">:</span>
			<span class="n">aggregation_pipeline_query</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;$sort&#39;</span><span class="p">:{</span><span class="s">&#39;COUNTS&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}})</span>
					
		<span class="c">#RUN THE QUERY using the custom aggregation function </span>
		<span class="c">#THIS FUNCION WILL use the exp_id value and the metadata_query value </span>
		<span class="bp">self</span><span class="o">.</span><span class="n">aggregate_seqs_collection</span><span class="p">(</span><span class="n">exp_id</span><span class="p">,</span><span class="n">analysis_name</span><span class="p">,</span><span class="n">recombination_type</span><span class="p">,</span><span class="n">aggregation_pipeline_query</span><span class="p">,</span><span class="n">metadata_query</span><span class="o">=</span><span class="n">metadata_query</span><span class="p">,</span><span class="n">allowDiskUse</span><span class="o">=</span><span class="n">allowDiskUse</span><span class="p">)</span>
	
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># ################Cursor Modification Functions######################</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		The following functions are used to actually modify the format of the document coming out of the database. For example, it could</span>
<span class="sd">		convert documents be renaming keys, or it could convert documents into strings (i.e. json.dumps), or it could</span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c"># Creates a generator for going through the cursor results and grouping results by seq_id</span>
	<span class="c"># If same_document, then all results are merged into one document, if False, then only the information from @SEQ is appended to each dcoument</span>
	<span class="k">def</span> <span class="nf">group_documents_by_seq_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">same_document</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="k">def</span> <span class="nf">group_by_id</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
			<span class="n">reported_docs</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">seq_id</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
			<span class="n">output_doc</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="k">for</span> <span class="n">doc_results</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">doc_results</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span> <span class="o">!=</span> <span class="n">seq_id</span><span class="p">:</span>
					<span class="c"># New doc found</span>
					<span class="k">if</span> <span class="n">output_doc</span><span class="p">:</span>
						<span class="c"># Output all results to the same result/document/same row</span>
						<span class="k">if</span> <span class="n">same_document</span><span class="p">:</span>
							<span class="k">yield</span> <span class="n">output_doc</span>
						<span class="c"># Split up results by annotation</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="n">sub_doc</span> <span class="o">=</span> <span class="n">output_doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;ANALYSES&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
							<span class="k">if</span> <span class="n">sub_doc</span><span class="p">:</span>
								<span class="c"># No annotation results found</span>
								<span class="n">output_doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
								<span class="n">output_doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;DATE_UPDATED&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
								<span class="n">output_doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;_id&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
								<span class="k">for</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">each_doc</span> <span class="ow">in</span> <span class="n">sub_doc</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
									<span class="n">each_doc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">output_doc</span><span class="p">)</span>
									<span class="k">yield</span> <span class="n">each_doc</span>
							<span class="k">else</span><span class="p">:</span>
								<span class="k">yield</span> <span class="n">output_doc</span>
						<span class="n">reported_docs</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="n">seq_id</span> <span class="o">=</span> <span class="n">doc_results</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span>
					<span class="n">output_doc</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;ANALYSES&#39;</span><span class="p">:{}}</span><span class="c">#initialize outputdoc							</span>
					
					<span class="k">if</span> <span class="n">limit</span> <span class="ow">and</span> <span class="n">reported_docs</span><span class="o">==</span><span class="n">limit</span><span class="p">:</span>
						<span class="k">break</span>
				<span class="n">data</span> <span class="o">=</span> <span class="n">doc_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;DATA&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>	<span class="c">#remove data key	</span>
				<span class="n">doc_results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">doc_results</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">seqRawData</span><span class="p">:</span>					
					<span class="n">output_doc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">doc_results</span><span class="p">)</span> <span class="c">#ALL OF DOC INFORMATION FROM SEQUENCES/RAW DATA WILL APPEAR IN THIS DICTIONARY</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">doc_results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
					<span class="n">output_doc</span><span class="p">[</span><span class="s">&#39;ANALYSES&#39;</span><span class="p">][</span><span class="n">doc_results</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">doc_results</span>
					
			
			<span class="c">#OUTPUT the last result if there is still information:</span>
			<span class="k">if</span> <span class="n">output_doc</span> <span class="ow">and</span> <span class="n">output_doc</span><span class="o">!=</span><span class="p">{</span><span class="s">&#39;ANALYSES&#39;</span><span class="p">:{}}:</span>
				<span class="k">if</span> <span class="n">same_document</span><span class="p">:</span> <span class="c">#output all results to the same result/document							</span>
					<span class="k">yield</span> <span class="n">output_doc</span>
				<span class="k">else</span><span class="p">:</span> <span class="c">#split up results by annotation </span>
					<span class="n">sub_doc</span> <span class="o">=</span> <span class="n">output_doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;ANALYSES&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">sub_doc</span><span class="p">:</span> <span class="c">#NO annotation results found </span>
						<span class="k">for</span> <span class="n">analysis</span><span class="p">,</span><span class="n">each_doc</span> <span class="ow">in</span> <span class="n">sub_doc</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
							<span class="n">each_doc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">output_doc</span><span class="p">)</span>								
							<span class="k">yield</span> <span class="n">each_doc</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="k">yield</span> <span class="n">output_doc</span>								

			
					<span class="c">#output_doc[&#39;ANALYSES&#39;][doc_results[&#39;ANALYSIS_NAME&#39;]</span>

			
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">group_by_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>


	<span class="c">#this generator function will return teh RAW sequence data information for every doocument returned from the query </span>
	<span class="k">def</span> <span class="nf">get_rawseq_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">query_data</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">query_data</span><span class="p">:</span>
				<span class="k">if</span> <span class="s">&#39;ANALYSIS_NAME&#39;</span> <span class="ow">in</span> <span class="n">doc</span> <span class="ow">and</span> <span class="n">doc</span><span class="p">[</span><span class="s">&#39;ANALYSIS_NAME&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">seqRawData</span> <span class="ow">and</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
					<span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;_id&#39;</span><span class="p">:</span> <span class="n">doc</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]},</span> <span class="p">{</span><span class="s">&#39;DATA&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>  <span class="c"># {idIdentifier:doc[idIdentifier],&#39;ANALYSIS_NAME&#39;:seqRawData},{&#39;DATA&#39;:1})</span>
					<span class="k">if</span> <span class="s">&#39;DATA&#39;</span> <span class="ow">in</span> <span class="n">raw_data</span><span class="p">:</span>
						<span class="n">doc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s">&#39;DATA&#39;</span><span class="p">])</span>
						<span class="k">yield</span> <span class="n">doc</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="k">yield</span> <span class="n">doc</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">doc</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># This generator function will take a list of docs and yield them one by one</span>
	<span class="k">def</span> <span class="nf">list_to_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">def</span> <span class="nf">make_gen</span><span class="p">(</span><span class="n">query_data</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">query_data</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">doc</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="n">make_gen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="c"># #################RETURNING QUERIES AS A FILE FUNCTIONS ####################</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		The following functions are used when you want to save a query result to a file</span>
<span class="sd">		We have functions for saving results as :</span>
<span class="sd">			TAB, CSV, JSON, FLATJSON, FASTA, and FASTQ</span>
<span class="sd">			See the function allowed_file_types to see a description of each</span>

<span class="sd">		When running these functions the documents will be converted to strings and the cursor will be extinguished. Decided not to use itertools tee because it might have been an unnecessary use of memory.</span>
<span class="sd">	&#39;&#39;&#39;</span>

<div class="viewcode-block" id="RunQuery.save_as_delim"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_delim">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_delim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;txt&#39;</span><span class="p">,</span> <span class="n">header_var</span><span class="o">=</span><span class="p">[],</span> <span class="n">keep_all_info</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">avoid_commas_in_string_output</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query to a delimited file. Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			delimiter : character</span>
<span class="sd">				This defines what character should be used to delimit file</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			header_var : list of strings, dict, or list of tuples default = []</span>
<span class="sd">				This variable allows user to manually define exactly how they want fields to appear in the delimited file.</span>
<span class="sd">				When format is a list of strings: Fields will appear in order based on the list of strings. i.e. [&#39;SEQUENCE&#39;,&#39;SEQUENCE_HEADER&#39;]</span>
<span class="sd">				When format is a dict: Fields will be renamed based on key value pairs where key is field name and value is new field name. i.e. {&#39;SEQUENCE&#39;:&#39;raw read&#39;,&#39;SEQUENCE_HEADER&#39;:&#39;miseqread&#39;}</span>
<span class="sd">				When format is a list of tuples: Fields will appear in order based on list, and also be renamed based on (fieldname, new field name). i.e. [(&#39;SEQUENCE_HEADER&#39;,&#39;miseqread&#39;),(&#39;SEQUENCE&#39;,&#39;raw read&#39;)]</span>
<span class="sd">			keep_all_info : boolean, default = False</span>
<span class="sd">				This variable defines whether to report all results from a query/projection or only report those fields defined in the variable &#39;header_var&#39;.</span>
<span class="sd">				If False, then only those fields explicitly reported by &#39;header_var&#39; will appear in the file. If True, then all fields not included in &#39;header_var&#39; will</span>
<span class="sd">				appear afterwards in the order defined by &#39;default_sorting_order&#39;</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">			avoid_commas_in_string_output : boolean, default = False</span>
<span class="sd">				When set to True, this will try to avoid using commas to convert fields to strings. For examples, lists will not be saved as strings using &#39;,&#39;.join. Instead it will use &#39;|&#39;.join.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">to_file</span> <span class="o">=</span> <span class="bp">True</span>

		<span class="c"># This variable will define the order fields should appear in the delimited file</span>
		<span class="n">output_sorted_fields</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

		<span class="c"># LETS TRY AND GET THE ORDER OF THE COLUMNS CORRECT</span>
		<span class="c"># ACOUNT FOR USER REQUESTS, DEFAULT SORT ORDERS, AND FOUND FIELDS FROM QUERIES#</span>
		<span class="n">user_requested_fields</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="c"># First lets figure out what type of variable the user passed in as the header_var</span>
		<span class="k">if</span> <span class="n">header_var</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="n">header_var</span><span class="p">):</span>
			<span class="c"># User does not care about order of results, so we  will use the sorting order , we will also force keep_all_info to be true</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="n">default_sorting_order</span>
			<span class="n">keep_all_info</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="n">user_requested_fields</span> <span class="o">=</span> <span class="bp">False</span>
			<span class="n">header_type</span> <span class="o">=</span> <span class="s">&#39;list&#39;</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="c"># make it a list</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">header_var</span><span class="p">]</span>
			<span class="n">header_type</span> <span class="o">=</span> <span class="s">&#39;list&#39;</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="c"># user will be renaming the field names based on key-value pairs</span>
			<span class="n">header_type</span> <span class="o">=</span> <span class="s">&#39;dict&#39;</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="c"># It is either a list or a list of tuples</span>
			<span class="n">first_val</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">):</span>
				<span class="n">header_type</span> <span class="o">=</span> <span class="s">&#39;list&#39;</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">type</span><span class="p">((</span><span class="s">&#39;db_field&#39;</span><span class="p">,</span> <span class="s">&#39;new_field&#39;</span><span class="p">))):</span>
				<span class="n">header_type</span> <span class="o">=</span> <span class="s">&#39;tuple&#39;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The parameter, header_var, can only be a list of strings or tuples.&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">all_vals</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">all_vals</span><span class="p">,</span> <span class="n">first_val</span><span class="p">)):</span>
					<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The parameter, header_var, can only be a list of strings or list of tuples. It can not have multiple types within the list&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The parameter, header_var, can only be a string, list, tuples or dictionary of strings&#39;</span><span class="p">)</span>

		<span class="c"># Uppercase all field names in the in the outputfiles except for &#39;_id&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&#39;_id&#39;</span> <span class="k">else</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">]</span>

		<span class="n">append_id</span> <span class="o">=</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span> <span class="k">else</span> <span class="bp">False</span>

		<span class="c"># Based on the header_type (list , dict or tuples), determine how the order of fields should appear</span>
		<span class="k">if</span> <span class="n">header_type</span> <span class="o">==</span> <span class="s">&#39;list&#39;</span><span class="p">:</span>
			<span class="c"># user passed in a list defining the order to output fields. Because its a list, the NAMES of each field will not change</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">append_id</span> <span class="ow">and</span> <span class="n">idIdentifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
				<span class="n">header_var</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idIdentifier</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">user_requested_fields</span><span class="p">:</span>
				<span class="c"># So all fields in header_var will be output to file</span>
				<span class="k">for</span> <span class="n">fields_requested</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
					<span class="n">output_sorted_fields</span><span class="p">[</span><span class="n">fields_requested</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields_requested</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c"># If the user does not explicitely define which fields they want, then we will only output fields we know exist/were part of query</span>
				<span class="k">for</span> <span class="n">fields_requested</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">fields_requested</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">:</span>
						<span class="n">output_sorted_fields</span><span class="p">[</span><span class="n">fields_requested</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields_requested</span>

		<span class="k">elif</span> <span class="n">header_type</span> <span class="o">==</span> <span class="s">&#39;dict&#39;</span><span class="p">:</span>
			<span class="c"># User passed in a dict so they do not want to specify the order of the fields, but they do want to rename fieldnames</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">h</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span> <span class="n">nv</span> <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="s">&#39;_id&#39;</span> <span class="k">else</span> <span class="n">h</span> <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">nv</span> <span class="ow">in</span> <span class="n">header_var</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()}</span>
			<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header_var</span> <span class="ow">and</span> <span class="n">append_id</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
				<span class="n">header_var</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">idIdentifier</span>

			<span class="c"># Cannot control order of fields, so use the order defined in default_sorting_order</span>
			<span class="n">sub_dict</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="n">max_pos</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">new_requested_fields</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">each_requested_key</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">each_requested_key</span> <span class="ow">in</span> <span class="n">default_sorting_order</span><span class="p">:</span>
					<span class="n">sub_dict</span><span class="p">[</span><span class="n">each_requested_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_sorting_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">each_requested_key</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">new_requested_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">each_requested_key</span><span class="p">)</span>
			<span class="n">max_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sub_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">sub_dict</span> <span class="k">else</span> <span class="mi">0</span>
			<span class="c"># Any keys that were not found in our defualt variable get appended to dictionary</span>
			<span class="k">for</span> <span class="n">each_requested_key</span> <span class="ow">in</span> <span class="n">new_requested_fields</span><span class="p">:</span>
				<span class="n">sub_dict</span><span class="p">[</span><span class="n">each_requested_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_pos</span>
				<span class="n">max_pos</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="c"># Add in the keys sorted by their psostiion to the ordered dictionary</span>
			<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sub_dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)):</span>
				<span class="n">output_sorted_fields</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">header_var</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

		<span class="k">elif</span> <span class="n">header_type</span> <span class="o">==</span> <span class="s">&#39;tuple&#39;</span><span class="p">:</span>
			<span class="c"># User passed in a tuple so we can specify the order of the fields and rename fields based on user response</span>
			<span class="c"># for each tuple, element 0 =&gt; name of field in document, element 1 =&gt; what to rename the field to</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="p">[(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;_id&#39;</span> <span class="k">else</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">append_id</span><span class="p">:</span>
				<span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idIdentifier</span><span class="p">:</span>
						<span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
						<span class="k">break</span>
				<span class="k">if</span> <span class="n">found</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
					<span class="n">header_var</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">idIdentifier</span><span class="p">,</span> <span class="n">idIdentifier</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">fields_requested</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
				<span class="n">output_sorted_fields</span><span class="p">[</span><span class="n">fields_requested</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fields_requested</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

		<span class="c"># Field names desired by user have been defined; if keep_all_info is true then we need to go through the fields produced by the query</span>
		<span class="c"># If they are not currently found in output_sorted_fields, then add them to the fields to be output</span>
		<span class="k">if</span> <span class="n">keep_all_info</span><span class="p">:</span>
			<span class="n">sub_dict</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="n">new_requested_fields</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="c"># loop through fields generated by query</span>
			<span class="k">for</span> <span class="n">generated_fields</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delim_file_headers</span><span class="p">:</span>
				<span class="c"># This field is not currently defined in output_sorted_fields</span>
				<span class="k">if</span> <span class="n">generated_fields</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_sorted_fields</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">generated_fields</span> <span class="ow">in</span> <span class="n">default_sorting_order</span><span class="p">:</span>
						<span class="n">sub_dict</span><span class="p">[</span><span class="n">generated_fields</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_sorting_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">generated_fields</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">new_requested_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generated_fields</span><span class="p">)</span>
			<span class="n">max_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sub_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">sub_dict</span> <span class="k">else</span> <span class="mi">0</span>

			<span class="c"># Any keys that were not found yet gets appended to dictionary</span>
			<span class="k">for</span> <span class="n">each_requested_key</span> <span class="ow">in</span> <span class="n">new_requested_fields</span><span class="p">:</span>
				<span class="n">sub_dict</span><span class="p">[</span><span class="n">each_requested_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_pos</span>
				<span class="n">max_pos</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="c"># Add in the keys sorted by their psostiion to the ordered dictionary</span>
			<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sub_dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)):</span>
				<span class="n">output_sorted_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
		<span class="c"># The order of all fields to output to the file has now been determined</span>

		<span class="c"># The user did not define a prefix path</span>
		<span class="k">if</span> <span class="n">prefix_file_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_filename</span>
		<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">prefix_file_path</span><span class="p">)</span>

		<span class="c"># If the query is just a dict (i.e. comes from a find_one command)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>

		<span class="c"># NOW define a function to control how we will save results to a file</span>
		<span class="k">def</span> <span class="nf">generate_delim</span><span class="p">(</span><span class="n">query_results</span><span class="p">,</span> <span class="n">output_sorted_fields</span><span class="p">):</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				A function for actually parsing the cursor and saving as text.</span>
<span class="sd">				query_results represents a cursor from the mongodb query.</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="c"># First set the default header line for files in this section</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">add_header_row</span><span class="p">(</span><span class="n">output_sorted_fields</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">)</span>
			<span class="c"># Next if there are any files in the class, open them up</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">open_files</span><span class="p">()</span>
			<span class="n">current_counts</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">num_line_to_write_sim</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">keys_to_be_reported</span> <span class="o">=</span> <span class="n">output_sorted_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">avoid_commas_in_string_output</span><span class="p">:</span>
				<span class="n">schema_schema_output_fnc_for_delim</span> <span class="o">=</span> <span class="n">schema_fields_to_file_avoid_commas</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">schema_schema_output_fnc_for_delim</span> <span class="o">=</span> <span class="n">schema_fields_to_file</span>

			<span class="c"># Lets figure out how to split results into multiple files using fields from documents</span>
			<span class="n">split_results</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">if</span> <span class="n">save_by_filename</span><span class="p">:</span>
				<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;FILENAME&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">split_results_by</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">fields</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
					<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

			<span class="k">for</span> <span class="n">seq_document</span> <span class="ow">in</span> <span class="n">query_results</span><span class="p">:</span>
				<span class="n">current_counts</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">prefix_line</span> <span class="o">=</span> <span class="n">prefix_file_path</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
					<span class="c"># If its not a dict, then we just need to write results to a file</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># If it is a dict, then it should be a db document</span>
					<span class="c"># Process document: (1) Flatten dictionary, (2) cconvert all fields to strings</span>
					<span class="n">seq_document</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Process_Cursor_For_Output_File</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="n">schema_schema_output_fnc_for_delim</span><span class="p">))</span>
					<span class="n">added_prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="k">if</span> <span class="n">save_by_exp_name</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">seq_document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]][</span><span class="s">&#39;EXPERIMENT_NAME&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
					<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="n">seq_document</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;.&#39;</span>
					<span class="k">if</span> <span class="n">added_prefix</span><span class="p">:</span>
						<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;[ ,</span><span class="se">\\</span><span class="s">/]&quot;</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">added_prefix</span><span class="p">)</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">delimiter</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">seq_document</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_to_be_reported</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="k">if</span> <span class="n">current_counts</span> <span class="o">%</span> <span class="n">num_line_to_write_sim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="c"># First we need to see if query_results is an iterable</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
			<span class="c"># Just convert any single dicts/strings/numbers into lists</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>
		<span class="c"># Finally, save results to a file</span>
		<span class="n">generate_delim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="n">output_sorted_fields</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.save_as_tab"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_tab">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;txt&#39;</span><span class="p">,</span> <span class="n">header_var</span><span class="o">=</span><span class="p">[],</span> <span class="n">keep_all_info</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query to a TAB delimited file. Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			header_var : list of strings, dict, or list of tuples default = []</span>
<span class="sd">				This variable allows user to manually define exactly how they want fields to appear in the delimited file.</span>
<span class="sd">				When format is a list of strings: Fields will appear in order based on the list of strings. i.e. [&#39;SEQUENCE&#39;,&#39;SEQUENCE_HEADER&#39;]</span>
<span class="sd">				When format is a dict: Fields will be renamed based on key value pairs where key is field name and value is new field name. i.e. {&#39;SEQUENCE&#39;:&#39;raw read&#39;,&#39;SEQUENCE_HEADER&#39;:&#39;miseqread&#39;}</span>
<span class="sd">				When format is a list of tuples: Fields will appear in order based on list, and also be renamed based on (fieldname, new field name). i.e. [(&#39;SEQUENCE_HEADER&#39;,&#39;miseqread&#39;),(&#39;SEQUENCE&#39;,&#39;raw read&#39;)]</span>
<span class="sd">			keep_all_info : boolean, default = False</span>
<span class="sd">				This variable defines whether to report all results from a query/projection or only report those fields defined in the variable &#39;header_var&#39;.</span>
<span class="sd">				If False, then only those fields explicitly reported by &#39;header_var&#39; will appear in the file. If True, then all fields not included in &#39;header_var&#39; will</span>
<span class="sd">				appear afterwards in the order defined by &#39;default_sorting_order&#39;</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">save_as_delim</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="p">,</span> <span class="n">file_ext</span><span class="p">,</span> <span class="n">header_var</span><span class="p">,</span> <span class="n">keep_all_info</span><span class="p">,</span> <span class="n">split_results_by</span><span class="p">,</span> <span class="n">save_by_filename</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.save_as_csv"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_csv">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;txt&#39;</span><span class="p">,</span> <span class="n">header_var</span><span class="o">=</span><span class="p">[],</span> <span class="n">keep_all_info</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query to a CSV file. Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			header_var : list of strings, dict, or list of tuples default = []</span>
<span class="sd">				This variable allows user to manually define exactly how they want fields to appear in the delimited file.</span>
<span class="sd">				When format is a list of strings: Fields will appear in order based on the list of strings. i.e. [&#39;SEQUENCE&#39;,&#39;SEQUENCE_HEADER&#39;]</span>
<span class="sd">				When format is a dict: Fields will be renamed based on key value pairs where key is field name and value is new field name. i.e. {&#39;SEQUENCE&#39;:&#39;raw read&#39;,&#39;SEQUENCE_HEADER&#39;:&#39;miseqread&#39;}</span>
<span class="sd">				When format is a list of tuples: Fields will appear in order based on list, and also be renamed based on (fieldname, new field name). i.e. [(&#39;SEQUENCE_HEADER&#39;,&#39;miseqread&#39;),(&#39;SEQUENCE&#39;,&#39;raw read&#39;)]</span>
<span class="sd">			keep_all_info : boolean, default = False</span>
<span class="sd">				This variable defines whether to report all results from a query/projection or only report those fields defined in the variable &#39;header_var&#39;.</span>
<span class="sd">				If False, then only those fields explicitly reported by &#39;header_var&#39; will appear in the file. If True, then all fields not included in &#39;header_var&#39; will</span>
<span class="sd">				appear afterwards in the order defined by &#39;default_sorting_order&#39;</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">save_as_delim</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="p">,</span> <span class="n">file_ext</span><span class="p">,</span> <span class="n">header_var</span><span class="p">,</span> <span class="n">keep_all_info</span><span class="p">,</span> <span class="n">split_results_by</span><span class="p">,</span> <span class="n">save_by_filename</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="p">,</span> <span class="n">avoid_commas_in_string_output</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.save_as_flatjson"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_flatjson">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_flatjson</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;json&#39;</span><span class="p">,</span> <span class="n">convert_values_to_strings</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query to a FLAT JSON document</span>
<span class="sd">			Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			convert_values_to_strings : boolean, default=False</span>
<span class="sd">				When True, all values in from a document query will be converted to strings. For example fields contaning lists (i.e. VREGION.VGENES) will be come strings using &#39;,&#39;.join(list)</span>
<span class="sd">				When False, datatypes are maintained</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">to_file</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="c"># The user did not define a prefix path</span>
		<span class="k">if</span> <span class="n">prefix_file_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_filename</span>
		<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">prefix_file_path</span><span class="p">)</span>
		<span class="c"># JSON files do not have header rows</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">add_header_row</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

		<span class="c"># Lets figure out how to split results into multiple files using fields from documents</span>
		<span class="n">split_results</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">save_by_filename</span><span class="p">:</span>
			<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;FILENAME&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">split_results_by</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">fields</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
				<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

		<span class="k">def</span> <span class="nf">generate_flat</span><span class="p">(</span><span class="n">query_results</span><span class="p">):</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				A function for parsing the cursor and saving as text.</span>
<span class="sd">				query_results represents a cursor from the mongodb query.</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="n">num_line_to_write_sim</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">current_counts</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">seq_document</span> <span class="ow">in</span> <span class="n">query_results</span><span class="p">:</span>
				<span class="n">current_counts</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">prefix_line</span> <span class="o">=</span> <span class="n">prefix_file_path</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
					<span class="k">except</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">seq_document</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">convert_values_to_strings</span><span class="p">:</span>
						<span class="c"># Process document: (1) Flatten dictionary, (2) cconvert all fields to strings</span>
						<span class="n">seq_document</span> <span class="o">=</span> <span class="n">Process_Cursor_For_Output_File</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="n">schema_fields_to_file</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="c"># Flatten dictionary only, convert object id&#39;s to strings</span>
						<span class="n">seq_document</span> <span class="o">=</span> <span class="n">flatten_dictionary</span><span class="p">(</span><span class="n">Simple_Process_Output</span><span class="p">(</span><span class="n">seq_document</span><span class="p">))</span>
					<span class="n">added_prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="k">if</span> <span class="n">save_by_exp_name</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">seq_document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]][</span><span class="s">&#39;EXPERIMENT_NAME&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
					<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="n">seq_document</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;.&#39;</span>
					<span class="k">if</span> <span class="n">added_prefix</span><span class="p">:</span>
						<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;[ ,</span><span class="se">\\</span><span class="s">/]&quot;</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">added_prefix</span><span class="p">)</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="k">if</span> <span class="n">current_counts</span> <span class="o">%</span> <span class="n">num_line_to_write_sim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="c"># First we need to see if query_results is an iterable</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
			<span class="c"># Just convert any single dicts/strings/numbers into lists</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>
		<span class="c"># Finally, save results to a file</span>
		<span class="n">generate_flat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.save_as_json"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_json">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;json&#39;</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query as JSON. JSON dumps on all documents.</span>
<span class="sd">			Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			.. note::</span>
<span class="sd">				Because dumps using json is faster than dumps using bson, all ObjectId values will be converted to a string</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">to_file</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="c"># The user did not define a prefix path</span>
		<span class="k">if</span> <span class="n">prefix_file_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_filename</span>
		<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">prefix_file_path</span><span class="p">)</span>
		<span class="c"># JSON files do not have header rows</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">add_header_row</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

		<span class="c"># Lets figure out how to split results into multiple files using fields from documents</span>
		<span class="n">split_results</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">save_by_filename</span><span class="p">:</span>
			<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;FILENAME&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">split_results_by</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">fields</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
				<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

		<span class="k">def</span> <span class="nf">generate_jsons</span><span class="p">(</span><span class="n">query_results</span><span class="p">):</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				A function for parsing the cursor and saving as text.</span>
<span class="sd">				query_results represents a cursor from the mongodb query.</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="n">num_line_to_write_sim</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">current_counts</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">seq_document</span> <span class="ow">in</span> <span class="n">query_results</span><span class="p">:</span>
				<span class="n">current_counts</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">prefix_line</span> <span class="o">=</span> <span class="n">prefix_file_path</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
					<span class="k">except</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">seq_document</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">seq_document</span> <span class="o">=</span> <span class="n">Simple_Process_Output</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
					<span class="n">added_prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="k">if</span> <span class="n">save_by_exp_name</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">seq_document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]][</span><span class="s">&#39;EXPERIMENT_NAME&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
					<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="n">seq_document</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;.&#39;</span>
					<span class="k">if</span> <span class="n">added_prefix</span><span class="p">:</span>
						<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;[ ,</span><span class="se">\\</span><span class="s">/]&quot;</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">added_prefix</span><span class="p">)</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="k">if</span> <span class="n">current_counts</span> <span class="o">%</span> <span class="n">num_line_to_write_sim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="c"># First we need to see if query_results is an iterable</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
			<span class="c"># Just convert any single dicts/strings/numbers into lists</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>
		<span class="c"># Finally, save results to a file</span>
		<span class="n">generate_jsons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.save_as_fasta"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_fasta">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;fasta&#39;</span><span class="p">,</span> <span class="n">sequence_key</span><span class="o">=</span><span class="s">&#39;SEQUENCE&#39;</span><span class="p">,</span> <span class="n">header_var</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;SEQUENCE_HEADER&#39;</span><span class="p">],</span> <span class="n">keep_all_info</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_header_row</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query to a FASTA file</span>
<span class="sd">			Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			sequence_key : string, default = &#39;SEQUENCE&#39;</span>
<span class="sd">				This field will be used as the sequence for a fasta file (i.e. &gt;header\nsequence)</span>
<span class="sd">			header_var : list of strings, default = [&#39;SEQUENCE_HEADER&#39;]</span>
<span class="sd">				These fields will be used to form the sequence header for a faster file. All fields in this list will be seperated by | (i.e. &gt;header field 1 | header field 2 | header field 3\nsequence)</span>
<span class="sd">			keep_all_info : boolean, default = False</span>
<span class="sd">				When True then all other fields not explicity defined in &#39;header_var&#39; will be exported in json format to the sequence header (i.e. &gt;header field 1 &lt;{field 2: value, field 3: value}\nsequence)</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">			include_header_row : boolean, default = True</span>
<span class="sd">				When true, a header row, prepended by &#39;#&#39;, is output to the top of each created file. All field names defined by header_var are reported in this line</span>

<span class="sd">			.. note::</span>
<span class="sd">				The field corresponding to the sequencey_key will always be removed from the header_var variable</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">header_var</span><span class="p">):</span>
			<span class="c"># Just use a JSON document to dump results to sequence header; it won&#39;t look pretty but user didnt define a value to use a sequence header and changed default value</span>
			<span class="n">keep_all_info</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">header_var</span><span class="p">]</span>

		<span class="n">temp_header_var</span> <span class="o">=</span> <span class="n">header_var</span>
		<span class="n">header_var</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">each_field</span> <span class="ow">in</span> <span class="n">temp_header_var</span><span class="p">:</span>
			<span class="c"># Always make sure fields do not start with &#39;DATA.&#39; (we are removing in them during the function Process_Cursor...)</span>
			<span class="k">if</span> <span class="n">each_field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA.&#39;</span><span class="p">):</span>
				<span class="n">each_field</span> <span class="o">=</span> <span class="n">each_field</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
			<span class="k">if</span> <span class="n">each_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
				<span class="n">header_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">each_field</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
		<span class="c"># Always remove sequence key from header_var. It shouldnt appear in header.</span>
		<span class="k">if</span> <span class="n">sequence_key</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
			<span class="n">header_var</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sequence_key</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">to_file</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="c"># The user did not define a prefix path</span>
		<span class="k">if</span> <span class="n">prefix_file_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_filename</span>
		<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">prefix_file_path</span><span class="p">)</span>
		<span class="c"># JSON files do not have header rows</span>
		<span class="k">if</span> <span class="n">include_header_row</span><span class="p">:</span>
			<span class="n">show_header_var</span> <span class="o">=</span> <span class="n">header_var</span>
			<span class="n">show_header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;#&#39;</span> <span class="o">+</span> <span class="n">show_header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">add_header_row</span><span class="p">(</span><span class="n">show_header_var</span><span class="p">,</span> <span class="s">&#39;|&#39;</span><span class="p">)</span>

		<span class="c"># Lets figure out how to split results into multiple files using fields from documents</span>
		<span class="n">split_results</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">save_by_filename</span><span class="p">:</span>
			<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;FILENAME&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">split_results_by</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">fields</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
				<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

		<span class="k">def</span> <span class="nf">generate_fasta</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				A function for parsing the cursor and saving as FASTA text.</span>
<span class="sd">				query_results represents a cursor from the mongodb query.</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="n">current_counts</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">num_line_to_write_sim</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">for</span> <span class="n">seq_document</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
				<span class="n">current_counts</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">prefix_line</span> <span class="o">=</span> <span class="n">prefix_file_path</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
					<span class="c"># We really wouldnt like to export these fields as fasta, but just for edge edge case scenarios</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;&gt;Unexpected FASTA format</span><span class="se">\n</span><span class="s">{0}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">seq_document</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># Process document: (1) Flatten dictionary, (2) cconvert all fields to strings</span>
					<span class="n">seq_document</span> <span class="o">=</span> <span class="n">Process_Cursor_For_Output_File</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="n">schema_fields_to_file</span><span class="p">)</span>
					<span class="n">added_prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="k">if</span> <span class="n">save_by_exp_name</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">seq_document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]][</span><span class="s">&#39;EXPERIMENT_NAME&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
					<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="n">seq_document</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;.&#39;</span>
					<span class="k">if</span> <span class="n">added_prefix</span><span class="p">:</span>
						<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;[ ,</span><span class="se">\\</span><span class="s">/]&quot;</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">added_prefix</span><span class="p">)</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="c"># We always want exp_id and seq_id to appear in the header of fasta file, but they will appear as part of json doc</span>
						<span class="n">seq_id</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idIdentifier</span><span class="p">)</span>
						<span class="n">added_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">idIdentifier</span><span class="p">:</span> <span class="n">seq_id</span><span class="p">}</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">added_data</span> <span class="o">=</span> <span class="p">{}</span>
					<span class="c"># header = seq_document.pop(header_key) if header_key in seq_document else seq_id</span>
					<span class="n">seq_val</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">sequence_key</span><span class="p">)</span> <span class="k">if</span> <span class="n">sequence_key</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>  <span class="c"># check to see whether this document has a sequence field defined by sequence_key</span>
					<span class="c"># Generate sequence header use fields defined in header_var</span>
					<span class="n">header_str</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
					<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_var</span><span class="p">)):</span>
						<span class="n">header_str</span> <span class="o">+=</span> <span class="s">&#39;|&#39;</span> <span class="o">+</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="k">if</span> <span class="n">header_var</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;|&#39;</span>
					<span class="k">if</span> <span class="n">keep_all_info</span><span class="p">:</span>
						<span class="c"># When True, any fields not explicitly defined in header_var will be shown as a json string in header</span>
						<span class="n">added_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span>
					<span class="n">descriptor_str</span> <span class="o">=</span> <span class="n">header_str</span> <span class="o">+</span> <span class="n">fasta_file_delimiter</span> <span class="o">+</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">added_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">added_data</span> <span class="k">else</span> <span class="n">header_str</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;&gt;{0}</span><span class="se">\n</span><span class="s">{1}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">descriptor_str</span><span class="p">,</span> <span class="n">seq_val</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">current_counts</span> <span class="o">%</span> <span class="n">num_line_to_write_sim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="c"># Make sure we can iterate through entire document results (that is if any of the queries are NOT cursors, then make them lists)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>
		<span class="n">generate_fasta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RunQuery.save_as_fastq"><a class="viewcode-back" href="../ABDatabase.html#immunogrep_db_query_api.RunQuery.save_as_fastq">[docs]</a>	<span class="k">def</span> <span class="nf">save_as_fastq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_file_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_ext</span><span class="o">=</span><span class="s">&#39;fastq&#39;</span><span class="p">,</span> <span class="n">sequence_key</span><span class="o">=</span><span class="s">&#39;SEQUENCE&#39;</span><span class="p">,</span> <span class="n">header_var</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;SEQUENCE_HEADER&#39;</span><span class="p">],</span> <span class="n">keep_all_info</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">split_results_by</span><span class="o">=</span><span class="p">[],</span> <span class="n">save_by_exp_name</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_by_filename</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_header_row</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">null_quality</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Exports the results of a query to a FASTQ file</span>
<span class="sd">			Once this function is called, the query cursor will be exhausted.</span>

<span class="sd">			Parameters</span>
<span class="sd">			----------</span>
<span class="sd">			prefix_file_path : string , default=None</span>
<span class="sd">				All exported files will start with this path. The prefix should also include parent folder paths (i.e scratch/query/myquery)</span>
<span class="sd">				If None, then function will default prefix as, &#39;current folder/&#39;+default_query_name</span>
<span class="sd">			file_ext : string, default=&#39;txt&#39;</span>
<span class="sd">				Save files using this extension</span>
<span class="sd">			sequence_key : string, default = &#39;SEQUENCE&#39;</span>
<span class="sd">				This field will be used as the sequence for a fasta file (i.e. &gt;header\nsequence)</span>
<span class="sd">			header_var : list of strings, default = [&#39;SEQUENCE_HEADER&#39;]</span>
<span class="sd">				These fields will be used to form the sequence header for a faster file. All fields in this list will be seperated by | (i.e. &gt;header field 1 | header field 2 | header field 3\nsequence)</span>
<span class="sd">			keep_all_info : boolean, default = False</span>
<span class="sd">				When True then all other fields not explicity defined in &#39;header_var&#39; will be exported in json format to the sequence header (i.e. &gt;header field 1 &lt;{field 2: value, field 3: value}\nsequence)</span>
<span class="sd">			split_results_by : list of strings, default = []</span>
<span class="sd">				This variable defines how to seperate results into multiple files by specific field names. For example, if you wanted each file to only include sequences with</span>
<span class="sd">				a unique CDR3 AA sequence, you would set split_results_by = [&#39;CDR3.AA&#39;]. In this sitation, each new CDR3 instance would create a new file with the path: filepath+&#39;.&#39;+cdr3_name</span>
<span class="sd">			save_by_filename : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on the original filename of the sequences uploaded to the database. For example, if R1/R2 files from MIseq were uploaded, this</span>
<span class="sd">				function will seperate sequences based on either R1/R2 file location.</span>
<span class="sd">			save_by_exp_name : boolean, default = False</span>
<span class="sd">				When true, results are seperated into different files based on their respective experiment name</span>
<span class="sd">			include_header_row : boolean, default = False</span>
<span class="sd">				When true, a header row, prepended by &#39;#&#39;, is output to the top of each created file. All field names defined by header_var are reported in this line</span>
<span class="sd">			null_quality : char or integer, default = 40</span>
<span class="sd">				This is used for documents that do not have fields for the sequence quality score.</span>
<span class="sd">				For example if sequences from a FASTA file were inserted into the database, then they have no quality information. So when saving these sequences as a FASTQ file,</span>
<span class="sd">				we will use this null_quality value as the default value of quality for each base. i.e. when null_quality is 40, the quality information wil be &#39;)&#39; for each sequence. (&#39;@ACTGG&#39; will be have quality &#39;)))))&#39;)</span>

<span class="sd">			.. note::</span>
<span class="sd">				The field corresponding to the sequencey_key and the &#39;QUALITY_SCORE&#39; field will always be removed from the header_var variable</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">min_valid_quality_scores</span> <span class="o">=</span> <span class="mi">33</span>
		<span class="n">max_valid_quality_score</span> <span class="o">=</span> <span class="mi">126</span>
		<span class="n">default_quality_score</span> <span class="o">=</span> <span class="mi">40</span>
		<span class="k">if</span> <span class="n">null_quality</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">null_quality</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">null_quality</span> <span class="o">&lt;</span> <span class="n">min_valid_quality_scores</span> <span class="ow">or</span> <span class="n">null_quality</span> <span class="o">&gt;</span> <span class="n">max_valid_quality_score</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Default quality score must be between: {0} and {1} &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">min_valid_quality_scores</span><span class="p">,</span> <span class="n">max_valid_quality_score</span><span class="p">)))</span>
				<span class="n">default_char</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">null_quality</span><span class="p">)</span>
			<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">null_quality</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">null_quality</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">unicode</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">null_quality</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">ascii</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">null_quality</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">ascii</span> <span class="o">&lt;</span> <span class="n">min_valid_quality_scores</span> <span class="ow">or</span> <span class="n">ascii</span> <span class="o">&gt;</span> <span class="n">max_valid_quality_score</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Default quality score must be between: {0} and {1}. Parameter passed was an ascii value of {2}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">min_valid_quality_scores</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_valid_quality_score</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">ascii</span><span class="p">)))</span>
				<span class="n">default_char</span> <span class="o">=</span> <span class="n">null_quality</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Invalid ascii value passed to null_quality parameter&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">default_char</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">default_quality_score</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">header_var</span><span class="p">):</span>
			<span class="c"># Just use a JSON document to dump results to sequence header; it won&#39;t look pretty but user didnt define a value to use a sequence header and changed default value</span>
			<span class="n">keep_all_info</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_var</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">header_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">header_var</span><span class="p">]</span>
		<span class="n">temp_header_var</span> <span class="o">=</span> <span class="n">header_var</span>
		<span class="n">header_var</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">each_field</span> <span class="ow">in</span> <span class="n">temp_header_var</span><span class="p">:</span>
			<span class="c"># Always make sure fields do not start with &#39;DATA.&#39; (we are removing in them during the function Process_Cursor...)</span>
			<span class="k">if</span> <span class="n">each_field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;DATA.&#39;</span><span class="p">):</span>
				<span class="n">each_field</span> <span class="o">=</span> <span class="n">each_field</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
			<span class="k">if</span> <span class="n">each_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
				<span class="n">header_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">each_field</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
		<span class="c"># Always remove sequence key from header_var. It shouldnt appear in header.</span>
		<span class="k">if</span> <span class="n">sequence_key</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
			<span class="n">header_var</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sequence_key</span><span class="p">)</span>
		<span class="c"># Always remove quality score</span>
		<span class="k">if</span> <span class="s">&#39;QUALITY_SCORE&#39;</span> <span class="ow">in</span> <span class="n">header_var</span><span class="p">:</span>
			<span class="n">header_var</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;QUALITY_SCORE&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">to_file</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="c"># The user did not define a prefix path</span>
		<span class="k">if</span> <span class="n">prefix_file_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_filename</span>
		<span class="n">prefix_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">prefix_file_path</span><span class="p">)</span>
		<span class="c"># JSON files do not have header rows</span>
		<span class="k">if</span> <span class="n">include_header_row</span><span class="p">:</span>
			<span class="n">show_header_var</span> <span class="o">=</span> <span class="n">header_var</span>
			<span class="n">show_header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;#&#39;</span> <span class="o">+</span> <span class="n">show_header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">add_header_row</span><span class="p">(</span><span class="n">show_header_var</span><span class="p">,</span> <span class="s">&#39;|&#39;</span><span class="p">)</span>

		<span class="c"># Lets figure out how to split results into multiple files using fields from documents</span>
		<span class="n">split_results</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">save_by_filename</span><span class="p">:</span>
			<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;FILENAME&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">split_results_by</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">fields</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
				<span class="n">split_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

		<span class="k">def</span> <span class="nf">generate_fastq</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">to_file</span><span class="p">,</span> <span class="n">split_results_by</span><span class="p">):</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				A function for parsing the cursor and saving as FASTQ text.</span>
<span class="sd">				query_results represents a cursor from the mongodb query.</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="n">default_char_str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">default_char</span><span class="p">]</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
			<span class="n">char_str_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_char_str</span><span class="p">)</span>
			<span class="n">current_counts</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">num_line_to_write_sim</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">for</span> <span class="n">seq_document</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
				<span class="n">current_counts</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">prefix_line</span> <span class="o">=</span> <span class="n">prefix_file_path</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
					<span class="c"># We really wouldnt like to export these fields as fasta, but just for edge edge case scenarios</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;@Unexpected FASTQ format</span><span class="se">\n</span><span class="s">{0}</span><span class="se">\n</span><span class="s">+</span><span class="se">\n</span><span class="s">{1}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">seq_document</span><span class="p">),</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">default_char</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">seq_document</span><span class="p">))))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c"># Process document: (1) Flatten dictionary, (2) cconvert all fields to strings</span>
					<span class="n">seq_document</span> <span class="o">=</span> <span class="n">Process_Cursor_For_Output_File</span><span class="p">(</span><span class="n">seq_document</span><span class="p">,</span> <span class="n">schema_fields_to_file</span><span class="p">)</span>
					<span class="n">added_prefix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="k">if</span> <span class="n">save_by_exp_name</span> <span class="ow">and</span> <span class="n">expIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_metadata</span><span class="p">[</span><span class="n">seq_document</span><span class="p">[</span><span class="n">expIdentifier</span><span class="p">]][</span><span class="s">&#39;EXPERIMENT_NAME&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
					<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
						<span class="n">added_prefix</span> <span class="o">+=</span> <span class="n">seq_document</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;.&#39;</span>
					<span class="k">if</span> <span class="n">added_prefix</span><span class="p">:</span>
						<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;[ ,</span><span class="se">\\</span><span class="s">/]&quot;</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">added_prefix</span><span class="p">)</span>
					<span class="n">prefix_line</span> <span class="o">+=</span> <span class="n">file_ext</span>
					<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="c"># We always want exp_id and seq_id to appear in the header of fasta file, but they will appear as part of json doc</span>
						<span class="n">seq_id</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idIdentifier</span><span class="p">)</span>
						<span class="n">added_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">idIdentifier</span><span class="p">:</span> <span class="n">seq_id</span><span class="p">}</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">added_data</span> <span class="o">=</span> <span class="p">{}</span>
					<span class="n">seq_val</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">sequence_key</span><span class="p">)</span> <span class="k">if</span> <span class="n">sequence_key</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>  <span class="c"># check to see whether this document has a sequence field defined by sequence_key</span>
					<span class="k">if</span> <span class="s">&#39;QUALITY_SCORE&#39;</span> <span class="ow">in</span> <span class="n">seq_document</span><span class="p">:</span>
						<span class="n">quality_score</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;QUALITY_SCORE&#39;</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">char_str_len</span><span class="p">:</span>
							<span class="n">default_char_str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">default_char</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_val</span><span class="p">))</span>
							<span class="n">char_str_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_val</span><span class="p">)</span>
							<span class="n">quality_score</span> <span class="o">=</span> <span class="n">default_char_str</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="n">quality_score</span> <span class="o">=</span> <span class="n">default_char_str</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_val</span><span class="p">)]</span>
					<span class="c"># Generate sequence header use fields defined in header_var</span>
					<span class="n">header_str</span> <span class="o">=</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">header_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
					<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_var</span><span class="p">)):</span>
						<span class="n">header_str</span> <span class="o">+=</span> <span class="s">&#39;|&#39;</span> <span class="o">+</span> <span class="n">seq_document</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">header_var</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="k">if</span> <span class="n">header_var</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seq_document</span> <span class="k">else</span> <span class="s">&#39;|&#39;</span>
					<span class="k">if</span> <span class="n">keep_all_info</span><span class="p">:</span>
						<span class="c"># When True, any fields not explicitly defined in header_var will be shown as a json string in header</span>
						<span class="n">added_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">seq_document</span><span class="p">)</span>
					<span class="n">descriptor_str</span> <span class="o">=</span> <span class="n">header_str</span> <span class="o">+</span> <span class="n">fasta_file_delimiter</span> <span class="o">+</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">added_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">added_data</span> <span class="k">else</span> <span class="n">header_str</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;doc_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="p">[</span><span class="n">prefix_line</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;@{0}</span><span class="se">\n</span><span class="s">{1}</span><span class="se">\n</span><span class="s">+</span><span class="se">\n</span><span class="s">{2}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">descriptor_str</span><span class="p">,</span> <span class="n">seq_val</span><span class="p">,</span> <span class="n">quality_score</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">current_counts</span> <span class="o">%</span> <span class="n">num_line_to_write_sim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">files_created</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="bp">None</span>

		<span class="c"># Make sure we can iterate through entire document results (that is if any of the queries are NOT cursors, then make them lists)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">query_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">]</span>
		<span class="n">generate_fastq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_file</span><span class="p">,</span> <span class="n">split_results_by</span><span class="p">)</span>

</div></div>
<span class="k">class</span> <span class="nc">Write_Files</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Make a special class for handling dicts of file buffers.</span>
<span class="sd">		This will define a default dict to allow opening files not yet created</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="nf">add_header_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header_row</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Define what should be the header_row for a file</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_row</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">header_row</span> <span class="o">=</span> <span class="n">delim</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header_row</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_row</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">header_row</span> <span class="o">=</span> <span class="n">header_row</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_row</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">header_row</span> <span class="o">=</span> <span class="n">delim</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header_row</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">header_row</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; has an unknown structure&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Create a default dict definition. If a string is not present in the dictionary, then add it to dict and create a new file</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_row</span><span class="p">:</span>
				<span class="n">temp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_row</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">header_row</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		<span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;buffer&#39;</span><span class="p">:</span> <span class="n">temp</span><span class="p">,</span> <span class="s">&#39;doc_count&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;lines&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">}</span>
		<span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">get_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="p">[{</span><span class="s">&#39;filepath&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;doc_count&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]}</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Write all data to file</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">])</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;lines&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

	<span class="k">def</span> <span class="nf">close_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Close all open files</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">open_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Open all files. Use append to avoid overwriting</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">IGREP 1.0.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Costas.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>