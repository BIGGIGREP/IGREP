

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>immunogrep_gglab_pairing &mdash; IGREP 1.0.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="IGREP 1.0.0 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> IGREP</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../Variables.html">Global Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Variables.html#list-of-variables">List of variables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Functions.html">Useful Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Functions.html#contents">Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Functions.html#insidefunc">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../IGfile.html">Immunogrepfile</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../IGfile.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../IGfile.html#module-immunogrep_read_file">Header Extraction Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../IGfile.html#immunogrep-classes">Immunogrep Classes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../VHVLPairing.html">VH-VL Pairing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../VHVLPairing.html#contents">Contents</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">IGREP</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>immunogrep_gglab_pairing</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for immunogrep_gglab_pairing</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">generic_dna</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">sys</span> 
<span class="kn">import</span> <span class="nn">math</span>

<span class="c">#for making folders in igrep</span>
<span class="kn">import</span> <span class="nn">immunogrep_file_system_tools</span> <span class="kn">as</span> <span class="nn">filesystem</span>
<span class="c">#for reading files</span>
<span class="kn">import</span> <span class="nn">immunogrep_read_file</span> <span class="kn">as</span> <span class="nn">readfile</span> 

<span class="c">#default dictionaries</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="c">#for printing pretty</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">translation_var</span> <span class="c">#this key will signify the translation/translator key </span>
<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">descriptor_symbol</span> <span class="c">#this key will signify the translation/translator key </span>
<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">idIdentifier</span> <span class="c">#variable defining what SEQ_ID variable is in database </span>
<span class="kn">from</span> <span class="nn">immunogrep_global_variables</span> <span class="kn">import</span> <span class="n">fasta_file_delimiter</span>
<span class="c">#import immunogrep_useful_immunogrep_functions as useful</span>
<span class="kn">import</span> <span class="nn">immunogrep_useful_functions</span> <span class="kn">as</span> <span class="nn">useful</span>

<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="c">#VERSION 4.0 applied on Version 7</span>
<span class="n">pairing_version</span> <span class="o">=</span> <span class="s">&#39;Pairing_v4.1&#39;</span>
<span class="c">#updates =&gt; allow isotyping </span>
	<span class="c">#=&gt; store SHM as mean SHM and variance </span>
	<span class="c">#=&gt; allow diversity calculations </span>
<span class="c">#updates 4.0 =&gt; produce a pairing &#39;annotation&#39; file </span>
	<span class="c">#the annotation file will store the &#39;paired-id&#39; of successful pairs , and their corresponding &#39;paired cluster id&#39;</span>
<span class="c">#updates 4.1 =&gt; </span>
	<span class="c">#use &#39;MODE&#39; for VGENE usage call:</span>
		<span class="c">#ONLY CONSIDER VGENES WHOSE SCORES ARE EQUAL TO THE TOP SCORE!!!</span>
		<span class="c">#RULE/ASSUMPTION: IF THERE IS NOT VGENE SCORE FIELD OR THE VGENE SCORE FIELD LENGTH != THE LENGHT OF VGENES THEN ONLY CONSIDER ALL VGENES PROVIDED</span>
	<span class="c">#we will no longer filter out sequences whose full length nt or aa field are empty </span>
	<span class="c">#add a new productivity rule =&gt; productive if there is no stop codon in the CDR3 sequence ONLY. This will become the default productivity rule  </span>
	

<div class="viewcode-block" id="get_ab_field_loc"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.get_ab_field_loc">[docs]</a><span class="k">def</span> <span class="nf">get_ab_field_loc</span><span class="p">():</span>
	<span class="c">#structure of array in codeDict and collapsedict </span>
	<span class="c">#every R1-R2 read (that passes filters) will be stored as an array in the variable codeDict</span>
	<span class="c">#ONLY the first occurrence of H or L data from a pair will be stored in codeDict. </span>
	<span class="c">#the location of each data stored for either the heavy or light chain will be mapped by the following variable</span>
	<span class="c">#for example, lets if the Heavy chain is encountered first. It will be stored in codeDict as an array based on the indexes below. </span>
				 <span class="c">#the moment its Light chain pair is encountered, then the heavy chain data will be removed from the codeDict var and </span>
				 <span class="c">#both heavy and light chain data will be stored in collapsed_dict as a 2-D array where index 0 is heavy chain and index 1 is light chain . The third element of collapsed dict stores counts</span>
				 <span class="c">#-&gt; collapsedict[fullcode] = [heavy chain data array/list, light chain data array/list, COUNTS!!]			 </span>

	<span class="n">ab_field_loc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&#39;CDR3_SEQ&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c">#store the cdr3 sequence in the first element of the array </span>
		<span class="s">&#39;VGENE&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
		<span class="s">&#39;DGENE&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
		<span class="s">&#39;JGENE&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
		<span class="s">&#39;LOCUS&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
		<span class="s">&#39;MUT&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
		<span class="s">&#39;CDR3_LEN&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span>
		<span class="s">&#39;AB_SEQ&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span>
		<span class="s">&#39;CHAIN_CALL&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span>
		<span class="s">&#39;ISOTYPE&#39;</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span>
		<span class="s">&#39;VSCORES&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
		<span class="s">&#39;JSCORES&#39;</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span>
		<span class="s">&#39;DSCORES&#39;</span><span class="p">:</span><span class="mi">12</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ab_field_loc</span>
</div>
<div class="viewcode-block" id="get_required_field_names"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.get_required_field_names">[docs]</a><span class="k">def</span> <span class="nf">get_required_field_names</span><span class="p">():</span>
	<span class="n">required_field_names</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&#39;vgene&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;cdr3_nt&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;seq_header&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;shm&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;functionality&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;recomb&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span>
		<span class="p">}</span>		
	<span class="k">return</span> <span class="n">required_field_names</span>

<span class="c">#the array for each heavy/light chain will always be this long</span></div>
<span class="n">num_elem_stored</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">get_ab_field_loc</span><span class="p">()</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span><span class="o">+</span><span class="mi">1</span>  
<span class="n">allowed_file_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;TAB&#39;</span><span class="p">,</span><span class="s">&#39;CSV&#39;</span><span class="p">,</span><span class="s">&#39;JSON&#39;</span><span class="p">,</span><span class="s">&#39;IMGT&#39;</span><span class="p">]</span>

<span class="c">#We will need to update the database with the results from IgFFT.  In order</span>
<span class="c">#to update teh database, we need a translator, so that we know what fields go where in the database</span>
<div class="viewcode-block" id="DatabaseTranslator"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.DatabaseTranslator">[docs]</a><span class="k">def</span> <span class="nf">DatabaseTranslator</span><span class="p">(</span><span class="n">input_dictionary</span> <span class="o">=</span> <span class="p">{}):</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">translation_var</span>
	
	<span class="n">translator</span> <span class="o">=</span> <span class="p">{</span>								
			<span class="s">&quot;RECOMBINATION_FIELD&quot;</span><span class="p">:{</span> <span class="c">#THIS TELLS THE PROGRAM HOW TO DETERMINE WHETHER AN ANALYSIS/QUERY RESULT (from file) IS VDJ OR VJ</span>
					<span class="s">&quot;FIELD_NAME&quot;</span><span class="p">:</span> <span class="s">&quot;Recombination Type&quot;</span><span class="p">,</span> <span class="c">#name of the field in the file that will give information regarding the recombination type (VDJ OR VJ)					</span>
					<span class="s">&quot;EXPLICIT&quot;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="s">&quot;FIELDS_UPDATE&quot;</span><span class="p">:{</span> 
				<span class="c">#key = field name  in database </span>
				<span class="c">#value = field name in file</span>
				<span class="c">#this will map all of the fields in the file to the proper location in the database. I.E. If I list VGENES as the column name/field name, then i want to map VREGION.VGENES:VGENES (because VREGION.VGENES is the name in the database)							</span>
				<span class="n">idIdentifier</span><span class="p">:</span><span class="n">idIdentifier</span><span class="p">,</span>
				<span class="s">&quot;SEQUENCE&quot;</span><span class="p">:</span><span class="s">&quot;Sequence&quot;</span><span class="p">,</span>				
				<span class="s">&quot;SEQUENCE_HEADER&quot;</span><span class="p">:</span><span class="s">&quot;Header&quot;</span><span class="p">,</span>								
				<span class="s">&quot;PAIRING.PAIRED_ID&quot;</span><span class="p">:</span><span class="s">&#39;PairedID&#39;</span><span class="p">,</span>
				<span class="s">&quot;PAIRING.PAIRED_CLUSTER&quot;</span><span class="p">:</span><span class="s">&#39;PairedClusterId&#39;</span><span class="p">,</span>
				<span class="s">&quot;PAIRING.CONFIDENCE&quot;</span><span class="p">:</span><span class="s">&#39;Confidence&#39;</span><span class="p">,</span>
				<span class="s">&quot;PAIRING.DOMINANCE&quot;</span><span class="p">:</span><span class="s">&#39;Dominance&#39;</span><span class="p">,</span>
				<span class="s">&#39;COMMAND&#39;</span><span class="p">:</span><span class="s">&#39;Command&#39;</span>
			<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">input_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">translator</span>		
	
	<span class="k">return</span> <span class="n">input_dictionary</span>
</div>
<div class="viewcode-block" id="FloatRange"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.FloatRange">[docs]</a><span class="k">def</span> <span class="nf">FloatRange</span><span class="p">(</span><span class="n">minv</span><span class="p">,</span><span class="n">maxv</span><span class="p">,</span><span class="n">step</span><span class="p">,</span><span class="n">num_dec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">step</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
		<span class="n">step</span> <span class="o">=</span><span class="mf">0.01</span>
	<span class="n">minv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="n">minv</span><span class="p">))</span>
	<span class="n">maxv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="n">maxv</span><span class="p">))</span>
	
	<span class="n">x</span> <span class="o">=</span> <span class="n">minv</span>
	<span class="k">if</span> <span class="n">maxv</span><span class="o">&lt;</span><span class="n">minv</span><span class="p">:</span>
		<span class="n">min2</span><span class="o">=</span><span class="n">minv</span>
		<span class="n">minv</span><span class="o">=</span><span class="n">maxv</span>
		<span class="n">maxv</span><span class="o">=</span><span class="n">min2</span>
	<span class="k">if</span> <span class="n">minv</span><span class="o">==</span><span class="n">maxv</span><span class="p">:</span>
		<span class="k">yield</span> <span class="n">minv</span>
		<span class="n">x</span><span class="o">+=</span><span class="mi">1</span>
		<span class="n">minv</span><span class="o">+=</span><span class="mi">1</span>
		<span class="c">#yield min+1</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">while</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">maxv</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">num_dec</span><span class="p">:</span>
				<span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">num_dec</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">x</span>
			<span class="n">x</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
	<span class="k">yield</span> <span class="n">maxv</span>

<span class="c">#use output from IMGT program to determine productivity</span></div>
<div class="viewcode-block" id="IMGTProductivity"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.IMGTProductivity">[docs]</a><span class="k">def</span> <span class="nf">IMGTProductivity</span><span class="p">(</span><span class="n">field_row</span><span class="p">):</span>
	<span class="k">global</span> <span class="n">functionality_field</span>
	<span class="k">if</span> <span class="n">field_row</span><span class="p">[</span><span class="n">functionality_field</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;unproductive&#39;</span> <span class="ow">or</span> <span class="n">field_row</span><span class="p">[</span><span class="n">functionality_field</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;No results&#39;</span> <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="n">field_row</span><span class="p">[</span><span class="n">functionality_field</span><span class="p">]):</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">True</span>

<span class="c">#use output from IGBLAST program to determine productivity</span>
<span class="c">#(have not handled this function yet)</span></div>
<div class="viewcode-block" id="IGBLASTProductivity"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.IGBLASTProductivity">[docs]</a><span class="k">def</span> <span class="nf">IGBLASTProductivity</span><span class="p">(</span><span class="n">field_row</span><span class="p">):</span>
	<span class="k">return</span> <span class="bp">True</span> 

<span class="c">#use output from IGFFT program to determine productivity</span></div>
<div class="viewcode-block" id="IGFFTProductivity"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.IGFFTProductivity">[docs]</a><span class="k">def</span> <span class="nf">IGFFTProductivity</span><span class="p">(</span><span class="n">field_row</span><span class="p">):</span>
	<span class="k">global</span> <span class="n">functionality_field</span>
	<span class="k">if</span> <span class="n">field_row</span><span class="p">[</span><span class="n">functionality_field</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;NO&#39;</span> <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="n">field_row</span><span class="p">[</span><span class="n">functionality_field</span><span class="p">]):</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">else</span><span class="p">:</span>		
		<span class="k">return</span> <span class="bp">True</span>

<span class="c">#use output from MIXCR program to determine productivity</span></div>
<div class="viewcode-block" id="MIXCRProductivity"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.MIXCRProductivity">[docs]</a><span class="k">def</span> <span class="nf">MIXCRProductivity</span><span class="p">(</span><span class="n">field_row</span><span class="p">):</span>	
	<span class="k">global</span> <span class="n">full_aa_field</span>
	<span class="k">if</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">field_row</span><span class="p">[</span><span class="n">full_aa_field</span><span class="p">]</span> <span class="ow">or</span> <span class="s">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">field_row</span><span class="p">[</span><span class="n">full_aa_field</span><span class="p">]:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">True</span>


<span class="c">#general function for determining if a sequence is productive or not </span></div>
<div class="viewcode-block" id="GeneralProductivity"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.GeneralProductivity">[docs]</a><span class="k">def</span> <span class="nf">GeneralProductivity</span><span class="p">(</span><span class="n">field_row</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		General function for determining if an entire Antibody amino acid sequence is productive or not </span>
<span class="sd">		</span>
<span class="sd">		Function will return True or False based on rule </span>
<span class="sd">		Input variable field_row: this will represent all antibody annotation field for a specific sequence the provided annotation file</span>
<span class="sd">		</span>
<span class="sd">		General steps:</span>
<span class="sd">			Extract the field referring to the amino acid sequence of the antibody 			</span>

<span class="sd">			If there is a stop codon (*) in sequence </span>

<span class="sd">				return false </span>

<span class="sd">			Else </span>
<span class="sd">			</span>
<span class="sd">				return true</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">global</span> <span class="n">full_aa_field</span>
	<span class="k">if</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">field_row</span><span class="p">[</span><span class="n">full_aa_field</span><span class="p">]:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="CDR3Productivity"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.CDR3Productivity">[docs]</a><span class="k">def</span> <span class="nf">CDR3Productivity</span><span class="p">(</span><span class="n">field_row</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Rule for CDR3 productivity. 		</span>
<span class="sd">		</span>
<span class="sd">		Function will return True or False based on rule </span>
<span class="sd">		Input variable field_row: this will represent all antibody annotation field for a specific sequence the provided annotation file</span>
<span class="sd">		</span>
<span class="sd">		General steps:</span>
<span class="sd">			1) Extract the CDR3 nucleotide field </span>
<span class="sd">			2) If length of CDR3 is not a multiple of 3 or length of CDR3 &lt; 9</span>
<span class="sd">				return false </span>
<span class="sd">			3) Translate CDR3 to amino acid </span>
<span class="sd">			4) If there is a stop codon (*) in sequence</span>
<span class="sd">				return false </span>
<span class="sd">			5) return true</span>
<span class="sd">		</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">global</span> <span class="n">cdr3_field</span>
	<span class="n">cdr3_nt</span> <span class="o">=</span> <span class="n">field_row</span><span class="p">[</span><span class="n">cdr3_field</span><span class="p">]</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdr3_nt</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdr3_nt</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>		
	<span class="n">cdr3_aa</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">cdr3_nt</span><span class="p">,</span><span class="n">generic_dna</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">())</span>
	<span class="k">if</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">cdr3_aa</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">True</span>

	</div>
<div class="viewcode-block" id="populate_clusters"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.populate_clusters">[docs]</a><span class="k">def</span> <span class="nf">populate_clusters</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">):</span>
	<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)):</span>
		<span class="k">return</span> <span class="n">d</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_in</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">line_text</span> <span class="ow">in</span> <span class="n">f_in</span><span class="p">:</span>			
			<span class="n">line_text</span> <span class="o">=</span> <span class="n">line_text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
			<span class="n">line</span> <span class="o">=</span> <span class="n">line_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
		
			<span class="n">SorH</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Seed or Hit</span>
			<span class="n">number</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c">#seed number</span>
			
			<span class="k">if</span> <span class="s">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="mi">8</span><span class="p">]:</span>
				<span class="n">info</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">info</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
			<span class="n">counts</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
			
			<span class="c">#identify seeds (S) vs hits (H)</span>
			<span class="k">if</span> <span class="n">SorH</span><span class="o">==</span><span class="s">&#39;S&#39;</span><span class="p">:</span>
				<span class="n">d</span><span class="p">[</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">counts</span><span class="p">,]</span>
				<span class="n">d</span><span class="p">[</span><span class="n">number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">SorH</span><span class="o">==</span><span class="s">&#39;H&#39;</span><span class="p">:</span>
				<span class="n">d</span><span class="p">[</span><span class="n">number</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">counts</span>
				<span class="n">d</span><span class="p">[</span><span class="n">number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>		
	<span class="k">return</span> <span class="n">d</span> 
</div>
<div class="viewcode-block" id="gene_hist"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.gene_hist">[docs]</a><span class="k">def</span> <span class="nf">gene_hist</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">geneCall</span><span class="p">):</span>
	
	<span class="n">summary</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
	
	<span class="n">hist</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
	
	<span class="k">if</span> <span class="n">geneCall</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
		<span class="n">Title</span><span class="o">=</span><span class="s">&#39;VH gene analysis&#39;</span>
		<span class="n">genePos</span><span class="o">=</span><span class="mi">5</span>
	<span class="k">if</span> <span class="n">geneCall</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
		<span class="n">Title</span><span class="o">=</span><span class="s">&#39;DH gene analysis&#39;</span>
		<span class="n">genePos</span><span class="o">=</span><span class="mi">6</span>
	<span class="k">if</span> <span class="n">geneCall</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
		<span class="n">Title</span><span class="o">=</span><span class="s">&#39;JH gene analysis&#39;</span>
		<span class="n">genePos</span><span class="o">=</span><span class="mi">7</span>
	<span class="k">if</span> <span class="n">geneCall</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
		<span class="n">Title</span><span class="o">=</span><span class="s">&#39;VL gene analysis&#39;</span>
		<span class="n">genePos</span><span class="o">=</span><span class="mi">8</span>
	<span class="k">if</span> <span class="n">geneCall</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
		<span class="n">Title</span><span class="o">=</span><span class="s">&#39;JL gene analysis&#39;</span>
		<span class="n">genePos</span><span class="o">=</span><span class="mi">9</span>
	
	<span class="n">total</span><span class="o">=</span><span class="mi">0</span>
	<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
		<span class="n">gene</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)[</span><span class="n">genePos</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">hist</span><span class="p">:</span>
			<span class="n">hist</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">hist</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
		<span class="n">total</span><span class="o">+=</span><span class="mi">1</span>	

	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">******  </span><span class="si">%s</span><span class="s">  ******</span><span class="se">\n\n</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">Title</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="n">percent</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="mf">100.0</span><span class="o">*</span><span class="n">hist</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">total</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:&lt;12} {:&lt;12} {:&lt;12}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">hist</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">percent</span><span class="p">))</span>	

	
<span class="c">#variable for determining whether the antibody is heavy or light chain </span></div>
<span class="n">chain_call</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&#39;VDJ&#39;</span><span class="p">:[</span><span class="s">&#39;TRB&#39;</span><span class="p">,</span><span class="s">&#39;TB&#39;</span><span class="p">,</span><span class="s">&#39;IGH&#39;</span><span class="p">,</span><span class="s">&#39;TRD&#39;</span><span class="p">],</span>
	<span class="s">&#39;VJ&#39;</span><span class="p">:[</span><span class="s">&#39;IGK&#39;</span><span class="p">,</span><span class="s">&#39;TRA&#39;</span><span class="p">,</span><span class="s">&#39;TA&#39;</span><span class="p">,</span><span class="s">&#39;IGL&#39;</span><span class="p">,</span><span class="s">&#39;TRG&#39;</span><span class="p">],</span>	
<span class="p">}</span>


<span class="c">#this is a simple variable for mapping the fields we require to run the analysis to the field names in different annotation files </span>
<span class="c">#so when reading files we know that the field name &#39;Functionality_1&#39; in IMGT files correponds to our functionality variable we use in the analysis </span>
<span class="n">pairing_settings</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&#39;IMGT&#39;</span><span class="p">:{</span>
		<span class="s">&#39;fields_for_analysis&#39;</span><span class="p">:{</span>
			<span class="s">&#39;functionality&#39;</span><span class="p">:</span><span class="s">&#39;Functionality_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;Sequence ID_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene&#39;</span><span class="p">:</span><span class="s">&#39;V-GENE and allele_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene&#39;</span><span class="p">:</span><span class="s">&#39;J-GENE and allele_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene&#39;</span><span class="p">:</span><span class="s">&#39;D-GENE and allele_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;Sequence_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;cdr3_nt&#39;</span><span class="p">:</span><span class="s">&#39;CDR3-IMGT_3&#39;</span><span class="p">,</span>
			<span class="s">&#39;seq_header&#39;</span><span class="p">:</span><span class="s">&#39;Sequence ID_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;shm&#39;</span><span class="p">:</span><span class="s">&#39;VREGION.SHM.NT_PER&#39;</span><span class="p">,</span>			
			<span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.AA&#39;</span><span class="p">,</span><span class="c">#THIS FIELD IS NOT PRESENT IN THE IMGT FILE, BUT IT DOES GET ADDED TO THE INFORMATION WHEN READING IMGT FILES USING OUR READER CLASS			</span>
			<span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span><span class="c">#THIS FIELD IS NOT PRESENT IN THE IMGT FILE, BUT IT DOES GET ADDED TO THE INFORMATION WHEN READING IMGT FILES USING OUR READER CLASS			</span>
			<span class="s">&#39;vgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;V-REGION score_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;D-REGION score_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;J-REGION score_1&#39;</span><span class="p">,</span>
			<span class="s">&#39;recomb&#39;</span><span class="p">:</span><span class="s">&#39;R_TYPE&#39;</span>
			
		<span class="p">},</span>
		<span class="s">&#39;productivity_function&#39;</span><span class="p">:</span><span class="n">IMGTProductivity</span> <span class="c">#when handling IMGT anaysis, use the function described above (IMGTProductivity) to determine whether a sequence is productive or not </span>
	<span class="p">},</span>
	<span class="s">&#39;IGBLAST&#39;</span><span class="p">:{</span>
		<span class="s">&#39;fields_for_analysis&#39;</span><span class="p">:{</span>
			<span class="s">&#39;functionality&#39;</span><span class="p">:</span><span class="s">&#39;PRODUCTIVE&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&quot;FULL_SEQ&quot;</span><span class="p">,</span>
			<span class="s">&#39;vgene&#39;</span><span class="p">:</span><span class="s">&#39;VREGION.VGENES&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene&#39;</span><span class="p">:</span><span class="s">&#39;JREGION.JGENES&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene&#39;</span><span class="p">:</span><span class="s">&#39;DREGION.DGENES&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;FULL_SEQ&#39;</span><span class="p">,</span>
			<span class="s">&#39;cdr3_nt&#39;</span><span class="p">:</span><span class="s">&#39;CDR3.NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;seq_header&#39;</span><span class="p">:</span><span class="s">&#39;DOCUMENTHEADER&#39;</span><span class="p">,</span>
			<span class="s">&#39;shm&#39;</span><span class="p">:</span><span class="s">&quot;VREGION.SHM_NT_PER&quot;</span><span class="p">,</span>			
			<span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.AA&#39;</span><span class="p">,</span><span class="c">#optional field but preferred</span>
			<span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span>			
			<span class="s">&#39;vgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;VREGION.VGENE_SCORE&quot;</span><span class="p">,</span>
			<span class="s">&#39;jgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;JREGION.VGENE_SCORE&quot;</span><span class="p">,</span>
			<span class="s">&#39;dgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;DREGION.VGENE_SCORE&quot;</span><span class="p">,</span>
			<span class="s">&#39;recomb&#39;</span><span class="p">:</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span>
		<span class="p">},</span>                    
		<span class="s">&#39;productivity_function&#39;</span><span class="p">:</span><span class="n">CDR3Productivity</span>
	<span class="p">},</span>
	<span class="s">&#39;IGFFT&#39;</span><span class="p">:{</span>
		<span class="s">&#39;fields_for_analysis&#39;</span><span class="p">:{</span>
			<span class="s">&#39;functionality&#39;</span><span class="p">:</span><span class="s">&#39;Productive&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene&#39;</span><span class="p">:</span><span class="s">&#39;Top_V-Gene_Hits&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;Sequence&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene&#39;</span><span class="p">:</span><span class="s">&#39;Top_J-Gene_Hits&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="c">#Top_D-Gene_Hits</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;Sequence&#39;</span><span class="p">,</span>
			<span class="s">&#39;cdr3_nt&#39;</span><span class="p">:</span><span class="s">&#39;CDR3_Sequence.NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;seq_header&#39;</span><span class="p">:</span><span class="s">&#39;Header&#39;</span><span class="p">,</span>
			<span class="s">&#39;shm&#39;</span><span class="p">:</span><span class="s">&#39;VRegion.SHM.Per_nt&#39;</span><span class="p">,</span><span class="c">#&#39;VRegion.SHM.NT&#39;,</span>
			<span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">:</span><span class="s">&#39;Full_Length_Sequence.AA&#39;</span><span class="p">,</span><span class="c">#optional field but preferred</span>
			<span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">:</span><span class="s">&#39;Full_Length_Sequence.NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;isotype&#39;</span><span class="p">:</span><span class="s">&#39;Isotype&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;V-Gene_Alignment_Scores&quot;</span><span class="p">,</span>
			<span class="s">&#39;jgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;J-Gene_Alignment_Scores&quot;</span><span class="p">,</span>
			<span class="s">&#39;dgene_scores&#39;</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">,</span>
			<span class="s">&#39;recomb&#39;</span><span class="p">:</span><span class="s">&#39;Recombination_Type&#39;</span>
		<span class="p">},</span>
		<span class="s">&#39;productivity_function&#39;</span><span class="p">:</span><span class="n">CDR3Productivity</span>
	<span class="p">},</span>
	<span class="s">&#39;MIXCR&#39;</span><span class="p">:{</span>
		<span class="s">&#39;fields_for_analysis&#39;</span><span class="p">:{</span>
			<span class="s">&#39;functionality&#39;</span><span class="p">:</span><span class="s">&#39;Productivity&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene&#39;</span><span class="p">:</span><span class="s">&quot;All V hits&quot;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;Sequence&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene&#39;</span><span class="p">:</span><span class="s">&quot;All J hits&quot;</span><span class="p">,</span>
			<span class="s">&#39;dgene&#39;</span><span class="p">:</span><span class="s">&quot;All D hits&quot;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;Sequence&#39;</span><span class="p">,</span>
			<span class="s">&#39;cdr3_nt&#39;</span><span class="p">:</span><span class="s">&#39;N. Seq. CDR3&#39;</span><span class="p">,</span>
			<span class="s">&#39;seq_header&#39;</span><span class="p">:</span><span class="s">&#39;Seqheader&#39;</span><span class="p">,</span>
			<span class="s">&#39;shm&#39;</span><span class="p">:</span> <span class="s">&#39;VGENE: Shm.per&#39;</span><span class="p">,</span><span class="c">#&#39;VGENE: Shm.nt&#39;,</span>
			<span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">:</span><span class="s">&#39;Full AA&#39;</span><span class="p">,</span><span class="c">#optional field but preferred</span>
			<span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">:</span><span class="s">&#39;Full NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;isotype&#39;</span><span class="p">:</span><span class="s">&#39;All C hits&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;All V scores&quot;</span><span class="p">,</span>
			<span class="s">&#39;jgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;All J scores&quot;</span><span class="p">,</span>
			<span class="s">&#39;dgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;All D scores&quot;</span><span class="p">,</span>
			<span class="s">&#39;recomb&#39;</span><span class="p">:</span><span class="s">&#39;Recombination Type&#39;</span>
		<span class="p">},</span>
		<span class="s">&#39;productivity_function&#39;</span><span class="p">:</span><span class="n">CDR3Productivity</span>
	<span class="p">},</span>
	
	<span class="s">&#39;DATABASE&#39;</span><span class="p">:{</span>
		<span class="s">&#39;fields_for_analysis&#39;</span><span class="p">:{</span>
			<span class="s">&#39;functionality&#39;</span><span class="p">:</span><span class="s">&#39;PRODUCTIVE&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;SEQUENCE&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene&#39;</span><span class="p">:</span><span class="s">&#39;VREGION.VGENES&#39;</span><span class="p">,</span>
			<span class="s">&#39;jgene&#39;</span><span class="p">:</span><span class="s">&#39;JREGION.JGENES&#39;</span><span class="p">,</span>
			<span class="s">&#39;dgene&#39;</span><span class="p">:</span><span class="s">&#39;DREGION.DGENES&#39;</span><span class="p">,</span>
			<span class="s">&#39;raw_seq_nt&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;cdr3_nt&#39;</span><span class="p">:</span><span class="s">&#39;CDR3.NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;seq_header&#39;</span><span class="p">:</span><span class="s">&#39;SEQUENCE_HEADER&#39;</span><span class="p">,</span>
			<span class="s">&#39;shm&#39;</span><span class="p">:</span><span class="s">&#39;VREGION.SHM.NT_PER&#39;</span><span class="p">,</span>
			<span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.AA&#39;</span><span class="p">,</span><span class="c">#optional field but preferred</span>
			<span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">:</span><span class="s">&#39;PREDICTED_AB_SEQ.NT&#39;</span><span class="p">,</span>
			<span class="s">&#39;isotype&#39;</span><span class="p">:</span><span class="s">&#39;ISOTYPE.GENE&#39;</span><span class="p">,</span>
			<span class="s">&#39;vgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;VREGION.VGENE_SCORES&quot;</span><span class="p">,</span>
			<span class="s">&#39;jgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;JREGION.JGENE_SCORES&quot;</span><span class="p">,</span>
			<span class="s">&#39;dgene_scores&#39;</span><span class="p">:</span><span class="s">&quot;DREGION.DGENE_SCORES&quot;</span><span class="p">,</span>
			<span class="s">&#39;recomb&#39;</span><span class="p">:</span><span class="s">&#39;RECOMBINATION_TYPE&#39;</span>
		<span class="p">},</span>
		<span class="s">&#39;productivity_function&#39;</span><span class="p">:</span><span class="n">CDR3Productivity</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">supported_analyses</span> <span class="o">=</span> <span class="n">pairing_settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

<div class="viewcode-block" id="GetHeaderInfo"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.GetHeaderInfo">[docs]</a><span class="k">def</span> <span class="nf">GetHeaderInfo</span><span class="p">(</span><span class="n">file_data</span><span class="p">,</span><span class="n">header_var</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">file_data</span><span class="p">[</span><span class="n">header_var</span><span class="p">]</span>
	
	<span class="c">#check if ididnetifier is in the file first </span>
	<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">file_data</span> <span class="ow">and</span> <span class="n">file_data</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]:</span>
		<span class="nb">id</span> <span class="o">=</span> <span class="n">file_data</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="c">#its not in the file, so it might in header </span>
		<span class="nb">id</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		<span class="k">if</span> <span class="n">fasta_file_delimiter</span> <span class="ow">in</span> <span class="n">h</span><span class="p">:</span>
			<span class="c">#check header </span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fasta_file_delimiter</span><span class="p">)</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">additional_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">additional_data</span><span class="o">=</span><span class="p">{}</span>
			<span class="k">if</span> <span class="n">idIdentifier</span> <span class="ow">in</span> <span class="n">additional_data</span><span class="p">:</span>
				<span class="nb">id</span> <span class="o">=</span> <span class="n">additional_data</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">]</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">h</span><span class="p">,</span><span class="nb">id</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="initialize_input_files"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.initialize_input_files">[docs]</a><span class="k">def</span> <span class="nf">initialize_input_files</span><span class="p">(</span><span class="n">analysis_method</span><span class="p">,</span><span class="n">list_of_filetypes</span><span class="p">,</span><span class="n">list_of_files</span><span class="p">):</span>
	<span class="k">global</span> <span class="n">annotation_headers</span>
	<span class="c">#load all of the filenames and open the files using our class for reading different files </span>
	<span class="k">if</span> <span class="n">list_of_filetypes</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">list_of_file_reading</span> <span class="o">=</span> <span class="p">[</span><span class="n">readfile</span><span class="o">.</span><span class="n">immunogrepFile</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">)]</span>
	<span class="k">elif</span> <span class="n">list_of_filetypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span><span class="s">&#39;IMGT&#39;</span><span class="p">:</span>
		<span class="n">list_of_file_reading</span> <span class="o">=</span> <span class="p">[</span><span class="n">readfile</span><span class="o">.</span><span class="n">immunogrepFile</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="s">&#39;IMGT&#39;</span><span class="p">,</span><span class="n">required_files</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="n">field_names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Sequence_1&#39;</span><span class="p">,</span><span class="s">&#39;V-D-J-REGION_3&#39;</span><span class="p">,</span><span class="s">&#39;V-D-J-REGION_5&#39;</span><span class="p">,</span><span class="s">&#39;V-J-REGION_3&#39;</span><span class="p">,</span><span class="s">&#39;V-J-REGION_5&#39;</span><span class="p">,</span><span class="s">&#39;CDR3-IMGT_5&#39;</span><span class="p">,</span><span class="s">&#39;Functionality_1&#39;</span><span class="p">,</span><span class="s">&#39;V-GENE and allele_1&#39;</span><span class="p">,</span><span class="s">&#39;D-GENE and allele_1&#39;</span><span class="p">,</span><span class="s">&#39;J-GENE and allele_1&#39;</span><span class="p">,</span><span class="s">&#39;CDR3-IMGT_3&#39;</span><span class="p">,</span><span class="s">&#39;Sequence ID_1&#39;</span><span class="p">,</span><span class="s">&#39;V-REGION Nb of mutations_8&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">)]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">list_of_file_reading</span> <span class="o">=</span> <span class="p">[</span><span class="n">readfile</span><span class="o">.</span><span class="n">immunogrepFile</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">list_of_filetypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">)]</span>
	
	<span class="c">#we will generate annotation files as we read through the files for pairing 	</span>
	<span class="n">annotation_file_writing</span> <span class="o">=</span> <span class="p">[]</span>	
	<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">list_of_files</span><span class="p">:</span>		
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
			<span class="n">bname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">annotation_file_writing</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;filename&#39;</span><span class="p">:</span><span class="n">annotation_path</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">bname</span><span class="o">+</span><span class="s">&#39;.pairing.annotation&#39;</span><span class="p">,</span><span class="s">&#39;buffer&#39;</span><span class="p">:</span><span class="nb">open</span><span class="p">(</span><span class="n">annotation_path</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">bname</span><span class="o">+</span><span class="s">&#39;.pairing.annotation.temp&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)})</span>			
		<span class="k">else</span><span class="p">:</span>
			<span class="n">bname</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
			<span class="n">annotation_file_writing</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;filename&#39;</span><span class="p">:</span><span class="n">annotation_path</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">bname</span><span class="o">+</span><span class="s">&#39;.pairing.annotation&#39;</span><span class="p">,</span><span class="s">&#39;buffer&#39;</span><span class="p">:</span><span class="nb">open</span><span class="p">(</span><span class="n">annotation_path</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">bname</span><span class="o">+</span><span class="s">&#39;.pairing.annotation.temp&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)})</span>		
		<span class="n">translator</span> <span class="o">=</span> <span class="n">DatabaseTranslator</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">analysis_method</span><span class="o">!=</span><span class="s">&#39;CUSTOM&#39;</span><span class="p">:</span>
			<span class="n">translator</span><span class="p">[</span><span class="n">translation_var</span><span class="p">][</span><span class="s">&quot;ANALYSIS_NAME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_method</span>		
		<span class="n">annotation_file_writing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">descriptor_symbol</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">translator</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
		<span class="n">annotation_file_writing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">annotation_headers</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">list_of_file_reading</span><span class="p">,</span><span class="n">annotation_file_writing</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="ProcessGene"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.ProcessGene">[docs]</a><span class="k">def</span> <span class="nf">ProcessGene</span><span class="p">(</span><span class="n">gene</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Removes the allele calls from genes</span>
<span class="sd">		</span>
<span class="sd">		Assumption: </span>
<span class="sd">			</span>
<span class="sd">			Multiple genes are seperated by &#39;,&#39; </span>
<span class="sd">			</span>
<span class="sd">			Alleles are seperated by &#39;*&#39; </span>
<span class="sd">			</span>
<span class="sd">			If a gene is seperated by multiple spaces, then the gene should be identified by a gene that contains either - or &#39;*&#39; </span>
<span class="sd">			For example: </span>

<span class="sd">				Imgt genes may be: </span>

<span class="sd">					Homo sapiens IGHV1-3*01</span>

<span class="sd">					We only want to isolate the word IGHV1-3</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="k">if</span> <span class="ow">not</span> <span class="n">gene</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>	
	<span class="c">#extract all genes in field </span>
	<span class="n">gene_array</span> <span class="o">=</span> <span class="n">gene</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">gene_num</span><span class="p">,</span><span class="n">each_gene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gene_array</span><span class="p">):</span>
		<span class="c">#split each gene by spaces. Go through each word</span>
		<span class="n">split_words</span>  <span class="o">=</span> <span class="n">each_gene</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_words</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#there is only one word </span>
			<span class="n">gene_array</span><span class="p">[</span><span class="n">gene_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">split_words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">g</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
			<span class="k">for</span> <span class="n">subv</span> <span class="ow">in</span> <span class="n">split_words</span><span class="p">:</span>
				<span class="c">#if we find a word with gene characters in it, it must be our gene </span>
				<span class="k">if</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">subv</span> <span class="ow">or</span> <span class="s">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">subv</span><span class="p">:</span>						
					<span class="c">#extract everything before &#39;*&#39;</span>
					<span class="n">g</span> <span class="o">=</span> <span class="n">subv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
					<span class="k">break</span>
			<span class="n">gene_array</span><span class="p">[</span><span class="n">gene_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>	
	<span class="k">return</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gene_array</span><span class="p">)</span>
	</div>
<div class="viewcode-block" id="get_top_genes"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.get_top_genes">[docs]</a><span class="k">def</span> <span class="nf">get_top_genes</span><span class="p">(</span><span class="n">gene_string</span><span class="p">,</span><span class="n">gene_scores</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">		Return a list of &#39;top&#39; unique genes</span>
<span class="sd">		Go through the reported list of genes and only report genes whose scores are equal to the top score</span>
<span class="sd">		</span>
<span class="sd">		Assumptions:	</span>
<span class="sd">			We err on the side of consider &#39;more genes&#39; than less</span>
<span class="sd">			1) If there is no score provided for a field, then consider all genes equally </span>
<span class="sd">			2) If only a single gene score is provided, then again, assume all reported genes have equal alignment (i.e. IMGT reporting)</span>
<span class="sd">			3) For all other cases where there is more than one gene score provided, then traverse the scores and only report genes whose score = top score</span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">gene_string</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">[]</span>
	<span class="c">#gene_string should only be genes not alleles. this should have been handled in the add_to_dict_memory_safe function </span>
	<span class="n">gene_array</span> <span class="o">=</span> <span class="n">gene_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
	
	<span class="c">#no scores provided, so we assume they are all equal </span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">gene_scores</span><span class="p">:</span>
		<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gene_array</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>			
			<span class="n">gene_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gene_scores</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)]</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="c">#gene scores are not numbers</span>
			<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gene_array</span><span class="p">))</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_numbers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="c">#IMGT will report only one gene score for multiple genes. we assume these genes are idetnically scored then </span>
			<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gene_array</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">top_score</span> <span class="o">=</span> <span class="n">gene_numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">top_gene_list</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gene_numbers</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">s</span><span class="o">&lt;</span><span class="n">top_score</span><span class="p">:</span>
					<span class="k">break</span>
				<span class="n">top_gene_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene_array</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
			<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">top_gene_list</span><span class="p">))</span>
						</div>
<div class="viewcode-block" id="parse_sorted_paired_file"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.parse_sorted_paired_file">[docs]</a><span class="k">def</span> <span class="nf">parse_sorted_paired_file</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	</span>
<span class="sd">		Function for extracting the proper VH-VL pairs from an annotation results </span>
<span class="sd">		We assume that the input file (pairing_temp_file) is a tab delimited file whose columns match the variable ab_field_loc</span>
<span class="sd">		the last column of the tab delimited file is equal to the fullcode field/the miseq id; we use this last column for sorting sequences into respective R1-R2 paired reads</span>
<span class="sd">		</span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">ab_field_loc</span> <span class="o">=</span> <span class="n">get_ab_field_loc</span><span class="p">()</span>
	<span class="k">global</span> <span class="n">codeDict_output_dict</span>
	<span class="k">global</span> <span class="n">dict_summary</span>
	<span class="k">global</span> <span class="n">collapsed_output_file</span>
	<span class="k">global</span> <span class="n">usearch_cluster_file</span>
	
	<span class="c">#parent_folder = &#39;/&#39;.join(dict_summary.split(&#39;/&#39;)[:-1])+&#39;/&#39;</span>
	<span class="c">#temp_barcode_file = parent_folder+&#39;cdrh3_l3_barcodes.txt&#39;</span>
	
	<span class="n">my_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">)</span><span class="c"># &#39;/&#39;.join(pairing_temp_file.split(&#39;/&#39;)[:-1])+&#39;/&#39;</span>

	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Will now sort file by MiSeq ID to determine which sequences should be paired&#39;</span><span class="p">)</span>
	<span class="n">fullcode_column</span> <span class="o">=</span> <span class="n">num_elem_stored</span><span class="o">+</span><span class="mi">1</span><span class="c">#last column number in file should be equal to the number of elements stored (in ab_field_loc) +1</span>
	<span class="c">#sort all sequences sent to file by the full code field (the last column in file) 		</span>
	<span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s">&#39;&#39;&#39;sort -T &quot;{2}&quot; -t &#39;</span><span class="se">\t</span><span class="s">&#39; &quot;{0}&quot; -k{1}&gt;&quot;{0}.sorted&quot; &#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">fullcode_column</span><span class="p">),</span><span class="n">my_folder</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>	
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;File sorted. Will now parse sequences into their H-L pairs&#39;</span><span class="p">)</span>	
	<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">)</span>	
	<span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="o">+</span><span class="s">&#39;.sorted&#39;</span><span class="p">,</span><span class="n">pairing_temp_file</span><span class="p">)</span>
	
	<span class="n">paired_fullcode</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
	<span class="n">num_paired</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">locus_pairing_error</span><span class="o">=</span><span class="mi">0</span>	
	<span class="n">num_r1_r2_found</span> <span class="o">=</span> <span class="mi">0</span>	
	<span class="n">Hchain_pairing_error</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">Lchain_pairing_error</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">successful_pair</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">nonpaired_len</span><span class="o">=</span><span class="mi">0</span>
	
	<span class="n">mapping_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">pairing_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">r_count</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">index_loc</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;VDJ&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;VJ&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
	
	<span class="n">codeDict_save</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">codeDict_output_dict</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
	<span class="n">write_dict_summary</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">dict_summary</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
	<span class="n">write_dict_summary_unsorted</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">dict_summary</span><span class="o">+</span><span class="s">&#39;.unsorted&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
	<span class="c">#collapsed_cdr3_barcode_file = open(temp_barcode_file,&#39;w&#39;)	</span>
	<span class="n">cdrh3_l3_barcode_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{&#39;</span><span class="p">)</span><span class="c">#we will save the variable codeDict as a JSON var to file. JSON files start with { and end with }. &#39;,&#39; will be used to save each R1-R2 pair</span>
	
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">sorted_file</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sorted_file</span><span class="p">:</span>
			<span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>
			<span class="n">fullcode</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>			
			<span class="k">if</span> <span class="ow">not</span> <span class="n">fullcode</span><span class="p">:</span>
				<span class="c">#shouldnt happen, but check anyway...</span>
				<span class="k">continue</span>
				
			<span class="n">temp_array</span> <span class="o">=</span> <span class="n">line</span>			
			<span class="n">rtype</span> <span class="o">=</span> <span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;CHAIN_CALL&#39;</span><span class="p">]]</span>			
			
			<span class="c">#we assume only two miseq IDs 		</span>
			<span class="k">if</span> <span class="n">r_count</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
				<span class="c">#encountered a potentially new R1/R2 pair.</span>
				<span class="c">#we need to read the next line to ensure that its an R1/R2 pair </span>
				<span class="n">pairing_dict_array</span> <span class="o">=</span> <span class="p">[[],[],</span><span class="s">&#39;&#39;</span><span class="p">]</span>
				<span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="n">rtype</span><span class="p">]]</span> <span class="o">=</span> <span class="n">temp_array</span>
				<span class="n">paired_fullcode</span> <span class="o">=</span> <span class="n">fullcode</span>
				<span class="n">r_count</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">continue</span>
			<span class="k">elif</span> <span class="n">fullcode</span><span class="o">==</span><span class="n">paired_fullcode</span><span class="p">:</span>
				<span class="c">#encountered a successful R1/R2 pair </span>
				<span class="n">check_index</span> <span class="o">=</span> <span class="n">index_loc</span><span class="p">[</span><span class="n">rtype</span><span class="p">]</span>
				<span class="n">other_index</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">check_index</span><span class="p">))</span> <span class="c">#basically =&gt; if check_index == 1, other_index=0 </span>
				<span class="c">#make sure its a VH-VL pair and not a VH-VH or VL-VL pair </span>
				<span class="n">num_r1_r2_found</span><span class="o">+=</span><span class="mi">1</span>				
				<span class="k">if</span> <span class="ow">not</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">check_index</span><span class="p">]:</span>
					<span class="c">#the sequence is a VH-VL PAIR </span>
					<span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">check_index</span><span class="p">]</span><span class="o">=</span><span class="n">temp_array</span>					
					<span class="c">#make sure the loci from both match (same receptor)</span>
					<span class="n">receptor_1</span> <span class="o">=</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
					<span class="n">receptor_2</span> <span class="o">=</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
					
					<span class="k">if</span> <span class="n">receptor_1</span><span class="o">!=</span><span class="n">receptor_2</span><span class="p">:</span>
						<span class="n">locus_pairing_error</span><span class="o">+=</span><span class="mi">1</span>						
						<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ReceptorMismatchError&#39;</span>
						<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>			
					<span class="k">else</span><span class="p">:</span>
						<span class="c">#a proper VH-VL pair was found </span>
						<span class="n">successful_pair</span><span class="o">+=</span><span class="mi">1</span>
						<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
						<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>														
						<span class="c">#lets write the proper VH-VL pair to the file write_dict_summary. This is a useful file for re-parsing the results after pairing </span>
						<span class="n">vdj_data</span> <span class="o">=</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VDJ&#39;</span><span class="p">]]</span>
						<span class="n">vj_data</span> <span class="o">=</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VJ&#39;</span><span class="p">]]</span>
						<span class="n">barcode_cdr_h3_l3</span> <span class="o">=</span> <span class="n">vdj_data</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;CDR3_SEQ&#39;</span><span class="p">]]</span><span class="o">+</span><span class="s">&#39;:&#39;</span><span class="o">+</span><span class="n">vj_data</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;CDR3_SEQ&#39;</span><span class="p">]]</span>						
						<span class="c">#write the barcode to the first column before the json string so that we can later sort by CDR3H3-L3 sequences</span>
						<span class="n">write_line</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([{</span><span class="n">field</span><span class="p">:</span><span class="n">vdj_data</span><span class="p">[</span><span class="n">index_val</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span><span class="n">index_val</span> <span class="ow">in</span> <span class="n">ab_field_loc</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()},{</span><span class="n">field</span><span class="p">:</span><span class="n">vj_data</span><span class="p">[</span><span class="n">index_val</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span><span class="n">index_val</span> <span class="ow">in</span> <span class="n">ab_field_loc</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()}])</span>
						<span class="n">write_dict_summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">barcode_cdr_h3_l3</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="n">write_line</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>						
						<span class="c">#also write the output to a file that will not be sorted by CDRH3-CDRL3 barcode idea. we use this for &#39;random&#39; selection program/test program </span>
						<span class="n">write_dict_summary_unsorted</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">write_line</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>						
						<span class="c">#lets now write a third file where we will later group results by their CDRH3-L3 nucleotide sequences</span>
						<span class="c">#collapsed_cdr3_barcode_file.write(barcode_cdr_h3_l3+&#39;\t&#39;+&#39;::&#39;.join(vdj_data)+&#39;\t&#39;+&#39;::&#39;.join(vj_data)+&#39;\n&#39;)</span>
						<span class="n">cdrh3_l3_barcode_dict</span><span class="p">[</span><span class="n">barcode_cdr_h3_l3</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
						<span class="n">mapping_dict</span><span class="p">[</span><span class="n">fullcode</span><span class="p">]</span> <span class="o">=</span> <span class="n">barcode_cdr_h3_l3</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_array</span>
					<span class="n">receptor_1</span> <span class="o">=</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
					<span class="n">receptor_1</span> <span class="o">=</span> <span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
					<span class="k">if</span> <span class="n">rtype</span><span class="o">==</span><span class="s">&#39;VDJ&#39;</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">receptor_1</span><span class="o">!=</span><span class="n">receptor_2</span><span class="p">:</span>
							<span class="n">locus_pairing_error</span><span class="o">+=</span><span class="mi">1</span>						
							<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ReceptorMismatchError AND VH-VH Pairing mismatch&#39;</span>
							<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>			
						<span class="k">else</span><span class="p">:</span>
							<span class="c">#a proper VH-VL pair was found </span>
							<span class="n">Hchain_pairing_error</span><span class="o">+=</span><span class="mi">1</span>
							<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;OverlapError&#39;</span>
							<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>														
					<span class="k">elif</span> <span class="n">rtype</span><span class="o">==</span><span class="s">&#39;VJ&#39;</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">receptor_1</span><span class="o">!=</span><span class="n">receptor_2</span><span class="p">:</span>
							<span class="n">locus_pairing_error</span><span class="o">+=</span><span class="mi">1</span>						
							<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ReceptorMismatchError AND VL-VL Pairing mismatch&#39;</span>
							<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>			
						<span class="k">else</span><span class="p">:</span>
							<span class="c">#a proper VH-VL pair was found </span>
							<span class="n">Lchain_pairing_error</span><span class="o">+=</span><span class="mi">1</span>
							<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;OverlapError&#39;</span>
							<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>																				
				<span class="n">r_count</span> <span class="o">=</span> <span class="mi">0</span> 
				<span class="n">paired_fullcode</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
				
			<span class="k">else</span><span class="p">:</span>
				<span class="n">nonpaired_len</span><span class="o">+=</span><span class="mi">1</span>
				<span class="c">#the previous R1 or R2 sequence did not have a corresponding R1/R2 seq that passed filteres</span>
				<span class="c">#save the previous sequence that did not have an R1/R2 pair to file </span>
				<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;CORRESPONDING READ FILE DID NOT PASS FILTERS&#39;</span>
				<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>			
				<span class="n">pairing_dict_array</span> <span class="o">=</span> <span class="p">[[],[],</span><span class="s">&#39;&#39;</span><span class="p">]</span>
				<span class="c">#update the pairing array with the new sequence info </span>
				<span class="n">pairing_dict_array</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="n">rtype</span><span class="p">]]</span> <span class="o">=</span> <span class="n">temp_array</span>
				<span class="n">paired_fullcode</span> <span class="o">=</span> <span class="n">fullcode</span>		
				<span class="n">r_count</span><span class="o">=</span><span class="mi">2</span>
				<span class="k">continue</span>
	
	<span class="k">if</span> <span class="n">r_count</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
		<span class="c">#the last line in the sequence did not work/have a proper pair </span>
		<span class="c">#the previous R1 or R2 sequence did not have a corresponding R1/R2 seq that passed filteres</span>
		<span class="c">#save the previous sequence that did not have an R1/R2 pair to file </span>
		<span class="n">pairing_dict_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;CORRESPONDING READ FILE DID NOT PASS FILTERS&#39;</span>
		<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&quot;&#39;</span><span class="o">+</span><span class="n">fullcode</span><span class="o">+</span><span class="s">&#39;&quot;:&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pairing_dict_array</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>			
		
	

	<span class="c">#FINISH off saving of codeDict. have to do this to ensure that json.load function will work on file lateron</span>
	<span class="k">if</span> <span class="n">num_r1_r2_found</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
		<span class="n">codeDict_save</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">SEEK_END</span><span class="p">)</span> <span class="c">#search for last character in file </span>
		<span class="n">codeDict_save</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span> <span class="c">#remove the last character (should be a &#39;,&#39;)</span>
		<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">}&#39;</span><span class="p">)</span><span class="c">#replace last characer with a }</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">codeDict_save</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">}&#39;</span><span class="p">)</span><span class="c">#replace last characer with a }</span>

	<span class="n">codeDict_save</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	<span class="c">#collapsed_cdr3_barcode_file.close()</span>
	<span class="n">write_dict_summary</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	<span class="n">write_dict_summary_unsorted</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	
	<span class="c">#Now sort the write_dict_summary file by CDRH3-L3 barcode sequences</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Sorting paired sequences by unique CDRH3-CDRL3 sequences&#39;</span><span class="p">)</span>
	<span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s">&#39;&#39;&#39;sort -T &quot;{1}&quot; -t &#39;</span><span class="se">\t</span><span class="s">&#39; &quot;{0}&quot; -k1,1 &gt; &quot;{0}.sorted&quot; &#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dict_summary</span><span class="p">,</span><span class="n">my_folder</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	<span class="c">#Now open the file again and keep track of unique CDRH3-CDRL3 sequence data. Keep and updated list of SHM to calculate the averate and standard deviation. </span>
	<span class="c">#Also keep track of which line has the MOST data. i.e. has all vgenes and isotype information. By default we will store this information as the &#39;unique&#39; sequence. </span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Collapsing sequences by unique CDRH3-CDRL3 values. Finding average SHM and most occurring &quot;Gene Mode&quot; for unique sequences&#39;</span><span class="p">)</span>
	<span class="n">group_barcode</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
	<span class="n">barcode_count</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">summed_counts</span> <span class="o">=</span> <span class="mi">0</span> 
	<span class="n">collapsed_output</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">collapsed_output_file</span><span class="o">+</span><span class="s">&#39;.presorted&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
	
	<span class="n">old_summary</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">dict_summary</span><span class="o">+</span><span class="s">&#39;.sorted&#39;</span><span class="p">)</span>
	<span class="n">new_dict_summary</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">dict_summary</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>

	<span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">each_seq_line</span> <span class="o">=</span> <span class="n">old_summary</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="k">break</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">each_seq_line</span><span class="p">:</span>
			<span class="k">break</span>
		<span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
		<span class="n">each_seq_line</span><span class="o">=</span><span class="n">each_seq_line</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
		<span class="n">each_seq_line</span> <span class="o">=</span> <span class="n">each_seq_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>
		<span class="n">barcode_cdr_h3_l3</span> <span class="o">=</span> <span class="n">each_seq_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">group_barcode</span> <span class="o">=</span> <span class="n">barcode_cdr_h3_l3</span>
		<span class="n">num_seqs</span> <span class="o">=</span> <span class="n">cdrh3_l3_barcode_dict</span><span class="p">[</span><span class="n">barcode_cdr_h3_l3</span><span class="p">]</span>
		<span class="n">current_seq</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="n">remaining_data</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">each_seq_line</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
		<span class="n">new_dict_summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_seqs</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="n">remaining_data</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>							
		
		<span class="n">seed_barcode_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">remaining_data</span><span class="p">)</span>
		<span class="n">vdj_data</span> <span class="o">=</span> <span class="n">seed_barcode_data</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VDJ&#39;</span><span class="p">]]</span>
		<span class="n">vj_data</span> <span class="o">=</span> <span class="n">seed_barcode_data</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VJ&#39;</span><span class="p">]]</span>
		<span class="n">num_not_empty</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vdj_data</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;none&quot;</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;N/A&quot;</span><span class="p">:</span>
				<span class="n">num_not_empty</span><span class="o">+=</span><span class="mi">1</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vj_data</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;none&quot;</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;N/A&quot;</span><span class="p">:</span>
				<span class="n">num_not_empty</span><span class="o">+=</span><span class="mi">1</span>
		<span class="n">most_fields</span> <span class="o">=</span> <span class="n">num_not_empty</span>
		<span class="n">shm_data_vdj</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">shm_data_vj</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">hmut_found</span><span class="o">=</span><span class="bp">False</span>
		<span class="n">lmut_found</span><span class="o">=</span><span class="bp">False</span>
		<span class="k">if</span> <span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s">&#39;none&#39;</span><span class="p">:</span>
			<span class="n">shm_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">])</span>
			<span class="n">hmut_found</span><span class="o">=</span><span class="bp">True</span>
			<span class="n">shm_data_vdj</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">shm_val</span><span class="p">,</span><span class="nb">pow</span><span class="p">(</span><span class="n">shm_val</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
		<span class="k">if</span> <span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s">&#39;none&#39;</span><span class="p">:</span>
			<span class="n">shm_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">])</span>
			<span class="n">lmut_found</span><span class="o">=</span><span class="bp">True</span>
			<span class="n">shm_data_vj</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">shm_val</span><span class="p">,</span><span class="nb">pow</span><span class="p">(</span><span class="n">shm_val</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>		
		
		<span class="n">vgene_counts_vdj</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">jgene_counts_vdj</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">dgene_counts_vdj</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		
		<span class="n">vgene_counts_vj</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">jgene_counts_vj</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>		
				
				
		<span class="c">#for all of the V(D)J genes in the pair, determine which genes are the top gene hits. return these genes as a list and update the current gene counts to the variable </span>
		<span class="c">#at the end of the group, we will determine the mode/most likely gene. for now, we only chose the first instance of a top count </span>
		<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">],</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VSCORES&#39;</span><span class="p">]):</span>			
			<span class="n">vgene_counts_vdj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
		<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DGENE&#39;</span><span class="p">],</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DSCORES&#39;</span><span class="p">]):</span>		
			<span class="n">dgene_counts_vdj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
		<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">],</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JSCORES&#39;</span><span class="p">]):</span>
			<span class="n">jgene_counts_vdj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
		
		<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">],</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VSCORES&#39;</span><span class="p">]):</span>			
			<span class="n">vgene_counts_vj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>		
		<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">],</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JSCORES&#39;</span><span class="p">]):</span>
			<span class="n">jgene_counts_vj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>	
		
		<span class="c">#go through all remaining sequences in this file that contains the same CDRH3-CDRL3 PAIR and take the sum of the SHM and SHM^2 												</span>
		<span class="k">while</span> <span class="n">current_seq</span><span class="o">!=</span><span class="n">num_seqs</span><span class="p">:</span>		
			<span class="n">current_seq</span><span class="o">+=</span><span class="mi">1</span>			
			<span class="n">each_seq_line</span> <span class="o">=</span> <span class="n">old_summary</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
			<span class="n">each_seq_line</span><span class="o">=</span><span class="n">each_seq_line</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
			<span class="n">each_seq_line</span> <span class="o">=</span> <span class="n">each_seq_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>
			<span class="n">barcode_cdr_h3_l3</span> <span class="o">=</span> <span class="n">each_seq_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">barcode_cdr_h3_l3</span><span class="o">!=</span><span class="n">group_barcode</span><span class="p">:</span>
				<span class="k">print</span> <span class="s">&#39;error matching barocdes&#39;</span>
				<span class="k">print</span> <span class="n">group_barcode</span>
				<span class="k">print</span> <span class="n">barcode_cdr_h3_l3</span>
				<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;problem collapsing by unique cdrh3-cdrl3&#39;</span><span class="p">)</span>																
			<span class="n">remaining_data</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">each_seq_line</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
			<span class="n">new_dict_summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_seqs</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="n">remaining_data</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>							
			
			<span class="n">barcode_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">remaining_data</span><span class="p">)</span>
			<span class="n">vdj_data</span> <span class="o">=</span> <span class="n">barcode_data</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VDJ&#39;</span><span class="p">]]</span>
			<span class="n">vj_data</span> <span class="o">=</span> <span class="n">barcode_data</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VJ&#39;</span><span class="p">]]</span>
			<span class="n">num_not_empty</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vdj_data</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;none&quot;</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;N/A&quot;</span><span class="p">:</span>
					<span class="n">num_not_empty</span><span class="o">+=</span><span class="mi">1</span>
			<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vj_data</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;none&quot;</span> <span class="ow">and</span> <span class="n">t</span><span class="o">!=</span><span class="s">&quot;N/A&quot;</span><span class="p">:</span>
					<span class="n">num_not_empty</span><span class="o">+=</span><span class="mi">1</span>
			<span class="k">if</span> <span class="n">num_not_empty</span><span class="o">&gt;</span><span class="n">most_fields</span><span class="p">:</span>
				<span class="c">#if you find more non empty fields in this sequence, then it should be treated as the &#39;seed&#39;</span>
				<span class="n">seed_barcode_data</span> <span class="o">=</span> <span class="n">barcode_data</span>
				<span class="n">most_fields</span> <span class="o">=</span> <span class="n">num_not_empty</span>
			<span class="k">if</span> <span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s">&#39;none&#39;</span><span class="p">:</span>
				<span class="n">shm_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">])</span>
				<span class="n">hmut_found</span><span class="o">=</span><span class="bp">True</span>					
				<span class="n">shm_data_vdj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
				<span class="n">shm_data_vdj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">shm_val</span>
				<span class="n">shm_data_vdj</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="nb">pow</span><span class="p">(</span><span class="n">shm_val</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s">&#39;none&#39;</span><span class="p">:</span>
				<span class="n">shm_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">])</span>
				<span class="n">lmut_found</span><span class="o">=</span><span class="bp">True</span>
				<span class="n">shm_data_vj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
				<span class="n">shm_data_vj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">shm_val</span>
				<span class="n">shm_data_vj</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="nb">pow</span><span class="p">(</span><span class="n">shm_val</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
			
			<span class="c">#for all of the V(D)J genes in the pair, determine which genes are the top gene hits. return these genes as a list and update the current gene counts to the variable </span>
			<span class="c">#at the end of the group, we will determine the mode/most likely gene. for now, we only chose the first instance of a top count </span>
			<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">],</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VSCORES&#39;</span><span class="p">]):</span>			
				<span class="n">vgene_counts_vdj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
			<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DGENE&#39;</span><span class="p">],</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DSCORES&#39;</span><span class="p">]):</span>		
				<span class="n">dgene_counts_vdj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
			<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">],</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JSCORES&#39;</span><span class="p">]):</span>
				<span class="n">jgene_counts_vdj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
			
			<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">],</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VSCORES&#39;</span><span class="p">]):</span>			
				<span class="n">vgene_counts_vj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>		
			<span class="k">for</span> <span class="n">top_genes</span> <span class="ow">in</span> <span class="n">get_top_genes</span><span class="p">(</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">],</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JSCORES&#39;</span><span class="p">]):</span>
				<span class="n">jgene_counts_vj</span><span class="p">[</span><span class="n">top_genes</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
			
		
		<span class="k">if</span> <span class="n">hmut_found</span><span class="p">:</span>
			<span class="n">Hmut_sum</span> <span class="o">=</span> <span class="n">shm_data_vdj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">Hmut_sum_sq</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">shm_data_vdj</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">6</span><span class="p">)</span>			
			<span class="n">Hmut_count</span> <span class="o">=</span> <span class="n">shm_data_vdj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		
			<span class="n">hsum_sq</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">Hmut_sum</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">Hmut_count</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>		
			<span class="c">#average shm</span>
			<span class="n">Hmut_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Hmut_sum</span><span class="o">/</span><span class="n">Hmut_count</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
			<span class="c">#shm variance -&gt; sum of squares formulat =&gt; sum(vals^2)-(sum(vals)^2/counts)</span>
			<span class="k">if</span> <span class="n">Hmut_count</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">Hmut_var</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">((</span><span class="n">Hmut_sum_sq</span><span class="o">-</span><span class="n">hsum_sq</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Hmut_count</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">0.5</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Hmut_var</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Hmut_avg</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
			<span class="n">Hmut_var</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
			<span class="n">Hmut_sum</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">Hmut_sum_sq</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">Hmut_count</span> <span class="o">=</span> <span class="mi">0</span>	
		
		<span class="k">if</span> <span class="n">lmut_found</span><span class="p">:</span>
			<span class="n">Lmut_sum</span> <span class="o">=</span> <span class="n">shm_data_vj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">Lmut_sum_sq</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">shm_data_vj</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">6</span><span class="p">)</span>
			<span class="n">Lmut_count</span> <span class="o">=</span> <span class="n">shm_data_vj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		
			<span class="n">lsum_sq</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">Lmut_sum</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">Lmut_count</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>		
			<span class="c">#average shm</span>
			<span class="n">Lmut_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Lmut_sum</span><span class="o">/</span><span class="n">Lmut_count</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
			<span class="c">#shm variance -&gt; sum of squares formulat =&gt; sum(vals^2)-(sum(vals)^2/counts)</span>
			<span class="k">if</span> <span class="n">Lmut_count</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">Lmut_var</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">((</span><span class="n">Lmut_sum_sq</span><span class="o">-</span><span class="n">lsum_sq</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Lmut_count</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">0.5</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Lmut_var</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Lmut_avg</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
			<span class="n">Lmut_var</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
			<span class="n">Lmut_sum</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">Lmut_sum_sq</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">Lmut_count</span> <span class="o">=</span> <span class="mi">0</span>	
		
		
		<span class="n">vdj_data</span> <span class="o">=</span> <span class="n">seed_barcode_data</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VDJ&#39;</span><span class="p">]]</span>
		<span class="n">vj_data</span> <span class="o">=</span> <span class="n">seed_barcode_data</span><span class="p">[</span><span class="n">index_loc</span><span class="p">[</span><span class="s">&#39;VJ&#39;</span><span class="p">]]</span>
		<span class="n">HLen</span><span class="o">=</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;CDR3_LEN&#39;</span><span class="p">]</span>
		<span class="n">LLen</span><span class="o">=</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;CDR3_LEN&#39;</span><span class="p">]</span>
						
		<span class="n">summed_counts</span><span class="o">+=</span><span class="n">num_seqs</span>
		
		<span class="c">##store the FIRST gene matching MAX MODE of the V(D)J genes </span>
		<span class="c">#vdj_data[&#39;VGENE&#39;] = max(vgene_counts_vdj, key=vgene_counts_vdj.get)</span>
		<span class="c">#vdj_data[&#39;DGENE&#39;] = max(dgene_counts_vdj, key=dgene_counts_vdj.get)</span>
		<span class="c">#vdj_data[&#39;JGENE&#39;] = max(jgene_counts_vdj, key=jgene_counts_vdj.get)</span>
		<span class="c">#vj_data[&#39;VGENE&#39;] = max(vgene_counts_vj, key=vgene_counts_vj.get)		</span>
		<span class="c">#vj_data[&#39;JGENE&#39;] = max(jgene_counts_vj, key=jgene_counts_vj.get)</span>

		<span class="c">##store the ALL genes matching MAX MODE of the V(D)J genes </span>
		<span class="k">if</span> <span class="n">vgene_counts_vdj</span><span class="p">:</span>
			<span class="n">max_item</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">vgene_counts_vdj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
			<span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="n">vgene_counts_vdj</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="n">max_item</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		
		<span class="k">if</span> <span class="n">dgene_counts_vdj</span><span class="p">:</span>	
			<span class="n">max_item</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dgene_counts_vdj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
			<span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="n">dgene_counts_vdj</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="n">max_item</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		
		<span class="k">if</span> <span class="n">jgene_counts_vdj</span><span class="p">:</span>
			<span class="n">max_item</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">jgene_counts_vdj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
			<span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="n">jgene_counts_vdj</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="n">max_item</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		
		<span class="k">if</span> <span class="n">vgene_counts_vj</span><span class="p">:</span>
			<span class="n">max_item</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">vgene_counts_vj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
			<span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="n">vgene_counts_vj</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="n">max_item</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>				
		<span class="k">else</span><span class="p">:</span>
			<span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
		
		<span class="k">if</span> <span class="n">jgene_counts_vj</span><span class="p">:</span>
			<span class="n">max_item</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">jgene_counts_vj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
			<span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="n">jgene_counts_vj</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="n">max_item</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
				
		<span class="c">#the variable ab_field_loc stores the index position for each antibody region in the array </span>
		<span class="n">CDRH3</span><span class="o">=</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;CDR3_SEQ&#39;</span><span class="p">]</span>
		<span class="n">VHgene</span><span class="o">=</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]</span>
		<span class="n">DHgene</span><span class="o">=</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;DGENE&#39;</span><span class="p">]</span>
		<span class="n">JHgene</span><span class="o">=</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]</span>
		<span class="n">CDRL3</span><span class="o">=</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;CDR3_SEQ&#39;</span><span class="p">]</span>
		<span class="n">VLgene</span><span class="o">=</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]</span>
		<span class="n">JLgene</span><span class="o">=</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]</span>
		<span class="n">IgH</span><span class="o">=</span><span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]</span>
		<span class="n">IgL</span><span class="o">=</span><span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]</span>
		<span class="n">h_iso</span> <span class="o">=</span> <span class="n">vdj_data</span><span class="p">[</span><span class="s">&#39;ISOTYPE&#39;</span><span class="p">]</span>
		<span class="n">l_iso</span> <span class="o">=</span> <span class="n">vj_data</span><span class="p">[</span><span class="s">&#39;ISOTYPE&#39;</span><span class="p">]</span>
		
		<span class="k">try</span><span class="p">:</span> 
			<span class="n">CDRH3_trans</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">CDRH3</span><span class="p">,</span><span class="n">generic_dna</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">())</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> 
			<span class="n">CDRH3</span><span class="o">=</span> <span class="s">&#39;translation error&#39;</span>
			<span class="k">print</span><span class="p">(</span><span class="s">&#39;Error translating: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="k">try</span><span class="p">:</span> 
			<span class="n">CDRL3_trans</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">CDRL3</span><span class="p">,</span><span class="n">generic_dna</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">())</span>
		<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> 
			<span class="n">CDRL3</span><span class="o">=</span> <span class="s">&#39;translation error&#39;</span>
			<span class="k">print</span><span class="p">(</span><span class="s">&#39;Error translating: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
			
	
		<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_seqs</span><span class="p">,</span><span class="n">CDRH3_trans</span><span class="p">,</span><span class="n">CDRL3_trans</span><span class="p">,</span><span class="n">CDRH3</span><span class="p">,</span><span class="n">CDRL3</span><span class="p">,</span><span class="n">VHgene</span><span class="p">,</span><span class="n">DHgene</span><span class="p">,</span><span class="n">JHgene</span><span class="p">,</span><span class="n">VLgene</span><span class="p">,</span><span class="n">JLgene</span><span class="p">,</span><span class="n">IgH</span><span class="p">,</span><span class="n">IgL</span><span class="p">,</span><span class="n">Hmut_avg</span><span class="p">,</span><span class="n">Hmut_var</span><span class="p">,</span><span class="n">Lmut_avg</span><span class="p">,</span><span class="n">Lmut_var</span><span class="p">,</span><span class="n">HLen</span><span class="p">,</span><span class="n">LLen</span><span class="p">,</span><span class="n">h_iso</span><span class="p">,</span><span class="n">l_iso</span><span class="p">,</span><span class="n">Hmut_sum</span><span class="p">,</span><span class="n">Hmut_sum_sq</span><span class="p">,</span><span class="n">Hmut_count</span><span class="p">,</span><span class="n">Lmut_sum</span><span class="p">,</span><span class="n">Lmut_sum_sq</span><span class="p">,</span><span class="n">Lmut_count</span><span class="p">]</span>
		<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
	
		<span class="n">collapsed_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>

	
	<span class="n">old_summary</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	<span class="n">new_dict_summary</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>	
	
	<span class="n">collapsed_output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Compiling collapsed reads file: sorting unique CDRH3-CDRL3 sequences by their respective counts and exporting to FASTA file&#39;</span><span class="p">)</span>
	
	<span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s">&#39;&#39;&#39;sort -T &quot;{1}&quot; -t &#39;</span><span class="se">\t</span><span class="s">&#39; &quot;{0}.presorted&quot; -k1,1nr &gt;&quot;{0}&quot; &#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collapsed_output_file</span><span class="p">,</span><span class="n">my_folder</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	
	<span class="c">#convert output to fasta file using AWK, ONLY print counts ($1) above 1 </span>
	<span class="c">#$4 =&gt; nucleotide CDR3</span>
	<span class="n">awk_command</span><span class="o">=</span><span class="s">&#39;gawk -v offile=&quot;&#39;</span><span class="o">+</span><span class="n">usearch_cluster_file</span>
	<span class="n">awk_command</span><span class="o">+=</span><span class="s">&#39;&#39;&#39;&quot; &#39;BEGIN{OFS=&quot;:&quot;;FS=&quot;</span><span class="se">\t</span><span class="s">&quot;};</span>
<span class="s">					int($1)&gt;1{s=$1;for(i=2;i&lt;=NF;i++)s=s&quot;&quot;OFS&quot;&quot;$i; print&quot;&gt;&quot;s&gt;offile;print $4&gt;offile;}&#39; &#39;&#39;&#39;</span><span class="o">+</span><span class="n">collapsed_output_file</span>
	
	<span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">awk_command</span><span class="p">,</span><span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	
	<span class="c">#if there are no VH-VL pairs found, then the awk command above will not create an empty file.</span>
	<span class="c">#so to account for that we will do a hack and create an empty file </span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">usearch_cluster_file</span><span class="p">):</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">usearch_cluster_file</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
			<span class="k">pass</span>
	
	<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dict_summary</span><span class="o">+</span><span class="s">&#39;.sorted&#39;</span><span class="p">)</span>
	<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">collapsed_output_file</span><span class="o">+</span><span class="s">&#39;.presorted&#39;</span><span class="p">)</span>
	
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Creating a sorted line-by-line cluster file&#39;</span><span class="p">)</span>
	<span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dict_summary</span><span class="p">,</span><span class="n">dict_summary</span><span class="o">+</span><span class="s">&#39;.presorted&#39;</span><span class="p">)</span>	
	<span class="n">final_sort</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;sort -T &quot;{1}&quot; -t &#39;</span><span class="se">\t</span><span class="s">&#39; &quot;{0}.presorted&quot; -k1,1nr | awk &#39;BEGIN{{FS=&quot;</span><span class="se">\t</span><span class="s">&quot;}};{{print $2&gt;&quot;{0}&quot;}}&#39; &#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dict_summary</span><span class="p">,</span><span class="n">my_folder</span><span class="p">)</span>	
	<span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">final_sort</span><span class="p">,</span><span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>	
	<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dict_summary</span><span class="o">+</span><span class="s">&#39;.presorted&#39;</span><span class="p">)</span>
	<span class="n">num_unique_h_l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdrh3_l3_barcode_dict</span><span class="p">)</span>
	<span class="n">cdrh3_l3_barcode_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">del</span>  <span class="n">cdrh3_l3_barcode_dict</span>
	<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
	
	

	<span class="k">return</span> <span class="p">[</span><span class="n">mapping_dict</span><span class="p">,</span><span class="n">num_paired</span><span class="p">,</span><span class="n">successful_pair</span><span class="p">,</span><span class="n">nonpaired_len</span><span class="p">,</span><span class="n">locus_pairing_error</span><span class="p">,</span><span class="n">num_r1_r2_found</span><span class="p">,</span><span class="n">num_unique_h_l</span><span class="p">,</span><span class="n">Hchain_pairing_error</span><span class="p">,</span><span class="n">Lchain_pairing_error</span><span class="p">]</span>
	

</div>
<div class="viewcode-block" id="add_to_dict_memory_safe"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.add_to_dict_memory_safe">[docs]</a><span class="k">def</span> <span class="nf">add_to_dict_memory_safe</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">,</span><span class="n">list_of_filetypes</span><span class="p">,</span><span class="n">required_field_names</span><span class="p">,</span><span class="n">productivity_function_call</span><span class="p">,</span><span class="n">parent_dir</span><span class="p">,</span><span class="n">analysis_method</span><span class="p">):</span>	
	<span class="sd">&quot;&quot;&quot; 	</span>

<span class="sd">		This function will parse through multiple annotation files provided for pairing. It does not require a specific filetype. It parses each input file and generates </span>
<span class="sd">		an output file only containing sequences which passed through our filters and reporting only the fields we require for pairing. The output file as the input file </span>
<span class="sd">		in :py:func:`.parse_sorted_paired_file`</span>

<span class="sd">	&quot;&quot;&quot;</span>	 
	   
	<span class="c">##DEFINING SOME VARIABLES##</span>

	<span class="c">#get global files names for opening files to write/use in this function </span>
	<span class="k">global</span> <span class="n">dict_summary</span>
	<span class="k">global</span> <span class="n">usearch_cluster_file</span>
	
	<span class="c">#set global variables for field names we require to run analysis </span>
	<span class="k">global</span> <span class="n">vgene_field</span>
	<span class="k">global</span> <span class="n">jgene_field</span>
	<span class="k">global</span> <span class="n">dgene_field</span>
	<span class="k">global</span> <span class="n">vgene_scores</span>
	<span class="k">global</span> <span class="n">jgene_scores</span>
	<span class="k">global</span> <span class="n">dgene_scores</span>
	<span class="k">global</span> <span class="n">recomb_field</span>
	<span class="k">global</span> <span class="n">seq_field</span>
	<span class="k">global</span> <span class="n">cdr3_field</span>
	<span class="k">global</span> <span class="n">header_field</span>
	<span class="k">global</span> <span class="n">mut_field</span>
	<span class="k">global</span> <span class="n">functionality_field</span>
	<span class="k">global</span> <span class="n">full_aa_field</span>
	<span class="k">global</span> <span class="n">full_nt_field</span>
	
	<span class="n">required_field_names</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">required_field_names</span><span class="p">)</span> <span class="c">#convert this to default dict so that not all fields have to be explicitly defined</span>
	
	<span class="c">#keys to that refer to field names. these are the key values we use for reading files </span>
	<span class="n">vgene_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;vgene&#39;</span><span class="p">]</span>
	<span class="n">jgene_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;jgene&#39;</span><span class="p">]</span>
	<span class="n">dgene_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;dgene&#39;</span><span class="p">]</span>
	<span class="n">seq_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;raw_seq_nt&#39;</span><span class="p">]</span>
	<span class="n">cdr3_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;cdr3_nt&#39;</span><span class="p">]</span>
	<span class="n">isotype_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;isotype&#39;</span><span class="p">]</span>
	<span class="n">header_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;seq_header&#39;</span><span class="p">]</span>
	<span class="n">mut_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;shm&#39;</span><span class="p">]</span>
	<span class="n">functionality_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;functionality&#39;</span><span class="p">]</span>
	<span class="n">full_aa_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;full_len_ab_aa&#39;</span><span class="p">]</span>
	<span class="n">full_nt_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;full_len_ab_nt&#39;</span><span class="p">]</span>
	<span class="n">vgene_scores</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;vgene_scores&#39;</span><span class="p">]</span>
	<span class="n">jgene_scores</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;jgene_scores&#39;</span><span class="p">]</span> 
	<span class="n">dgene_scores</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;dgene_scores&#39;</span><span class="p">]</span>
	<span class="n">recomb_field</span> <span class="o">=</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;recomb&#39;</span><span class="p">]</span>
	 
	<span class="c">#seq_field = required_field_names[&#39;sequence&#39;]</span>
	
	<span class="k">if</span> <span class="n">productivity_function_call</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">productivity_function_call</span> <span class="o">=</span> <span class="n">CDR3Productivity</span>	<span class="c">#GeneralProductivity</span>
										
	<span class="c">#write_dict_summary = open(dict_summary,&#39;w&#39;)</span>
	<span class="c">#collapsed_save=open(collapsed_output_dict,&#39;w&#39;)	</span>
	<span class="c">#collapsed_output=open(collapsed_output_file,&#39;wb&#39;)</span>
	<span class="c">#error=open(error_file,&#39;wb&#39;)</span>
	
	<span class="n">pairing_temp_file</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">dict_summary</span><span class="p">),</span><span class="s">&#39;temp_annotation_files.txt&#39;</span><span class="p">)</span> <span class="c">#&#39;/&#39;.join(dict_summary.split(&#39;/&#39;)[:-1])+&#39;/temp_annotation_files.txt&#39;</span>
	<span class="n">temp_seq_data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
		
	<span class="n">counter</span><span class="o">=</span><span class="mi">0</span>
		
	<span class="n">codeDictSeqs</span> <span class="o">=</span> <span class="p">{}</span> <span class="c">#stores whether or not a sequence was successfully found (i.e. passes all filters) =&gt; 0 = not successful, 1 = successful </span>
	<span class="n">collapsed_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c">#store counts for unique cdrH3/CDRL3 counts </span>
	
	<span class="n">nonpaired_len</span> <span class="o">=</span> <span class="mi">0</span>	
	<span class="n">no_cdr3_error</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of sequences which lack cdr3</span>
	<span class="n">invalid_chain</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of sequences which do not have a valid chain call based on the chain_call variable above </span>
	<span class="n">not_productive</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of sequences which are determined to be &#39;unproductive&#39;</span>
	<span class="n">total_seqs</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of all sequences</span>
	<span class="n">no_result</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of sequences that have no antibody information 	</span>
	<span class="n">passed_filter</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of sequences that pass the filters described above (no cdr3, unproductive, etc)	</span>
	
	<span class="n">ab_field_loc</span> <span class="o">=</span> <span class="n">get_ab_field_loc</span><span class="p">()</span>
	
	<span class="c">###VARIABLES DEFINED, CONTINUING WITH FUNCTION###</span>
	
	<span class="k">print</span> <span class="s">&#39;Reading all files at once and collapsing identical CDRH3-CDRL3 pairs into collapsed dict&#39;</span> 
	
	<span class="n">at_least_one_file_open</span> <span class="o">=</span> <span class="bp">True</span>
	
	<span class="c">#we will generate annotation files as we read through the files for pairing </span>
	<span class="p">[</span><span class="n">list_of_file_reading</span><span class="p">,</span><span class="n">annotation_file_writing</span><span class="p">]</span> <span class="o">=</span> <span class="n">initialize_input_files</span><span class="p">(</span><span class="n">analysis_method</span><span class="p">,</span><span class="n">list_of_filetypes</span><span class="p">,</span><span class="n">list_of_files</span><span class="p">)</span>
	<span class="c"># we will read each of the files simultaneously (open all the files at once and read line by line)</span>
	<span class="k">while</span> <span class="n">at_least_one_file_open</span><span class="p">:</span>		
	<span class="c">#while counter&lt;200000:</span>
		<span class="n">counter</span><span class="o">+=</span><span class="mi">1</span>
		<span class="k">if</span> <span class="n">total_seqs</span><span class="o">%</span><span class="mi">100000</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="k">print</span> <span class="s">&#39;Processed &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">total_seqs</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; sequences&#39;</span><span class="c">#: &#39;+str(counter)			</span>
		
		<span class="c">#keep track of how many files have been completely read</span>
		<span class="n">num_eof</span> <span class="o">=</span> <span class="mi">0</span> 
		
		<span class="c">#read each file line by line</span>
		<span class="k">for</span> <span class="n">fnum</span><span class="p">,</span><span class="n">reader</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_file_reading</span><span class="p">):</span> 
			<span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">IFclass</span><span class="o">.</span><span class="n">eof</span><span class="p">:</span>
				<span class="n">num_eof</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">continue</span>						
				
			<span class="n">my_line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">IFclass</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
							
			<span class="k">if</span> <span class="ow">not</span> <span class="n">my_line</span><span class="p">:</span><span class="c">#probably end of file or just empty line			</span>
				<span class="k">continue</span>
			
			<span class="n">my_line</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">my_line</span><span class="p">)</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">header_field</span><span class="p">]</span>				
			<span class="k">if</span> <span class="ow">not</span> <span class="n">h</span><span class="p">:</span>				
				<span class="n">annotation_file_writing</span><span class="p">[</span><span class="n">fnum</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="n">my_line</span><span class="p">[</span><span class="n">seq_field</span><span class="p">],</span><span class="n">my_line</span><span class="p">[</span><span class="n">idIdentifier</span><span class="p">],</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
				<span class="k">print</span> <span class="s">&#39;Error type 0: no sequence header&#39;</span>
				<span class="k">continue</span>
			
			<span class="p">[</span><span class="n">header</span><span class="p">,</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetHeaderInfo</span><span class="p">(</span><span class="n">my_line</span><span class="p">,</span><span class="n">header_field</span><span class="p">)</span>						
			<span class="n">seq</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">seq_field</span><span class="p">]</span>
			<span class="c">#get miseq code/read info </span>
			<span class="n">fullcode</span> <span class="o">=</span> <span class="s">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>															
						
			<span class="n">total_seqs</span><span class="o">+=</span><span class="mi">1</span>												
			
			<span class="c">#no amino acid sequence found </span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">my_line</span><span class="p">[</span><span class="n">full_aa_field</span><span class="p">]:</span>			
				
				<span class="c">#we no longer require the variable full_aa_field to be &#39;non empty&#39;</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">my_line</span><span class="p">[</span><span class="n">full_nt_field</span><span class="p">]:</span>					
					<span class="c">#no nucleotide sequence found either </span>
					<span class="c">#do not save this sequences results to file </span>
					<span class="c">#write to temperoary file annotation file, store that there is no full length sequence for this sequence, so no need to save its </span>
					<span class="c">#paired annotation information </span>
					<span class="c">#annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,seq,id,&#39;&#39;,&#39;&#39;,&#39;&#39;])+&#39;\n&#39;)						</span>
					<span class="c">#no_result+=1</span>
					<span class="c">#continue</span>
					<span class="k">pass</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c">#aminoa acid sequence was not proviided, but a nucleotide sequence was provided </span>
					<span class="c">#translate nucloetid to amino acid..this can result in some potential problems with PRODUCTIVITY determination IF using GENERAL PRODUCTIVTY function rule </span>
					<span class="k">try</span><span class="p">:</span>
						<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">full_nt_field</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
						<span class="n">my_line</span><span class="p">[</span><span class="n">full_aa_field</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">full_nt_field</span><span class="p">][:</span><span class="n">end</span><span class="p">],</span><span class="n">generic_dna</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">())</span>
					<span class="k">except</span><span class="p">:</span>
						<span class="k">print</span><span class="p">(</span><span class="s">&#39;Error type 2: problem translating amino acid =&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">full_nt_field</span><span class="p">]))</span>
						<span class="c">#annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,seq,id,&#39;&#39;,&#39;&#39;,&#39;&#39;])+&#39;\n&#39;)						</span>
						<span class="c">#no_result+=1</span>
						<span class="c">#continue</span>
						<span class="n">my_line</span><span class="p">[</span><span class="n">full_aa_field</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
						<span class="c">#no cdr3 found </span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">cdr3_field</span><span class="p">]):</span>											
				<span class="c">#write to temperoary file </span>
				<span class="n">annotation_file_writing</span><span class="p">[</span><span class="n">fnum</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span><span class="n">seq</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>													
				<span class="n">no_cdr3_error</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">continue</span>				
									
			<span class="c">#maintain all vgenes as a list </span>
			<span class="c">#Process genes and only extract the GENE from each of the fields (that is ignore the alleles &#39;*01&#39;)</span>
			<span class="n">Vgene</span> <span class="o">=</span> <span class="n">ProcessGene</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">vgene_field</span><span class="p">])</span><span class="c">#.split(&#39;,&#39;)#[0]</span>
			<span class="n">Jgene</span> <span class="o">=</span> <span class="n">ProcessGene</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">jgene_field</span><span class="p">])</span><span class="c">#.split(&#39;,&#39;)#[0]			</span>
			<span class="n">Dgene</span> <span class="o">=</span> <span class="n">ProcessGene</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">dgene_field</span><span class="p">])</span><span class="c">#.split(&#39;,&#39;)#[0]				</span>
			<span class="c">#Unlike the above change for genes, only keep the first isotype in the list </span>
			<span class="n">isotype</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">isotype_field</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>			
			<span class="c">#figure out locus using vgene call 														</span>
		
			<span class="k">if</span> <span class="n">Vgene</span><span class="p">:</span>
				<span class="c">#use vgene to determine locus </span>
				<span class="n">locus</span> <span class="o">=</span> <span class="n">Vgene</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>						
			<span class="k">elif</span> <span class="n">Jgene</span><span class="p">:</span>
				<span class="c">#if no vgene is present, then use jgene</span>
				<span class="n">locus</span> <span class="o">=</span> <span class="n">Jgene</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>			
			<span class="k">else</span><span class="p">:</span>
				<span class="c">#ignore using D gene</span>
				<span class="n">locus</span><span class="o">=</span><span class="s">&#39;&#39;</span>			
			
			<span class="n">chain</span> <span class="o">=</span> <span class="s">&#39;N/A&#39;</span>			
		
			<span class="c">#the provided file defines recombination/VDJ or VJ chain </span>
			<span class="k">if</span> <span class="n">my_line</span><span class="p">[</span><span class="n">recomb_field</span><span class="p">]</span> <span class="ow">and</span> <span class="n">my_line</span><span class="p">[</span><span class="n">recomb_field</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;VDJ&#39;</span><span class="p">,</span><span class="s">&#39;VJ&#39;</span><span class="p">]:</span>
				<span class="n">chain</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">recomb_field</span><span class="p">]</span>
			<span class="k">elif</span> <span class="n">locus</span><span class="p">:</span>				
				<span class="c">#shoudl return &#39;VDJ&#39; or &#39;VJ&#39; based on LOCUS var</span>
				<span class="k">for</span> <span class="n">possible_chains</span><span class="p">,</span><span class="n">values</span> <span class="ow">in</span> <span class="n">chain_call</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>			
					<span class="k">if</span> <span class="n">locus</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
						<span class="n">chain</span> <span class="o">=</span> <span class="n">possible_chains</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
						<span class="k">break</span>		
			
										
						
			<span class="c">#chain could not be determind with provided locus </span>
			<span class="k">if</span> <span class="n">chain</span> <span class="o">==</span> <span class="s">&#39;N/A&#39;</span><span class="p">:</span>		
				<span class="n">this_chain</span><span class="o">=</span><span class="s">&#39;&#39;</span>
				<span class="n">invalid_chain</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">print</span> <span class="s">&#39;Error type 1&#39;</span> <span class="c">#isotype is mislabeled</span>
				<span class="k">print</span> <span class="n">my_line</span>			
				<span class="c">#write to temperoary file </span>
				<span class="c">#again write this sequence to the annotation file, but we have no information for its </span>
				<span class="c">#annoated paired data				</span>
				<span class="n">annotation_file_writing</span><span class="p">[</span><span class="n">fnum</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span><span class="n">seq</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>													
				<span class="k">continue</span>
			
			<span class="c">#this is the recombination type of the current sequence </span>
			<span class="n">rtype</span><span class="o">=</span><span class="n">chain</span>						
						
			<span class="c">#unproductive</span>
			<span class="k">if</span> <span class="n">productivity_function_call</span><span class="p">(</span><span class="n">my_line</span><span class="p">)</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>																									
				<span class="c">#write to temperoary file </span>
				<span class="n">annotation_file_writing</span><span class="p">[</span><span class="n">fnum</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span><span class="n">seq</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="n">rtype</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>										
				<span class="n">not_productive</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">continue</span>
								
			<span class="n">CDR3</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">cdr3_field</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
			<span class="n">Len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">CDR3</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>	
						
			<span class="c">#get SHM info </span>
			<span class="k">if</span> <span class="n">my_line</span><span class="p">[</span><span class="n">mut_field</span><span class="p">]:</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">Mut</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">mut_field</span><span class="p">]),</span><span class="mi">3</span><span class="p">)</span>
				<span class="k">except</span><span class="p">:</span>
					<span class="k">if</span> <span class="s">&#39;(&#39;</span> <span class="ow">in</span> <span class="n">my_line</span><span class="p">[</span><span class="n">mut_field</span><span class="p">]:</span>
						<span class="k">try</span><span class="p">:</span>
							<span class="n">Mut</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">my_line</span><span class="p">[</span><span class="n">mut_field</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()),</span><span class="mi">3</span><span class="p">)</span>
						<span class="k">except</span><span class="p">:</span>
							<span class="n">Mut</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
					<span class="k">else</span><span class="p">:</span>				
						<span class="n">Mut</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>		
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Mut</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
			
			<span class="c">#get isotype </span>
			<span class="n">isotype</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">isotype_field</span><span class="p">]</span>			
			<span class="n">seq</span><span class="o">=</span><span class="n">my_line</span><span class="p">[</span><span class="n">seq_field</span><span class="p">]</span>						
			<span class="n">v_scores</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">vgene_scores</span><span class="p">]</span>
			<span class="n">d_scores</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">dgene_scores</span><span class="p">]</span>
			<span class="n">j_scores</span> <span class="o">=</span> <span class="n">my_line</span><span class="p">[</span><span class="n">jgene_scores</span><span class="p">]</span>
			
			<span class="n">passed_filter</span><span class="o">+=</span><span class="mi">1</span>
						
			<span class="c">#This specific sequence passed all filters. Write this sequence to a file that can be sorted afterwards by its &#39;full code&#39; afterwards</span>
			<span class="n">temp_array</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">num_elem_stored</span><span class="p">)</span>			
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;CDR3_SEQ&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">CDR3</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;VGENE&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">Vgene</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;DGENE&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">Dgene</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;JGENE&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">Jgene</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;LOCUS&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">locus</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;MUT&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">Mut</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;CDR3_LEN&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">Len</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;AB_SEQ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">my_line</span><span class="p">[</span><span class="n">full_nt_field</span><span class="p">]</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;CHAIN_CALL&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">chain</span> 		
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;ISOTYPE&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">isotype</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;VSCORES&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v_scores</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;DSCORES&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">d_scores</span>
			<span class="n">temp_array</span><span class="p">[</span><span class="n">ab_field_loc</span><span class="p">[</span><span class="s">&#39;JSCORES&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j_scores</span>
			
			<span class="n">temp_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fullcode</span><span class="p">)</span>			
			<span class="c">#now store all of the importat fields we want to use for pairing to the temp file defined by temp_seq_data</span>
			<span class="n">temp_seq_data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">temp_array</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
			<span class="c">#store paired_id result for this sequence in the annotation file </span>
			<span class="n">annotation_file_writing</span><span class="p">[</span><span class="n">fnum</span><span class="p">][</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span><span class="n">seq</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="n">rtype</span><span class="p">,</span><span class="n">fullcode</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>													
				
		<span class="k">if</span> <span class="n">num_eof</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">):</span><span class="c">#all files have been read through</span>
			<span class="n">at_least_one_file_open</span><span class="o">=</span><span class="bp">False</span> 	
	
	<span class="n">temp_seq_data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	
	<span class="k">for</span> <span class="n">anot_files</span> <span class="ow">in</span> <span class="n">annotation_file_writing</span><span class="p">:</span>
		<span class="n">anot_files</span><span class="p">[</span><span class="s">&#39;buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	
	
	<span class="c">#ok the temp file was made. it only consits of sequences which passed the filters above. We now need to sort this file by the MISEQ id and group sequences into proper VH-VL pairs </span>
	<span class="p">[</span><span class="n">mapping_dict</span><span class="p">,</span><span class="n">num_paired</span><span class="p">,</span><span class="n">successful_pair</span><span class="p">,</span><span class="n">nonpaired_len</span><span class="p">,</span><span class="n">locus_pairing_error</span><span class="p">,</span><span class="n">num_r1_r2_found</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">,</span><span class="n">Hchain_pairing_error</span><span class="p">,</span><span class="n">Lchain_pairing_error</span><span class="p">]</span> <span class="o">=</span> <span class="n">parse_sorted_paired_file</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">)</span>
	<span class="n">num_unique_cdrh3_l3_pair_above1</span> <span class="o">=</span> <span class="n">useful</span><span class="o">.</span><span class="n">file_line_count</span><span class="p">(</span><span class="n">usearch_cluster_file</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
	<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pairing_temp_file</span><span class="p">)</span>				
				
	<span class="k">print</span> <span class="s">&#39;Summary: &#39;</span>
	<span class="k">print</span> <span class="s">&#39;Parsed through {0} sequences&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">total_seqs</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;{0} ({1}%) sequences did not pass filters: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">total_seqs</span><span class="o">-</span><span class="n">passed_filter</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>  <span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">total_seqs</span><span class="o">-</span><span class="n">passed_filter</span><span class="p">))</span><span class="o">/</span><span class="n">total_seqs</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">total_seqs</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span> <span class="p">)</span>
	<span class="c">#print &#39;		{0} sequences did not have an antibody sequence&#39;.format(str(no_result))</span>
	<span class="k">print</span> <span class="s">&#39;		{0} sequences did not have a cdr3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">no_cdr3_error</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;		{0} sequences were not productive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">not_productive</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;		{0} sequences had an unidentifiable chain type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">invalid_chain</span><span class="p">))</span>

	<span class="k">print</span> <span class="s">&#39;{0} ({1}%) sequences were not paired successfully: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">passed_filter</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>  <span class="mi">100</span><span class="o">*</span> <span class="p">((</span><span class="n">passed_filter</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">))</span>  <span class="o">/</span><span class="n">total_seqs</span><span class="p">)</span> <span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">total_seqs</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	<span class="k">print</span> <span class="s">&#39;		{0} sequences had different LOCUS calls&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">locus_pairing_error</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;		{0} sequences were paired as VH-VH&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Hchain_pairing_error</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;		{0} sequences were paired as VL-VL&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lchain_pairing_error</span><span class="p">))</span>		
	<span class="k">print</span> <span class="s">&#39;		{0} sequences did not have a corresponding R1-R2 pair read&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nonpaired_len</span><span class="p">))</span>
	

	<span class="k">print</span> <span class="s">&#39;{0} ({1}%) sequences were successfully paired: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">)</span><span class="o">/</span><span class="n">total_seqs</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">total_seqs</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	<span class="k">print</span> <span class="s">&#39;This leaves {0} identified VH-VL sequence-pairs: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">successful_pair</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;VH-VL sequence-pairs were collapsed into {0} sequences containing unique CDRH3-CDRL3 pairs: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;{0} ({1}%) of these unique pairs were observed more than once&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="o">/</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">num_unique_cdrh3_l3_pair</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	
	
	<span class="k">return</span> <span class="p">[</span><span class="n">total_seqs</span><span class="p">,</span><span class="n">passed_filter</span><span class="p">,</span><span class="n">no_result</span><span class="p">,</span><span class="n">no_cdr3_error</span><span class="p">,</span><span class="n">not_productive</span><span class="p">,</span><span class="n">invalid_chain</span><span class="p">,</span><span class="n">successful_pair</span><span class="p">,</span><span class="n">Hchain_pairing_error</span><span class="p">,</span><span class="n">Lchain_pairing_error</span><span class="p">,</span><span class="n">nonpaired_len</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="p">,</span><span class="n">locus_pairing_error</span><span class="p">,</span><span class="n">annotation_file_writing</span><span class="p">,</span><span class="n">mapping_dict</span><span class="p">]</span>
	</div>
<div class="viewcode-block" id="Compile_Clusters"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.Compile_Clusters">[docs]</a><span class="k">def</span> <span class="nf">Compile_Clusters</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">cluster_val</span><span class="p">):</span>	
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	</span>
<span class="sd">		Generates a compiled output file summarizing which CDRH3 clusters were made. </span>
<span class="sd">		Reports the cluster size and extra features such as diversity and dominance to determine whether clustering makes sense for H-L pair </span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">global</span> <span class="n">clustered_final_output_file</span>
	
	<span class="n">clustered_final_output</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">clustered_final_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_val</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.txt&#39;</span><span class="p">,</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>		
	<span class="n">header_output</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Total Counts&#39;</span><span class="p">,</span><span class="s">&#39;Indiv_Count&#39;</span><span class="p">,</span><span class="s">&#39;Dominance&#39;</span><span class="p">,</span> <span class="s">&#39;Confidence&#39;</span><span class="p">,</span> <span class="s">&#39;Diversity (Shannon)&#39;</span><span class="p">,</span><span class="s">&#39;Diversity (Simpsons)&#39;</span><span class="p">,</span> <span class="s">&#39;Cluster size&#39;</span><span class="p">,</span> <span class="s">&#39;CDRH3 AA&#39;</span><span class="p">,</span> <span class="s">&#39;CDRL3 AA&#39;</span><span class="p">,</span> <span class="s">&#39;CDRH3&#39;</span><span class="p">,</span><span class="s">&#39;CDRL3&#39;</span><span class="p">,</span><span class="s">&#39;VHgene&#39;</span><span class="p">,</span><span class="s">&#39;DHgene&#39;</span><span class="p">,</span><span class="s">&#39;JHgene&#39;</span><span class="p">,</span><span class="s">&#39;VLgene&#39;</span><span class="p">,</span><span class="s">&#39;JLgene&#39;</span><span class="p">,</span><span class="s">&#39;IgH&#39;</span><span class="p">,</span><span class="s">&#39;IgL&#39;</span><span class="p">,</span><span class="s">&#39;Hmut_avg&#39;</span><span class="p">,</span><span class="s">&#39;Hmut_std&#39;</span><span class="p">,</span><span class="s">&#39;L_mut_avg&#39;</span><span class="p">,</span><span class="s">&#39;Lmut_std&#39;</span><span class="p">,</span><span class="s">&#39;HLen&#39;</span><span class="p">,</span><span class="s">&#39;LLen&#39;</span><span class="p">,</span><span class="s">&#39;Hisotype&#39;</span><span class="p">,</span><span class="s">&#39;Lisotype&#39;</span><span class="p">]</span>
	<span class="n">clustered_final_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header_output</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
	
	<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">clustered_dict_raw</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>	
		<span class="n">best_hit</span> <span class="o">=</span> <span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)</span>
		<span class="c">#total_counts found from all CDR3s in a single cluster </span>
		<span class="n">total_counts</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
				
		<span class="n">indiv_count</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c">#total count for the BESt/highest populated CDR3 in the cluster/largest size</span>
		<span class="n">CDRH3_trans</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">CDRL3_trans</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
		<span class="n">CDRH3</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
		<span class="n">CDRL3</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
		<span class="n">VHgene</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
		<span class="n">DHgene</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
		<span class="n">JHgene</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>		
		<span class="n">VLgene</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
		<span class="n">JLgene</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
		<span class="n">IgH</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
		<span class="n">IgL</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
						
		
		<span class="n">HLen</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
		<span class="n">LLen</span><span class="o">=</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span>
		
		<span class="n">HIso</span> <span class="o">=</span> <span class="n">best_hit</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span>
		<span class="n">LIso</span> <span class="o">=</span> <span class="n">best_hit</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span>
		
		<span class="n">Hmut_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>
		<span class="n">Hmut_sum_sq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">21</span><span class="p">])</span>
		<span class="n">Hmut_count</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">22</span><span class="p">])</span>
		
		<span class="n">Lmut_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">23</span><span class="p">])</span>
		<span class="n">Lmut_sum_sq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">24</span><span class="p">])</span>
		<span class="n">Lmut_count</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">best_hit</span><span class="p">[</span><span class="mi">25</span><span class="p">])</span>
						
		<span class="n">dominance</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">indiv_count</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">total_counts</span><span class="p">)</span> <span class="c">#what percent of the TOP cdr3 contributes to the TOTAL count </span>
		
		<span class="n">freq</span> <span class="o">=</span> <span class="n">indiv_count</span><span class="o">/</span><span class="n">total_counts</span>
		<span class="n">diversity</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
		<span class="n">diversity_v2</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
		
		<span class="n">cluster_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
		
		<span class="k">if</span> <span class="n">cluster_size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">indiv_count2</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="c">#this is the counts for the second best CDR3</span>
			<span class="n">confidence</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="mi">100</span><span class="o">*</span><span class="n">indiv_count2</span><span class="o">/</span><span class="n">indiv_count</span><span class="p">)</span> <span class="c">#confidence =&gt; ratio of best cdr3 count/2nd best cdr3 count									</span>
			<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
				<span class="n">other_hits</span> <span class="o">=</span> <span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)</span>
				<span class="n">Hmut_sum</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>
				<span class="n">Hmut_sum_sq</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">21</span><span class="p">])</span>
				<span class="n">Hmut_count</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">22</span><span class="p">])</span>
				<span class="n">Lmut_sum</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">23</span><span class="p">])</span>
				<span class="n">Lmut_sum_sq</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">24</span><span class="p">])</span>
				<span class="n">Lmut_count</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">25</span><span class="p">])</span>
				<span class="n">freq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other_hits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">total_counts</span>
				<span class="n">diversity</span><span class="o">+=</span><span class="n">freq</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
				<span class="n">diversity_v2</span><span class="o">+=</span><span class="nb">pow</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">diversity</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">diversity</span><span class="p">)</span>
			<span class="n">diversity_v2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">diversity_v2</span>			
			<span class="k">if</span> <span class="n">Hmut_count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">Hmut_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Hmut_sum</span><span class="o">/</span><span class="n">Hmut_count</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Hmut_avg</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>			
			<span class="k">if</span> <span class="n">Hmut_count</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">h1</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Hmut_sum_sq</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
				<span class="n">h2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">Hmut_sum</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">Hmut_count</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>				
				<span class="n">Hmut_var</span> <span class="o">=</span>  <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span> <span class="p">(</span><span class="n">h1</span><span class="o">-</span><span class="n">h2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Hmut_count</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">0.5</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Hmut_var</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>			
			<span class="k">if</span> <span class="n">Lmut_count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">Lmut_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Lmut_sum</span><span class="o">/</span><span class="n">Lmut_count</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>			
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Lmut_avg</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>				
			<span class="c">#shm variance -&gt; sum of squares formulat =&gt; sum(vals^2)-(sum(vals)^2)/counts)</span>
			<span class="k">if</span> <span class="n">Lmut_count</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">l1</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">Lmut_sum_sq</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">Lmut_sum</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">Lmut_count</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>				
				<span class="n">Lmut_var</span> <span class="o">=</span>  <span class="nb">round</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span> <span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Lmut_count</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">0.5</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>				
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Lmut_var</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>			
		<span class="k">else</span><span class="p">:</span>				
			<span class="n">Hmut_avg</span> <span class="o">=</span> <span class="n">best_hit</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
			<span class="n">Hmut_var</span> <span class="o">=</span> <span class="n">best_hit</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
			<span class="n">Lmut_avg</span> <span class="o">=</span> <span class="n">best_hit</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span>
			<span class="n">Lmut_var</span> <span class="o">=</span> <span class="n">best_hit</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>
			<span class="n">confidence</span><span class="o">=</span><span class="mi">100</span>
			<span class="n">diversity</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">diversity_v2</span> <span class="o">=</span> <span class="mi">1</span>
						
		<span class="k">try</span><span class="p">:</span> <span class="n">CDRH3_trans</span><span class="o">=</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">CDRH3</span><span class="p">,</span><span class="n">generic_dna</span><span class="p">))</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
		<span class="k">except</span><span class="p">:</span> <span class="n">CDRH3</span><span class="o">=</span> <span class="s">&#39;translation error&#39;</span>
		<span class="k">try</span><span class="p">:</span> <span class="n">CDRL3_trans</span><span class="o">=</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">CDRL3</span><span class="p">,</span><span class="n">generic_dna</span><span class="p">))</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
		<span class="k">except</span><span class="p">:</span> <span class="n">CDRL3</span><span class="o">=</span> <span class="s">&#39;translation error&#39;</span>
		
		<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">total_counts</span><span class="p">,</span><span class="n">indiv_count</span><span class="p">,</span><span class="n">dominance</span><span class="p">,</span><span class="n">confidence</span><span class="p">,</span><span class="n">diversity</span><span class="p">,</span><span class="n">diversity_v2</span><span class="p">,</span><span class="n">cluster_size</span><span class="p">,</span><span class="n">CDRH3_trans</span><span class="p">,</span><span class="n">CDRL3_trans</span><span class="p">,</span><span class="n">CDRH3</span><span class="p">,</span><span class="n">CDRL3</span><span class="p">,</span><span class="n">VHgene</span><span class="p">,</span><span class="n">DHgene</span><span class="p">,</span><span class="n">JHgene</span><span class="p">,</span><span class="n">VLgene</span><span class="p">,</span><span class="n">JLgene</span><span class="p">,</span><span class="n">IgH</span><span class="p">,</span><span class="n">IgL</span><span class="p">,</span><span class="n">Hmut_avg</span><span class="p">,</span><span class="n">Hmut_var</span><span class="p">,</span><span class="n">Lmut_avg</span><span class="p">,</span><span class="n">Lmut_var</span><span class="p">,</span><span class="n">HLen</span><span class="p">,</span><span class="n">LLen</span><span class="p">,</span><span class="n">HIso</span><span class="p">,</span> <span class="n">LIso</span><span class="p">]</span>
		<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>		
		<span class="n">clustered_final_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>	
</div>
<div class="viewcode-block" id="GenerateAnnotationFile"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.GenerateAnnotationFile">[docs]</a><span class="k">def</span> <span class="nf">GenerateAnnotationFile</span><span class="p">(</span><span class="n">annotated_file_lists</span><span class="p">,</span><span class="n">cluster_val</span><span class="p">,</span><span class="n">mapping_dict</span><span class="p">,</span><span class="n">usearch_output_file</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates a file for inserting VH-VL paired and cluster data to the database</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">global</span> <span class="n">clustered_final_output_file</span>
	<span class="k">global</span> <span class="n">annotation_headers</span>
	<span class="n">delimiter</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span>
	
	<span class="n">cdrh3_l3_pair</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">unique_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span>
	<span class="n">command_string</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">&#39;VH-VL paired cluster cutoffs&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_val</span><span class="p">)})</span>	
	
	<span class="c">#now open the finalized cluster file. </span>
	<span class="c">#for each row in the file, store </span>
	<span class="c">#	seed name, confidence, dominance</span>
	<span class="n">final_file</span> <span class="o">=</span> <span class="n">readfile</span><span class="o">.</span><span class="n">immunogrepFile</span><span class="p">(</span><span class="n">clustered_final_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_val</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.txt&#39;</span><span class="p">,</span><span class="s">&#39;TAB&#39;</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">each_cluster</span> <span class="ow">in</span> <span class="n">final_file</span><span class="o">.</span><span class="n">read</span><span class="p">():</span>
		<span class="n">cdr3_h3_seq</span> <span class="o">=</span> <span class="n">each_cluster</span><span class="p">[</span><span class="s">&#39;CDRH3&#39;</span><span class="p">]</span>
		<span class="n">cdr3_l3_seq</span> <span class="o">=</span> <span class="n">each_cluster</span><span class="p">[</span><span class="s">&#39;CDRL3&#39;</span><span class="p">]</span>
		<span class="n">cdrh3_l3_pair</span><span class="p">[</span><span class="n">cdr3_h3_seq</span><span class="o">+</span><span class="s">&#39;:&#39;</span><span class="o">+</span><span class="n">cdr3_l3_seq</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;con&#39;</span><span class="p">:</span><span class="n">each_cluster</span><span class="p">[</span><span class="s">&#39;Confidence&#39;</span><span class="p">],</span><span class="s">&#39;dom&#39;</span><span class="p">:</span><span class="n">each_cluster</span><span class="p">[</span><span class="s">&#39;Dominance&#39;</span><span class="p">]}</span>
			
	<span class="c">#mapping_dict =&gt; key = unique idnetifier from miseq read (fullcode); value = &#39;CDRH3/CDRL3&#39; pair. </span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
		<span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cdrh3_l3_pair</span> <span class="ow">and</span> <span class="s">&#39;key&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cdrh3_l3_pair</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
			<span class="n">cdrh3_l3_pair</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="s">&#39;::&#39;</span><span class="o">+</span><span class="n">unique_str</span>
	
	
	<span class="c">#cdrh3_l3_pair =&gt; KEY = unique CDRH3/L3 pair, value = unique_identifier from miseq read + a random number appended (this will make sure cluster groups in database are different when paired with different files)	</span>
	<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">cdr3_clusters</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">usearch_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_val</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.uc&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_in</span><span class="p">:</span>
		<span class="c">#open the clustering output file </span>
		<span class="k">for</span> <span class="n">line_text</span> <span class="ow">in</span> <span class="n">f_in</span><span class="p">:</span>			
			
			<span class="n">line_text</span> <span class="o">=</span> <span class="n">line_text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
			<span class="n">line</span> <span class="o">=</span> <span class="n">line_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
		
			<span class="n">SorH</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Seed or Hit</span>
			<span class="n">seed_parent</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>												
			
			<span class="k">if</span> <span class="s">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="mi">8</span><span class="p">]:</span>
				<span class="n">info</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">info</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
			
			<span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)</span>
			<span class="n">cdrh3_nt</span><span class="o">=</span><span class="n">info</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
			<span class="n">cdrl3_nt</span><span class="o">=</span><span class="n">info</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>			
			
			<span class="n">cdr3_clusters</span><span class="p">[</span><span class="n">cdrh3_nt</span><span class="o">+</span><span class="s">&#39;:&#39;</span><span class="o">+</span><span class="n">cdrl3_nt</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed_parent</span>
			<span class="k">if</span> <span class="n">SorH</span><span class="o">!=</span><span class="s">&#39;S&#39;</span> <span class="ow">and</span> <span class="n">SorH</span><span class="o">!=</span><span class="s">&#39;H&#39;</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="n">c1</span><span class="o">+=</span><span class="mi">1</span>
			<span class="k">if</span> <span class="n">SorH</span><span class="o">==</span><span class="s">&#39;S&#39;</span><span class="p">:</span>								
				<span class="c">#if cdrh3+&#39;:&#39;+cdrl3 in cdrh3_l3_pair:</span>
				<span class="n">d</span><span class="p">[</span><span class="n">seed_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdrh3_l3_pair</span><span class="p">[</span><span class="n">cdrh3_nt</span><span class="o">+</span><span class="s">&#39;:&#39;</span><span class="o">+</span><span class="n">cdrl3_nt</span><span class="p">]</span>
				<span class="c">#else:</span>
				<span class="c">#	d[seed_parent] = &#39;&#39;							</span>
		
	
	<span class="n">paired_id_col_field</span> <span class="o">=</span> <span class="n">annotation_headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;PairedID&#39;</span><span class="p">)</span>
	<span class="n">paired_cluster_col_field</span> <span class="o">=</span> <span class="n">annotation_headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;PairedClusterId&#39;</span><span class="p">)</span>
	<span class="n">dom_field</span> <span class="o">=</span> <span class="n">annotation_headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;Dominance&#39;</span><span class="p">)</span>
	<span class="n">con_field</span> <span class="o">=</span> <span class="n">annotation_headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;Confidence&#39;</span><span class="p">)</span>
	<span class="n">all_fields</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotation_headers</span><span class="p">)</span>
	<span class="n">command_field</span> <span class="o">=</span> <span class="n">annotation_headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;Command&#39;</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">file_info</span> <span class="ow">in</span> <span class="n">annotated_file_lists</span><span class="p">:</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_info</span><span class="p">[</span><span class="s">&#39;filename&#39;</span><span class="p">],</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
			<span class="n">line_count</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">lines</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_info</span><span class="p">[</span><span class="s">&#39;filename&#39;</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.temp&#39;</span><span class="p">):</span>
				<span class="n">line_count</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="k">if</span> <span class="n">line_count</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
					<span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>
				<span class="n">output</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">all_fields</span>
				<span class="n">output</span><span class="p">[</span><span class="n">command_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_string</span>
				<span class="k">for</span> <span class="n">c1</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
					<span class="n">output</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
				<span class="n">paired_id</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">paired_id_col_field</span><span class="p">]</span>
				<span class="k">if</span> <span class="n">paired_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="p">:</span>					
					<span class="n">paired_id</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="n">output</span><span class="p">[</span><span class="n">paired_cluster_col_field</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
					<span class="n">output</span><span class="p">[</span><span class="n">paired_id_col_field</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;&#39;</span>
				<span class="k">else</span><span class="p">:</span>										
					<span class="n">pair</span> <span class="o">=</span> <span class="n">mapping_dict</span><span class="p">[</span><span class="n">paired_id</span><span class="p">]</span>					
					<span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">cdr3_clusters</span><span class="p">:</span>						
						<span class="n">output</span><span class="p">[</span><span class="n">paired_cluster_col_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">cdr3_clusters</span><span class="p">[</span><span class="n">pair</span><span class="p">]][</span><span class="s">&#39;key&#39;</span><span class="p">]</span>
						<span class="n">output</span><span class="p">[</span><span class="n">dom_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">cdr3_clusters</span><span class="p">[</span><span class="n">pair</span><span class="p">]][</span><span class="s">&#39;dom&#39;</span><span class="p">]</span>
						<span class="n">output</span><span class="p">[</span><span class="n">con_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">cdr3_clusters</span><span class="p">[</span><span class="n">pair</span><span class="p">]][</span><span class="s">&#39;con&#39;</span><span class="p">]</span>
				<span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
				
		<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">file_info</span><span class="p">[</span><span class="s">&#39;filename&#39;</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.temp&#39;</span><span class="p">)</span>
				</div>
<div class="viewcode-block" id="WriteSummaryFile"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.WriteSummaryFile">[docs]</a><span class="k">def</span> <span class="nf">WriteSummaryFile</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">,</span><span class="n">total_seqs</span><span class="p">,</span><span class="n">passed_filter</span><span class="p">,</span><span class="n">no_result</span><span class="p">,</span><span class="n">no_cdr3_error</span><span class="p">,</span><span class="n">not_productive</span><span class="p">,</span><span class="n">invalid_chain</span><span class="p">,</span><span class="n">successful_pair</span><span class="p">,</span><span class="n">Hchain_pairing_error</span><span class="p">,</span><span class="n">Lchain_pairing_error</span><span class="p">,</span><span class="n">nonpaired_len</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="p">,</span><span class="n">locus_pairing_error</span><span class="p">,</span><span class="n">cluster</span><span class="p">,</span><span class="n">num_clustered</span><span class="p">):</span>
	<span class="c">#MAKE THIS SPECIAL IF ITS IMGT FILES (MERGE FILES INTO ONE GROUP NAME)	</span>
	<span class="n">file_path_summary</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="n">f</span><span class="o">+</span><span class="s">&#39;,&#39;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">annotated_file_paths</span><span class="p">]</span>

	<span class="k">global</span> <span class="n">summary_file</span>
	<span class="n">summary</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span>	<span class="n">summary_file</span><span class="p">,</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
	<span class="c">#Write useful information in summary file	</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Data generated using </span><span class="si">%s</span><span class="s"> on: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">pairing_version</span><span class="p">,</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;***************************************************</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;***************   Summary Report  *****************</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;***************************************************</span><span class="se">\n\n\n</span><span class="s">&quot;</span><span class="p">)</span>
	
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;The following input files were used to run pairing analysis:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_path_summary</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n\n\n</span><span class="s">&#39;</span><span class="p">)</span>
	
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Parsed through {0} sequences</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">total_seqs</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{0} ({1}%) sequences did not pass filters:</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">total_seqs</span><span class="o">-</span><span class="n">passed_filter</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>  <span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">total_seqs</span><span class="o">-</span><span class="n">passed_filter</span><span class="p">))</span><span class="o">/</span><span class="n">total_seqs</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span> <span class="k">if</span> <span class="n">total_seqs</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences did not have an antibody sequence</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">no_result</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences did not have a cdr3</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">no_cdr3_error</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences were not productive</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">not_productive</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences had an unidentifiable chain type</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">invalid_chain</span><span class="p">)))</span>
		
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{0} ({1}%) sequences were not paired successfully:</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">passed_filter</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>  <span class="mi">100</span><span class="o">*</span> <span class="p">((</span><span class="n">passed_filter</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">))</span>  <span class="o">/</span><span class="n">total_seqs</span><span class="p">)</span> <span class="p">,</span><span class="mi">1</span><span class="p">)))</span> <span class="k">if</span> <span class="n">total_seqs</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences had different LOCUS calls</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">locus_pairing_error</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences were paired as VH-VH</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Hchain_pairing_error</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences were paired as VL-VL</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lchain_pairing_error</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">{0} sequences did not have a corresponding R1-R2 pair read</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nonpaired_len</span><span class="p">)))</span>
	<span class="c">#summary.write(&#39;\t{0} sequences did not have a corresponding R1-R2 pair read that passed filters]\n&#39;.format(str(bad_r1_pair)))</span>
	
		
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{0} ({1}%) sequences were successfully paired:</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">)</span><span class="o">/</span><span class="n">total_seqs</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span> <span class="k">if</span> <span class="n">total_seqs</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;This leaves {0} identified VH-VL sequence-pairs</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">successful_pair</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;VH-VL sequence-pairs were collapsed into {0} sequences containing unique CDRH3-CDRL3 pairs</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">)))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{0} ({1}%) of these unique pairs were observed more than once</span><span class="se">\n\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="o">/</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span> <span class="k">if</span> <span class="n">num_unique_cdrh3_l3_pair</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
	
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Total number of raw paired and unpaired sequences: </span><span class="si">%d</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">passed_filter</span><span class="p">))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Number of raw unpaired sequences: </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">passed_filter</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Number of raw VH:VL sequences: </span><span class="si">%d</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">successful_pair</span><span class="p">))</span>
	
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Number VH:VH pairs: </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Hchain_pairing_error</span><span class="p">))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Number VL:VL pairs: </span><span class="si">%d</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Lchain_pairing_error</span><span class="p">))</span>
	
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Number of unique CDRH3 sequences: </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;CDRH3 sequences were clustered using the following cluster cutoffs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Cluster Cutoff</span><span class="se">\t</span><span class="s">Number of clustered sequences</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
	
	<span class="k">for</span> <span class="n">cpos</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span>
		<span class="n">summary</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_clustered</span><span class="p">[</span><span class="n">cpos</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
	
	<span class="c">#summary.write(&quot;\t Number of clustered sequences to %d%% CDRH3 identity: %d\n&quot; %(cluster*100,num_clustered))</span>
	<span class="n">summary</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


</div>
<div class="viewcode-block" id="RunPairing"><a class="viewcode-back" href="../V.html#immunogrep_gglab_pairing.RunPairing">[docs]</a><span class="k">def</span> <span class="nf">RunPairing</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">,</span><span class="n">analysis_method</span><span class="p">,</span><span class="n">output_folder_path</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="n">prefix_output_files</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">annotated_file_formats</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">field_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">cluster_cutoff</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.96</span><span class="p">,</span><span class="mf">0.96</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">annotation_cluster_setting</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">use_low_memory</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span><span class="n">files_from_igrep_database</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">productivity_function</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		</span>
<span class="sd">		Brief Description </span>
<span class="sd">		</span>
<span class="sd">		This is the main function for pairing VH-VL antibody data using the Georgiou lab pipeline. The pairing function is not dependent on a specific file type/format and will pair sequences using any files passed into the field annotated_file_paths.</span>
<span class="sd">		Pairing of VH-VL antibodies is performed by grouping together sequences by their MISEQ header (Miseq id). This program should only be used to pair &#39;paired end NGS data&#39;. That is, we assume sequences come from MISEQ paired-end sequences containing complementary R1/R2 header names.</span>
<span class="sd">		</span>
<span class="sd">		**General algorithm**</span>
<span class="sd">		</span>
<span class="sd">		The pairing program follows the following steps: </span>
<span class="sd">			Step A: Go through the provided AB annotated files (IMGT, parsed IGBLAST files, etc), and filter out sequences that lack good results </span>

<span class="sd">				1) Loop through all sequences provided in all files </span>
<span class="sd">				2) Only select sequences that have a sequence header. Extract the MISEQ ID from the sequence header. </span>
<span class="sd">				3) Filter out sequences that do not have a cdr3 sequence </span>
<span class="sd">				4) Filter out sequences that are deemed &#39;unproductive&#39; using our Productivity Rules, or a custom productivity rule provided by user </span>
<span class="sd">			</span>
<span class="sd">			Step B: Parse the filtered file </span>

<span class="sd">				1) Sort the generated outputfile by the MISEQ ID</span>
<span class="sd">				2) Only consider sequences where both the R1 and R2 read (sequences with identicals MISEQ ID) passed all filter steps in Step A </span>
<span class="sd">				3) Filter out sequences that</span>

<span class="sd">					a) are found to be VH-VH pairs</span>
<span class="sd">					b) are found to be VL-VL pairs</span>
<span class="sd">					c) are found to be pairs of calls from different loci (i.e. IGH-TRA )</span>

<span class="sd">				4) All sequences that pass the above rules are considered to be proper VH-VL paired antibodies. We store these MISEQ ids inside &#39;annnotation files&#39; that can be used to update the database with properly paired sequences</span>
<span class="sd">			</span>
<span class="sd">			Step C: Group together CDRH3-CDRL3 pairs</span>

<span class="sd">				1) We group together sequences with identical CDRH3-CDRL3 pairs from the filtered VH-VL paired sequences in Step B</span>
<span class="sd">				2) For each CDRH3-CDRL3 group, we calculate the following as extra information for the group</span>

<span class="sd">					a) average SHM (if an SHM field is provided) and standard deviation SHM </span>
<span class="sd">					b) mode of V,D, and J gene calls (if V, D, or J genes are provided). Mode of gene calls are based on top genes only (genes whose alignment scores are equal to the top alignment score)</span>
<span class="sd">					c) All observed unique isotypes (if isotypes are provided)</span>
<span class="sd">			</span>
<span class="sd">			Step D: Cluster CDRH3-CDRL3 pairs</span>

<span class="sd">				1) Unique CDRH3-CDRL3 paired sequences are sorted by their total counts (number of sequences containing respective CDRH3-CDRL3 pair)</span>
<span class="sd">				2) The results from each CDRH3-CDRL3, pair whose counts are found &gt; 1 time, are exported as a FASTA file.</span>

<span class="sd">					a) The sequence header contains all of the data generated/information we are interested in for the H3-L3 pair. </span>
<span class="sd">					b) The sequence value for the FASTA is the nucleotide sequence of the CDRH3 (heavy chain) sequence only </span>

<span class="sd">				3) This FASTA file is used as an input file to the program USEARCH VERSION 7. </span>
<span class="sd">				4) We run the Usearch program for each cluster defined in the cluster_cutoff parameter defined in this function</span>
<span class="sd">			</span>
<span class="sd">			Step E: Summarize the output from each USEARCH cluster file </span>

<span class="sd">				1) For EACH cluster cutoff defined, USEARCH creates an output .uc file </span>
<span class="sd">				2) We parse this file and generate a finalized output file based on the CDRH3 seed/cluster</span>
<span class="sd">				3) For each seed we calculate the following</span>

<span class="sd">					a) The average SHM for all sequences which belong in the seed </span>
<span class="sd">					b) The V,D, and J call of the SEED sequence </span>
<span class="sd">					c) The Isotype call of the SEED sequence</span>
<span class="sd">					d) A &#39;dominance&#39; calculation =&gt; </span>
<span class="sd">						100*Unique CDRH3-L3 Count of the seed sequence/Unique CDRH3-L3 Count of the next largest H3-L3 group in the cluster</span>
<span class="sd">					e) A &#39;confidence&#39; calculation =&gt; </span>
<span class="sd">						100*Unique CDRH3-L3 Count of the seed sequence/The total counts of all sequences in cluster</span>
<span class="sd">					f) Diversity of all members in seed using </span>
<span class="sd">						i. shannon entropy </span>
<span class="sd">						ii. simpsons index </span>
<span class="sd">			</span>
<span class="sd">			Step F: Generate an annotation file for the database </span>

<span class="sd">				1) We generate an &#39;annotation&#39; file that stores the following features/results in the Georgiou lab database</span>

<span class="sd">					a) the Miseq of ID of a successful VH-VL paired seqsuence </span>
<span class="sd">					b) the Cluster ID of all CDRH3-CDRL3 pairs whose count are above 2 </span>
<span class="sd">					c) the Confidence score for each cluster</span>
<span class="sd">					d) the Dominance score for each cluster</span>
<span class="sd">					</span>
<span class="sd">		**General usage**</span>
<span class="sd">		</span>
<span class="sd">		When calling this function, the most important feature for this program to run correctly is defining the type of file(s) you have submitted. While there is no uniform file type/format, we do need to know which field names in the file correspond to field names we use in the pairing program. </span>
<span class="sd">		The variable, required_field_names, stores the fields we need to perform the analysis. From these fields, only the following fields are absolutely necessary (although providing all fields are ideal):</span>

<span class="sd">			1) seq_header</span>
<span class="sd">			2) cdr3_nt</span>
<span class="sd">					</span>
<span class="sd">		We already know which field names are required for files that were generated using our common annotation methods: IMGT, IGFFT (in house program), MIXCR, IGBLAST. Therefore, if you are pairing files from one of these programs AND you have not modified the output of the files created by our python wrapper functions, there is no need to define the fields. </span>
<span class="sd">		However, if the file being provided is a custom file or an annotation file we do not know about, then you need to define custom field names in the input variable: field_names</span>
<span class="sd">										</span>
<span class="sd">		Example usage for pairing IMGT files::</span>

<span class="sd">			list_of_imgt_files = a list of strings providing the location of all IMGT generated files for pairing. You do not need to select a specific IMGT file or differente the 11 files by experiment, we handle that in the function</span>
<span class="sd">			list_of_imgt_files = [1_summary_file1.txt,5_summary_file1.txt,1_summary_file2.txt,5_summary_file2.txt] (etc  etc for the files to pair)</span>
<span class="sd">			RunPairing(annotated_file_paths = list_of_imgt_files,analysis_method = IMGT, output_folder_path=&#39;paired_seq_data.txt,prefix_output_files=&#39;MYPAIRINGEXP&#39;,annotated_file_formats=&#39;IMGT&#39;,field_names=None,cluster_cutoff=[0.85,0.96,0.01])</span>
<span class="sd">		</span>
<span class="sd">		Example use for pairing MIXCR files::</span>

<span class="sd">			list_of_mixcr_files = a list of strings providing the location of all MIXCR annotation files generated by the function ParseMIXCR</span>
<span class="sd">			list_of_mixcr_files = [file1.mixcr.annotation,file2.mixcr.annotation,file3.mixcr.annotation]</span>
<span class="sd">			RunPairing(annotated_file_paths = list_of_mixcr_files,analysis_method = MIXCR, output_folder_path=&#39;paired_seq_data.txt,prefix_output_files=&#39;MYPAIRINGEXP&#39;,annotated_file_formats=&#39;TAB&#39;,field_names=None,cluster_cutoff=[0.85,0.96,0.01])</span>
<span class="sd">		</span>
<span class="sd">		Example use for any custom file (a file type not generated by the database, parseMIXCR function, parseIgblast function, parseIGFFT function, or IMGT)::</span>

<span class="sd">			list_of_files = a list of strings providing the location of some CSV file that we have not seen before </span>
<span class="sd">			In this example, this CSV (not TAB) file only contains CDR3 nucleotide information. So every other field provided will be treated as blank for the program and not considered. In the provided file, the CDR3 field is labeled as CDR3 Nt and the sequence header is labeled as, Miseq header</span>
<span class="sd">			</span>
<span class="sd">			field_mappings = { key = name of the field we need in the program, value = name of the field in the provided file </span>
<span class="sd">				&#39;cdr3_nt&#39;:	&#39;CDR3 Nt&#39;,</span>
<span class="sd">				&#39;seq_header&#39;:Miseq header&#39;</span>
<span class="sd">			}</span>
<span class="sd">			list_of_files = [fie1.txt,file2.txt,file3.txt]			</span>
<span class="sd">			RunPairing(annotated_file_paths = list_of_files,analysis_method = custom, output_folder_path=&#39;paired_seq_data.txt,prefix_output_files=&#39;MYCUSTOMPAIRINGEXP&#39;,annotated_file_formats=&#39;CSV&#39;,field_names=field_mappings,cluster_cutoff=[0.85,0.96,0.01])</span>
<span class="sd">			</span>
<span class="sd">			</span>
<span class="sd">		**REQUIRED FIELDS**</span>

<span class="sd">			1) annotated_file_paths = a list of files that you want to run pairing with </span>
<span class="sd">			2) analysis_method:</span>
<span class="sd">			</span>
<span class="sd">				A string defining which annotation program generated the results </span>
<span class="sd">				IF an annotation program is not defined in this script (variable above) yet, then use &#39;CUSTOM&#39;</span>
<span class="sd">				</span>
<span class="sd">				.. note:: if analysis_method == &#39;CUSTOM&#39; OR not in the predefined list, then the parameter,field_names, is required </span>
<span class="sd">		</span>
<span class="sd">		**OPTIONAL FIELDS**</span>
<span class="sd">			1) annotated_file_formats</span>
<span class="sd">				</span>
<span class="sd">				accepts three possible formats: </span>
<span class="sd">				</span>
<span class="sd">					None =&gt; do not define file type, let program guess </span>
<span class="sd">					list of file types =&gt; the file type FOR EACH PROVIDED FILE </span>
<span class="sd">					SINGLE STRING =&gt; THIS MEANS ALL INPUTED FILES ARE OF THE SAME TYPE </span>
<span class="sd">		</span>
<span class="sd">			2) field_names</span>

<span class="sd">				A dictionary defining which fields in the file correspond to the fields required for this program </span>
<span class="sd">				</span>
<span class="sd">				.. important::</span>
<span class="sd">					If analysis_method == CUSTOM! then you must define field_names in the file. Program will raise exception otherwise</span>
<span class="sd">					if provided, the structure of field names is as follows: </span>
<span class="sd">					keys of variable: &#39;vgene&#39;,&#39;jgene&#39;,&#39;dgene&#39;,&#39;raw_seq_nt&#39;,&#39;cdr3_nt&#39;,&#39;seq_header&#39;,&#39;shm&#39;,&#39;full_len_ab_aa&#39;</span>
<span class="sd">					values =&gt; for each key,provide the field name in the file that corresponds to the key</span>

<span class="sd">				</span>
<span class="sd">			3) output_folder_path =&gt; path of output folder. If empty, then a new folder is created. If folder path does not exist, then creates a new folder using provided folder path</span>
<span class="sd">			4) prefix_output_files =&gt; prefix string to use for naming output files</span>
<span class="sd">			5) cluster_cutoff =&gt; clustering cutoff for determining clustered pairs  (cluster=0.96 #heavy chain clustering percent (0.96 = 96%))</span>
<span class="sd">			6) files_from_igrep_database =&gt; indicates whether the provided files were downloaded from the database (this is important because files from the database will have the same field names regardless of the annotation type. Therefore, we need to use these files from database</span>
<span class="sd">		</span>
<span class="sd">	&quot;&quot;&quot;</span>						
	<span class="k">if</span> <span class="n">use_low_memory</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;The parameter: use_low_memory = False has been deprecated. We now always run the function using the parameter use_low_memory = True. This can be changed in the future if desired&#39;</span><span class="p">)</span>
		<span class="n">use_low_memory</span> <span class="o">=</span> <span class="bp">True</span>
		
	<span class="n">required_field_names</span> <span class="o">=</span> <span class="n">get_required_field_names</span><span class="p">()</span>
			
	<span class="c">###########INITIALIZATION#################</span>
	<span class="c">##########################################</span>
	<span class="c">#JUST SET UP INPUT PARAMETERS. GO THROUGH PROVIDED PARAMETERS AND DETERMINE HOW TO RUN PROGRAM#		</span>
	<span class="c">#cluster cutof must be between 0 and 1 </span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_cutoff</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_cutoff</span><span class="p">)</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The cluster range must be defined as a 3 element list of :[min cluster,max cluster, step increase in cluster]&#39;</span><span class="p">)</span>
		<span class="n">cluster_cutoff</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">FloatRange</span><span class="p">(</span><span class="n">cluster_cutoff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cluster_cutoff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cluster_cutoff</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">cluster_cutoff</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">cluster_cutoff</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Cluster cutoff must be a floating number between 0 and 1&#39;</span><span class="p">)</span>			
		<span class="n">cluster_cutoff</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster_cutoff</span><span class="p">]</span>		
	
	<span class="k">if</span> <span class="n">annotation_cluster_setting</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">cluster_cutoff</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cluster_cutoff</span><span class="p">)))]</span>			
		<span class="n">mid_val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_cutoff</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
		<span class="n">annotation_cluster_setting</span> <span class="o">=</span> <span class="n">cluster_cutoff</span><span class="p">[</span><span class="n">mid_val</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">annotation_cluster_setting</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">annotation_cluster_setting</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Cluster cutoff must be a floating number between 0 and 1&#39;</span><span class="p">)</span>			
		<span class="n">cluster_cutoff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation_cluster_setting</span><span class="p">)</span>	
		<span class="n">cluster_cutoff</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cluster_cutoff</span><span class="p">)))]</span>			
	
	<span class="c">#if user just passe in a single string for single file, then make it a list </span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
		<span class="n">annotated_file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotated_file_paths</span><span class="p">]</span>			
	<span class="c">#user passed in the file type for EACH provided file </span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The user defined a file format for each file. But the number of file formats does not match the number of input files. If the user wants to use a single format for all files, then simply pass in a string not list defining file format&#39;</span><span class="p">)</span>
		
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">)):</span>
			<span class="n">annotated_file_formats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotated_file_formats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">annotated_file_formats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_file_formats</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The provided file format, {0}, is not currently supported in this program&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">))</span>		
	<span class="c">#user just passed in a string. copy this to all a list contaiing same string for all files </span>
	<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">,</span><span class="nb">basestring</span><span class="p">):</span>		
		<span class="n">annotated_file_formats</span> <span class="o">=</span> <span class="n">annotated_file_formats</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>		
		<span class="k">if</span> <span class="n">annotated_file_formats</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_file_formats</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The provided file format, {0}, is not currently supported in this program&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">))</span>	
		<span class="n">annotated_file_formats</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotated_file_formats</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>	
	<span class="c">#user provided ouput folder </span>
	<span class="k">if</span> <span class="n">output_folder_path</span><span class="p">:</span>		
		<span class="c">#folder path provided does not exist </span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_folder_path</span><span class="p">):</span>			
			<span class="c">#make folder, but ONLY USE BASENAME. FORCE the folder to exist within IGREP project </span>
			<span class="k">if</span> <span class="n">output_folder_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;/&#39;</span><span class="p">:</span>
				<span class="n">output_folder_path</span><span class="o">=</span><span class="n">output_folder_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">parent_dir</span> <span class="o">=</span> <span class="n">filesystem</span><span class="o">.</span><span class="n">ExperimentDirs</span><span class="p">()</span><span class="o">.</span><span class="n">make_dir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">output_folder_path</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;/&#39;</span>
			<span class="k">print</span> <span class="s">&quot;WARNING, OUTPUT DIRECTORY NOT FOUND. CREATED A NEW DIRECTORY FOR OUTPUT CALLED: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c">#this is the output folder </span>
			<span class="n">parent_dir</span> <span class="o">=</span> <span class="n">output_folder_path</span><span class="o">+</span><span class="s">&#39;/&#39;</span> <span class="k">if</span> <span class="n">output_folder_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s">&#39;/&#39;</span> <span class="k">else</span> <span class="n">output_folder_path</span>									
	<span class="k">else</span><span class="p">:</span>
		<span class="c">#user did not pass in output folder, so make a new folder</span>
		<span class="n">folder_name</span> <span class="o">=</span> <span class="s">&#39;PAIRING_RESULT_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c">#make a new folder</span>
		<span class="n">parent_dir</span> <span class="o">=</span> <span class="n">filesystem</span><span class="o">.</span><span class="n">ExperimentDirs</span><span class="p">()</span><span class="o">.</span><span class="n">make_dir</span><span class="p">(</span><span class="n">folder_name</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;/&#39;</span>		
	
	<span class="c">#replace empty spaces in folder name (can be annoying..)</span>
	<span class="n">parent_dir</span> <span class="o">=</span> <span class="n">parent_dir</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
	<span class="n">prefix</span> <span class="o">=</span> <span class="n">parent_dir</span><span class="o">+</span><span class="n">prefix_output_files</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;_&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">prefix_output_files</span> <span class="k">else</span> <span class="n">parent_dir</span><span class="o">+</span><span class="s">&#39;VH_VL_PAIRING&#39;</span>	
	<span class="c">#make sure provided analysis settings are correct/make sure we have all the data we need for pairing </span>
	<span class="n">analysis_method</span><span class="o">=</span><span class="n">analysis_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">analysis_method</span> <span class="o">==</span> <span class="s">&#39;CUSTOM&#39;</span> <span class="ow">or</span> <span class="n">analysis_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_analyses</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">field_names</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">Excpetion</span><span class="p">(</span><span class="s">&#39;You have defined the following analysis method: {0}. However, we cannot use this file until we know the field names for the following variables: {1}. Please rerun function defining these values as key:value format (key = required field name, value = field name in file)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">analysis_method</span><span class="p">,</span><span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">required_field_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
		<span class="k">for</span> <span class="n">each_req_field</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">field_names</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">each_req_field</span> <span class="ow">in</span> <span class="n">required_field_names</span><span class="p">:</span>
				<span class="n">required_field_names</span><span class="p">[</span><span class="n">each_req_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>							
	<span class="k">else</span><span class="p">:</span>
		<span class="c">#the user did not provide field_names, but thats ok because we already know the analysis type and have it hardcoded in variable above </span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">field_names</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">each_req_field</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">pairing_settings</span><span class="p">[</span><span class="n">analysis_method</span><span class="p">][</span><span class="s">&#39;fields_for_analysis&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">each_req_field</span> <span class="ow">in</span> <span class="n">required_field_names</span><span class="p">:</span>
					<span class="n">required_field_names</span><span class="p">[</span><span class="n">each_req_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>							
		<span class="c">#the user provided the field name values </span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">each_req_field</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">field_names</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">each_req_field</span> <span class="ow">in</span> <span class="n">required_field_names</span><span class="p">:</span>
					<span class="n">required_field_names</span><span class="p">[</span><span class="n">each_req_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>				
		<span class="k">if</span> <span class="n">productivity_function</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">productivity_function</span> <span class="o">=</span> <span class="n">pairing_settings</span><span class="p">[</span><span class="n">analysis_method</span><span class="p">][</span><span class="s">&#39;productivity_function&#39;</span><span class="p">]</span>
		
	<span class="c">#at the very least, both the field for seq header and the field for cdr3 nt must be defined </span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;seq_header&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">required_field_names</span><span class="p">[</span><span class="s">&#39;cdr3_nt&#39;</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;At the very least you must define what field name corresponds to the seq_header and what field name corresponds to the nucleotide cdr3. The following fields were defined by the variable field_names: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field_names</span><span class="p">))</span>
	
	<span class="c">#NOW tell the user whether they are will be missing any fields with the provided file for pairing (therefore they know whether to expect weird results)</span>
	<span class="k">for</span> <span class="n">each_req_field</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">required_field_names</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
			<span class="k">print</span> <span class="s">&quot;WARNING, THE FOLLOWING FIELD IS NOT DEFINED: {0}. PAIRING WILL NOT INCLUDE INFORMATION FOR THIS FIELD&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">each_req_field</span><span class="p">)</span>			
	
	<span class="c">#WE PREDICT TWO WAYS TO PROVIDE IMGT FILES: </span>
		<span class="c">#METHOD 1=&gt; PROVIDE THE ORIGINAL 11 IMGT FILES, IN THIS CASE, THEN ANLAYSIS_METHOD == IMGT AND ALSO ANNOTATED_FILE_FORMATS = IMGT OR [IMGT,IMGT,IMGT]</span>
		<span class="c">#METHOD 2=&gt; PROVIDE A SUMMARIZED FILE COMBINING RESULTS FROM IMGT. FOR EXAMPLE DOWNLOADING IMGT RESULTS FROM DATABASE. IN THIS CASE THEN ANALYSIS_METHOD == IMGT BUT!! THE ANNOTATED_FILE_FORMATS DOES  NOT EQUAL IMGT 		</span>
	<span class="c">#SO IF METHOD 1, THEN WE WILL REORGANIZE THE PROVIDED FILES. WE DO THIS BECAUSE WE WANT TO READ MULTIPLE EXPERIMENTS simultaneously (READ MULTIPLE SETS OF IMGT FILES AT THE SAME TIME TO MAINTAIN THE SIZE OF CODEDICT AS SMALL)</span>
	<span class="k">if</span> <span class="n">analysis_method</span><span class="o">==</span><span class="s">&#39;IMGT&#39;</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">annotated_file_formats</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>			
			<span class="n">annotated_file_formats</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;IMGT&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
			<span class="n">imgt_groups</span> <span class="o">=</span> <span class="n">readfile</span><span class="o">.</span><span class="n">GroupIMGTFiles</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
			<span class="n">annotated_file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span> <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="n">imgt_groups</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>			
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_formats</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The provided number of file formats does not match the provided files&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">annotated_file_formats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;IMGT&#39;</span><span class="p">:</span>
				<span class="n">annotated_file_formats</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;IMGT&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
				<span class="n">imgt_groups</span> <span class="o">=</span> <span class="n">readfile</span><span class="o">.</span><span class="n">GroupIMGTFiles</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
				<span class="n">annotated_file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span> <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="n">imgt_groups</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>			
		<span class="k">elif</span> <span class="n">annotated_file_formats</span> <span class="o">==</span> <span class="s">&#39;IMGT&#39;</span><span class="p">:</span>
			<span class="n">annotated_file_formats</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;IMGT&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
			<span class="n">imgt_groups</span> <span class="o">=</span> <span class="n">readfile</span><span class="o">.</span><span class="n">GroupIMGTFiles</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
			<span class="n">annotated_file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span> <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="n">imgt_groups</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>			
		<span class="k">else</span><span class="p">:</span>
			<span class="n">annotated_file_formats</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotated_file_formats</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">)</span>		
		
		<span class="c">#print annotated_file_paths</span>
								
	<span class="c">#SETUP COMPLETE. PROCEED TO RUNNING FUNCTION#			</span>
	<span class="c">############################################################################</span>
		
	<span class="c">#the following files will be generated during the program</span>
	<span class="k">global</span> <span class="n">dict_summary</span>
	<span class="k">global</span> <span class="n">codeDict_output_dict</span>
	<span class="k">global</span> <span class="n">collapsed_output_dict</span>
	<span class="k">global</span> <span class="n">error_file</span>
	<span class="k">global</span> <span class="n">usearch_cluster_file</span>
	<span class="k">global</span> <span class="n">collapsed_output_file</span>
	<span class="k">global</span> <span class="n">summary_file</span>
	<span class="k">global</span> <span class="n">annotation_path</span>	
	<span class="k">global</span> <span class="n">clustered_final_output_file</span>	
	<span class="k">global</span> <span class="n">annotation_headers</span>
	
	<span class="n">annotation_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Header&#39;</span><span class="p">,</span><span class="s">&#39;Sequence&#39;</span><span class="p">,</span><span class="n">idIdentifier</span><span class="p">,</span><span class="s">&#39;Recombination Type&#39;</span><span class="p">,</span><span class="s">&#39;PairedID&#39;</span><span class="p">,</span><span class="s">&#39;PairedClusterId&#39;</span><span class="p">,</span><span class="s">&#39;Dominance&#39;</span><span class="p">,</span><span class="s">&#39;Confidence&#39;</span><span class="p">,</span><span class="s">&#39;Command&#39;</span><span class="p">]</span>
	
	<span class="c">#stores a file of unique CDRH3-L3 pairs. Its a tab delimited file where the first column is the counts for that CDRH3-L3 pair. Reamining columns contain AB information such as CDRH3 AA CDRL3 AA, V,D,J genes, isotypes, average SHM</span>
	<span class="n">collapsed_output_file</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_CDR3_identical_nt_pairs.txt&quot;</span>
	<span class="c">#stores a file of the parsed output from USEARCH clustering. It will store the seed CDRH3-L3 sequence and then store all other sequences above 1 read that were clustered into that seed. </span>
	<span class="c">#it is a TAB delimited file </span>
	<span class="n">clustered_output_file</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_CDR3_raw_clustered_nt_pairs_over1read&quot;</span>
	<span class="c">#stores a summary file of all CDRH3-L3 clusters created from usearch. It stores the seed sequence, then includes information about this size of the cluster and develops &quot;confidence&quot; and &quot;dominance&quot; terms for each cluster size</span>
	<span class="n">clustered_final_output_file</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_CDR3_clustered_nt_pairs_over1read&quot;</span>
	<span class="c">#this is a JSON file that stores all of the sequences which passed filtering. It stores all the sequence information used during pairing. </span>
	<span class="c">#the key in this file represents the fullcode from a miseq header and the value represents VDJ and VJ sequence data. </span>
	<span class="n">codeDict_output_dict</span><span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_codeDict.json&quot;</span>
	<span class="c">#this is a JSON file of the dumped collapsed dict </span>
	<span class="c">#this is no longer supported</span>
	<span class="n">collapsed_output_dict</span><span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_collapsed_dict.json&quot;</span>
	<span class="c">#this is a JSON file created after USEARCH clustering. For each selected cluster it will store the seed as the key and all of the AB information for the CDRH3-L3 sequence found in the sequence header submitted to usearch</span>
	<span class="c">#consider removing this file....</span>
	<span class="n">clustered_output_dict</span><span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_clustered_dict.json&quot;</span>
	<span class="c">#this is a series of JSON strings </span>
	<span class="c">#each line in the file represents a specific VH-VL pair.</span>
	<span class="c">#when using json.loads(line) on each line, it yeilds a 2 element list. the first element is a dictionary of the VDJ data of relevant AB info. the second element is a dictionary of the VJ data of relevant AB info</span>
	<span class="n">dict_summary</span><span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;_dict_summary_line_by_line.txt&quot;</span>	
	<span class="c">#this will generate a final summary file describing how many sequences were parsed, how many were sucessful, and how many clusters were formed. it also includes gene usage for H/L</span>
	<span class="n">summary_file</span><span class="o">=</span><span class="n">prefix</span><span class="o">+</span><span class="s">&quot;_Summary.txt&quot;</span>
	<span class="c">#also not currently being used in both functions </span>
	<span class="n">error_file</span><span class="o">=</span><span class="n">prefix</span><span class="o">+</span><span class="s">&quot;_error log.txt&quot;</span>
	<span class="c">#at the end of this function we will generate annotation files for storing results in the database </span>
	<span class="c">#each line in the annotation file should correspond to each line in the input files</span>
	<span class="n">annotation_path</span><span class="o">=</span><span class="n">prefix</span>
	
	<span class="c">#the input FASTA file submitted to usearch </span>
	<span class="n">usearch_cluster_file</span> <span class="o">=</span> <span class="n">parent_dir</span><span class="o">+</span><span class="s">&quot;clustered_input_file.fasta&quot;</span>
	<span class="c">#the output file generated by usearch program </span>
	<span class="n">usearch_output_file</span> <span class="o">=</span> <span class="n">parent_dir</span><span class="o">+</span><span class="s">&#39;clustered_output_file&#39;</span>	
	
	<span class="c">#THIS IS THE ACTUAL CODE FOR RUNNING PAIRING (THIS CALLS ALL THE FUNCTIONS FOR PAIRING)	</span>
	<span class="c">#first create the variables &#39;codeDict&#39; and &#39;collapsedDict&#39; which will store information regarding R1/R2 pairs from the annotation files </span>
	<span class="c">#if use_low_memory:		</span>
	<span class="p">[</span><span class="n">total_seqs</span><span class="p">,</span><span class="n">passed_filter</span><span class="p">,</span><span class="n">no_result</span><span class="p">,</span><span class="n">no_cdr3_error</span><span class="p">,</span><span class="n">not_productive</span><span class="p">,</span><span class="n">invalid_chain</span><span class="p">,</span><span class="n">successful_pair</span><span class="p">,</span><span class="n">Hchain_pairing_error</span><span class="p">,</span><span class="n">Lchain_pairing_error</span><span class="p">,</span><span class="n">nonpaired_len</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="p">,</span><span class="n">locus_pairing_error</span><span class="p">,</span><span class="n">annotated_file_lists</span><span class="p">,</span><span class="n">mapping_dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_to_dict_memory_safe</span><span class="p">(</span><span class="n">annotated_file_paths</span><span class="p">,</span><span class="n">annotated_file_formats</span><span class="p">,</span><span class="n">required_field_names</span><span class="p">,</span><span class="n">productivity_function</span><span class="p">,</span><span class="n">parent_dir</span><span class="p">,</span><span class="n">analysis_method</span><span class="p">)</span>		
	<span class="c">#else:</span>
		<span class="c">#this function stores results in codeDict and collapsedDict. It is memory hungry but should run faster than above function</span>
		<span class="c">#this function is now deprecated</span>
	<span class="c">#	[total_seqs,passed_filter,no_result,no_cdr3_error,not_productive,invalid_chain,successful_pair,Hchain_pairing_error,Lchain_pairing_error,nonpaired_len,num_unique_cdrh3_l3_pair,num_unique_cdrh3_l3_pair_above1,locus_pairing_error,annotated_file_lists,mapping_dict] = add_to_dict(annotated_file_paths,annotated_file_formats,required_field_names,productivity_function,analysis_method)</span>
				
	<span class="n">number_of_clusters</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_cutoff</span><span class="p">:</span>
		<span class="n">usearch_file</span> <span class="o">=</span> <span class="n">usearch_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.uc&#39;</span>
	
		<span class="c">#CODEICT CREATED, RUN USEARCH  for all clustered settings</span>
		<span class="k">print</span> <span class="s">&#39;Clustering CDRH3 reads with </span><span class="si">%d%%</span><span class="s"> identity.</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
		<span class="c">#run USEARCH</span>
		<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;usearch7 -cluster_smallmem {2} -minhsp 10 -minseqlength 10 -usersort -id {0} -centroids c.fa -uc {1}.{0}.uc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">usearch_output_file</span><span class="p">,</span><span class="n">usearch_cluster_file</span><span class="p">))</span>
		<span class="k">print</span> <span class="s">&#39;USEARCH complete&#39;</span>	
		<span class="k">print</span> <span class="s">&#39;Compiling clustered reads file.</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="c">#After populate_clusters, clustered_dict_raw[cluster number]=[total count, infoSeed, infoHit 1, infoHit 2, etc]		</span>
		
		<span class="c">#Dict clusters based on %identity of heavy chain. light chain ignored. cluster variable defined at top of script.	</span>
		<span class="n">clustered_dict_raw</span> <span class="o">=</span> <span class="n">populate_clusters</span><span class="p">(</span><span class="n">usearch_file</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>			
			
		<span class="n">clustered_output</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">clustered_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.txt&#39;</span><span class="p">,</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>		
		<span class="n">clustered_save</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">clustered_output_dict</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.txt&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>	
		<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">clustered_dict_raw</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>			
			<span class="n">CDRH3</span><span class="o">=</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
			<span class="n">clustered_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">CDRH3</span><span class="p">))</span>
			
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
				<span class="n">clustered_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">clustered_dict_raw</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">))</span>
			<span class="n">clustered_output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>	
			
		<span class="k">print</span> <span class="s">&quot;Saving clustered data.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="n">len_clustered</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">)</span>
		<span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span> <span class="n">clustered_save</span><span class="p">)</span>	
		
		<span class="n">clustered_save</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
		<span class="n">clustered_output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>	
		
		<span class="c">#Prepare clustered file with over 1 read and only the top light chain paired to each heavy chain</span>
		<span class="c">#1st number is rank. </span>
		<span class="c">#2nd number is dominance factor ( LC reads / total number of reads * 100) Good=100, Bad=0</span>
		<span class="c">#3rd number is confidence factor (100 - 100 * (2nd rank LC)/(1st rank LC)) Good=100, Bad=0</span>
		<span class="c">#clustered_dict_raw[cluster number]=[total count, infoSeed, infoHit 1, infoHit 2, etc]	</span>
		<span class="c">#info=(counts,CDRH3_trans,CDRL3_trans,CDRH3,CDRL3,VHgene,DHgene,JHgene,VLgene,JLgene,IgH,IgL,Hmut,Lmut,HLen,LLen)</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;Compiling finalized clustered output file.</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
		<span class="n">Compile_Clusters</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>		
	
	
		<span class="n">number_of_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">))</span>
	
	<span class="c">#Add in gene histograms to summary file</span>
	<span class="n">gene_hist</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">summary_file</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">gene_hist</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">summary_file</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
	<span class="n">gene_hist</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">summary_file</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
	<span class="n">gene_hist</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">summary_file</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
	<span class="n">gene_hist</span><span class="p">(</span><span class="n">clustered_dict_raw</span><span class="p">,</span><span class="n">summary_file</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
	<span class="c">#generate a summary file </span>
	<span class="k">if</span> <span class="p">(</span><span class="n">analysis_method</span><span class="o">==</span><span class="s">&#39;IMGT&#39;</span> <span class="ow">and</span> <span class="n">annotated_file_formats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;IMGT&#39;</span><span class="p">):</span>
		<span class="n">annotated_file_path_summary</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">each_group</span> <span class="ow">in</span> <span class="n">annotated_file_paths</span><span class="p">:</span>
			<span class="n">path</span> <span class="o">=</span> <span class="n">each_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>			
			<span class="n">filename</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">each_group</span><span class="p">)</span><span class="c">#+&#39;/&#39;# &#39;/&#39;.join(path[:-1])+&#39;/&#39;</span>
			<span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">:</span>
				<span class="n">annotated_file_path_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filename</span><span class="p">[</span><span class="mi">2</span><span class="p">:])))</span><span class="c"># path+&#39;_&#39;.join(filename[2:]))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">annotated_file_path_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filename</span><span class="p">)))</span><span class="c"># path+&#39;_&#39;.join(filename))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">annotated_file_path_summary</span> <span class="o">=</span> <span class="n">annotated_file_paths</span>
	<span class="n">WriteSummaryFile</span><span class="p">(</span><span class="n">annotated_file_path_summary</span><span class="p">,</span><span class="n">total_seqs</span><span class="p">,</span><span class="n">passed_filter</span><span class="p">,</span><span class="n">no_result</span><span class="p">,</span><span class="n">no_cdr3_error</span><span class="p">,</span><span class="n">not_productive</span><span class="p">,</span><span class="n">invalid_chain</span><span class="p">,</span><span class="n">successful_pair</span><span class="p">,</span><span class="n">Hchain_pairing_error</span><span class="p">,</span><span class="n">Lchain_pairing_error</span><span class="p">,</span><span class="n">nonpaired_len</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair</span><span class="p">,</span><span class="n">num_unique_cdrh3_l3_pair_above1</span><span class="p">,</span><span class="n">locus_pairing_error</span><span class="p">,</span><span class="n">cluster_cutoff</span><span class="p">,</span><span class="n">number_of_clusters</span><span class="p">)</span>
	
			
	<span class="n">analysis_files_to_report</span> <span class="o">=</span> <span class="p">[</span><span class="n">collapsed_output_file</span><span class="p">,</span><span class="n">summary_file</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">c</span>  <span class="ow">in</span> <span class="n">cluster_cutoff</span><span class="p">:</span>
		<span class="n">analysis_files_to_report</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">usearch_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.uc&#39;</span><span class="p">,</span><span class="n">clustered_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.txt&#39;</span><span class="p">,</span><span class="n">clustered_final_output_file</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.txt&#39;</span><span class="p">])</span>
	
	<span class="c">#generate an annotation file  </span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;Generating an annotation file of paired results for the database&#39;</span><span class="p">)</span>
	<span class="n">GenerateAnnotationFile</span><span class="p">(</span><span class="n">annotated_file_lists</span><span class="p">,</span><span class="n">annotation_cluster_setting</span><span class="p">,</span><span class="n">mapping_dict</span><span class="p">,</span><span class="n">usearch_output_file</span><span class="p">)</span>
	<span class="c">#clustered_final_output_file</span>
	<span class="c">#summary_file</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;All paired clustering complete&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">{</span><span class="s">&#39;annotation_files&#39;</span><span class="p">:[</span><span class="n">annotated_file</span><span class="p">[</span><span class="s">&#39;filename&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">annotated_file</span> <span class="ow">in</span> <span class="n">annotated_file_lists</span><span class="p">],</span><span class="s">&#39;analysis_files&#39;</span><span class="p">:</span><span class="n">analysis_files_to_report</span><span class="p">}</span>



</div>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">THIS FUNCTION IS NOW DEPRECATED</span>
<span class="sd">IT HAS BEEN REPLACED WITH add_to_dict_memory_safe</span>




<span class="sd">#THIS FUNCTION WILL READ THROUGH THE LIST OF FILES PROVIDED</span>
<span class="sd">#1) EACH LINE FROM EACH FILE WILL BE READ IN EVERY ITERATION OF THE LOOP (SO THE FIRST LINE FROM ALL FILES WILL BE READ IN THE FIRST ITERATION , THEN THE SECODN LINE FROM ALL FILES</span>
<span class="sd">	#WE DO THIS BECAUSE AS WE FIND HEADER LINES THAT ARE THE SAME (VH-VL PAIRS FROM SAME MISEQ R1-R2 READ) WE REMOVE THE PAIRS FROM THE DICTIONARY. THIS HELPS WITH MEMORY AS THE DICTIONARY DOES NOT GET AS LARGE AS JUST LOADING ALL HEADER LINES FROM A SINGLE FILE</span>
<span class="sd">#2) THIS FUNCTION NOW COMBINES info from the previous &#39;collapsereads&#39; function </span>
<span class="sd">#3) ONCE WE FIND THE PROPER R1-R2 PAIRED READ, WE REMOVE THE SEQUENCE FROM CODEDICT VARIABLE, AND THEN WE ADD THIS VH-VL PAIR TO THE COLLAPSED DICT VARIABLE</span>
<span class="sd">def add_to_dict(list_of_files,list_of_filetypes,required_field_names,productivity_function_call,analysis_method):	</span>
<span class="sd">	#get global files names for opening files to write/use in this function </span>
<span class="sd">	global dict_summary</span>
<span class="sd">	global codeDict_output_dict</span>
<span class="sd">	global collapsed_output_dict</span>
<span class="sd">	global error_file</span>
<span class="sd">	global usearch_cluster_file</span>
<span class="sd">	global collapsed_output_file</span>
<span class="sd">	global annotation_path</span>
<span class="sd">	</span>
<span class="sd">	#set global variables for field names we require to run analysis </span>
<span class="sd">	global vgene_field</span>
<span class="sd">	global jgene_field</span>
<span class="sd">	global dgene_field</span>
<span class="sd">	global seq_field</span>
<span class="sd">	global cdr3_field</span>
<span class="sd">	global header_field</span>
<span class="sd">	global mut_field</span>
<span class="sd">	global functionality_field</span>
<span class="sd">	global full_aa_field</span>
<span class="sd">	global full_nt_field</span>
<span class="sd">	</span>
<span class="sd">	required_field_names = defaultdict(str,required_field_names) #convert this to default dict so that not all fields have to be explicitly defined</span>
<span class="sd">	</span>
<span class="sd">	#keys to that refer to field names. these are the key values we use for reading files </span>
<span class="sd">	vgene_field = required_field_names[&#39;vgene&#39;]</span>
<span class="sd">	jgene_field = required_field_names[&#39;jgene&#39;]</span>
<span class="sd">	dgene_field = required_field_names[&#39;dgene&#39;]</span>
<span class="sd">	seq_field = required_field_names[&#39;raw_seq_nt&#39;]</span>
<span class="sd">	cdr3_field = required_field_names[&#39;cdr3_nt&#39;]</span>
<span class="sd">	isotype_field = required_field_names[&#39;isotype&#39;]</span>
<span class="sd">	header_field = required_field_names[&#39;seq_header&#39;]</span>
<span class="sd">	mut_field = required_field_names[&#39;shm&#39;]</span>
<span class="sd">	functionality_field = required_field_names[&#39;functionality&#39;]</span>
<span class="sd">	full_aa_field = required_field_names[&#39;full_len_ab_aa&#39;]</span>
<span class="sd">	full_nt_field = required_field_names[&#39;full_len_ab_nt&#39;]</span>
<span class="sd">	</span>
<span class="sd">	</span>
<span class="sd">	#this is a pointer to functions we use for guessing the productivity of the sequence</span>
<span class="sd">	if productivity_function_call == None:</span>
<span class="sd">		productivity_function_call = CDR3Productivity #GeneralProductivity</span>
<span class="sd">	</span>
<span class="sd">	#results are written to the following files </span>
<span class="sd">	write_dict_summary = open(dict_summary,&#39;w&#39;)</span>
<span class="sd">	codeDict_save=open(codeDict_output_dict,&#39;w&#39;)</span>
<span class="sd">	collapsed_save=open(collapsed_output_dict,&#39;w&#39;)	</span>
<span class="sd">	collapsed_output=open(collapsed_output_file,&#39;wb&#39;)</span>
<span class="sd">	error=open(error_file,&#39;wb&#39;)</span>
<span class="sd">	</span>
<span class="sd">	#keep track of the following counters</span>
<span class="sd">	counter=0 #keep track of counters			</span>
<span class="sd">	nonpaired_len = 0 #length of unpaired sequences 		</span>
<span class="sd">	no_cdr3_error = 0 #keep track of sequences which lack cdr3</span>
<span class="sd">	invalid_chain = 0 #keep track of sequences which do not have a valid chain call based on the chain_call variable above </span>
<span class="sd">	not_productive = 0 #keep track of sequences which are determined to be &#39;unproductive&#39;</span>
<span class="sd">	total_seqs = 0 #keep track of all sequences</span>
<span class="sd">	no_result = 0 #keep track of sequences that have no antibody information 	</span>
<span class="sd">	passed_filter = 0 #keep track of sequences that pass the filters described above (no cdr3, unproductive, etc)	</span>
<span class="sd">	locus_pairing_error = 0 #keep track of sequences whose recpetors in the R1/R2 read are different. For example if R1 read is an IGH whereas R2 read is TRB then their receptors (IG AND TR) are not the same </span>
<span class="sd">	Hchain_pairing_error = 0 #keep track of sequences containing H-H data rather than H-L </span>
<span class="sd">	Lchain_pairing_error = 0 #keep track of sequences containing L-L data rather than H-L </span>
<span class="sd">	successful_pair = 0 #keep track of sequences that were successfully paired </span>
<span class="sd">	bad_r1_pair = 0 #keep track of sequences whose R1/R2 pair read was unsuccessful (so it was a good read, but its misqe pair was not )		</span>
<span class="sd">	num_unique_cdrh3_l3_pair = 0 #keep track of unique CDRH3-CDRL3 pairs </span>
<span class="sd">	num_unique_cdrh3_l3_pair_above1 = 0 #keep track of unique CDRH3-CDRL3 pairs above 1</span>
<span class="sd">		</span>
<span class="sd">	codeDict = {} #results from R1/R2 files are stored here </span>
<span class="sd">	collapsed_dict = {} #results for unique CDRH3/CDRL3 pairs are stored here 					</span>
<span class="sd">	codeDict_badSeqs = {} #anytime an R1/R2 read does not pass filters, its barcode/sequenceheader/fullcode gets stored in this dict. Therefore, when we identify its R1/R2 pair in a seperate file, we know not to add it to the dictionary codeDict	</span>
<span class="sd">	</span>
<span class="sd">	print(&#39;Reading all files at once and collapsing identical CDRH3-CDRL3 pairs into collapsed dict&#39;)</span>
<span class="sd">	codeDict_save.write(&#39;{&#39;)#we will save the variable codeDict as a JSON var to file. JSON files start with { and end with }. &#39;,&#39; will be used to save each R1-R2 pair</span>
<span class="sd">	</span>
<span class="sd">	num_r1_r2_found = 0	</span>
<span class="sd">	at_least_one_file_open = True</span>
<span class="sd">	</span>
<span class="sd">	[list_of_file_reading,annotation_file_writing] = initialize_input_files(analysis_method,list_of_filetypes,list_of_files)</span>
<span class="sd">	</span>
<span class="sd">	#key = &gt; a H/L pair ID (the variable fullcode from miseq reads), value = a &#39;CDRH3-CDRL3&#39; pair </span>
<span class="sd">	mapping_dict = {}</span>
<span class="sd">	</span>
<span class="sd">	# we will read each of the files simultaneously (open all the files at once and read line by line)</span>
<span class="sd">	while at_least_one_file_open:		</span>
<span class="sd">	#while counter&lt;200000:</span>
<span class="sd">		counter+=1</span>
<span class="sd">		if total_seqs%100000==0:</span>
<span class="sd">			print &#39;Processed &#39;+str(total_seqs)+&#39; sequences&#39;#: &#39;+str(counter)			</span>
<span class="sd">		</span>
<span class="sd">		#keep track of how many files have been completely read</span>
<span class="sd">		num_eof = 0 		</span>
<span class="sd">		#read each file line by line</span>
<span class="sd">		for fnum,reader in enumerate(list_of_file_reading): 						</span>
<span class="sd">			#this file has been completely read through</span>
<span class="sd">			if reader.IFclass.eof:</span>
<span class="sd">				num_eof+=1</span>
<span class="sd">				continue										</span>
<span class="sd">			#read the next line in the file </span>
<span class="sd">			my_line = reader.IFclass.read()							</span>
<span class="sd">			if not my_line:#probably end of file or just empty line			</span>
<span class="sd">				continue</span>
<span class="sd">			</span>
<span class="sd">			my_line = defaultdict(str,my_line)</span>
<span class="sd">			h = my_line[header_field]				</span>
<span class="sd">			if not h:				</span>
<span class="sd">				annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([&#39;&#39;,my_line[seq_field],my_line[idIdentifier],&#39;&#39;,&#39;&#39;])+&#39;\n&#39;)</span>
<span class="sd">				print &#39;Error type 0: no sequence header&#39;</span>
<span class="sd">				continue</span>
<span class="sd">			</span>
<span class="sd">			[header,id] = GetHeaderInfo(my_line,header_field)</span>
<span class="sd">			</span>
<span class="sd">			#get miseq code/read info </span>
<span class="sd">			fullcode = &#39;:&#39;.join(header.replace(&#39; &#39;,&#39;_&#39;).split(&#39;:&#39;)[3:7]).split(&#39;_&#39;)[0]															</span>
<span class="sd">			</span>
<span class="sd">			header_to_write = header </span>
<span class="sd">			seq_to_write = my_line[seq_field]</span>
<span class="sd">			seq = my_line[seq_field]</span>
<span class="sd">			total_seqs+=1						</span>
<span class="sd">			</span>
<span class="sd">			#no amino acid sequence found </span>
<span class="sd">			if not my_line[full_aa_field]:			</span>
<span class="sd">				</span>
<span class="sd">				if not my_line[full_nt_field]:</span>
<span class="sd">					#no nucleotide sequence found either </span>
<span class="sd">					#do not save this sequences results to file </span>
<span class="sd">					#write to temperoary file annotation file, store that there is no full length sequence for this sequence, so no need to save its </span>
<span class="sd">					#paired annotation information </span>
<span class="sd">					annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,seq,id,&#39;&#39;,&#39;&#39;,&#39;&#39;])+&#39;\n&#39;)						</span>
<span class="sd">					no_result+=1</span>
<span class="sd">					continue</span>
<span class="sd">				else:</span>
<span class="sd">					#aminoa acid sequence was not proviided, but a nucleotide sequence was provided </span>
<span class="sd">					#translate nucloetid to amino acid..this can result in some potential problems with PRODUCTIVITY determination IF using GENERAL PRODUCTIVTY function rule </span>
<span class="sd">					try:</span>
<span class="sd">						end = (len(my_line[full_nt_field])/3)*3</span>
<span class="sd">						my_line[full_aa_field] = str(Seq(my_line[full_nt_field][:end],generic_dna).translate())</span>
<span class="sd">					except:</span>
<span class="sd">						print(&#39;Error type 2: problem translating amino acid =&gt; &#39;+str(my_line[full_nt_field]))</span>
<span class="sd">						annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,seq,id,&#39;&#39;,&#39;&#39;,&#39;&#39;])+&#39;\n&#39;)						</span>
<span class="sd">						no_result+=1</span>
<span class="sd">						continue</span>
<span class="sd">						</span>
<span class="sd">						</span>
<span class="sd">			Vgene = my_line[vgene_field].split(&#39;,&#39;)[0]</span>
<span class="sd">			Jgene = my_line[jgene_field].split(&#39;,&#39;)[0]</span>
<span class="sd">			</span>
<span class="sd">			Dgene = my_line[dgene_field].split(&#39;,&#39;)[0]</span>
<span class="sd">			</span>
<span class="sd">			#figure out locus using vgene call </span>
<span class="sd">			if len(Vgene.split(&#39; &#39;))&gt;1:				</span>
<span class="sd">				for subv in Vgene.split(&#39; &#39;):</span>
<span class="sd">					if &#39;*&#39; in subv or &#39;-&#39; in subv:						</span>
<span class="sd">						Vgene = subv.split(&#39;*&#39;)[0]</span>
<span class="sd">						break</span>
<span class="sd">			else:</span>
<span class="sd">				Vgene = Vgene.split(&#39;*&#39;)[0]</span>
<span class="sd">				</span>
<span class="sd">			</span>
<span class="sd">			if Dgene:</span>
<span class="sd">				#figure out locus using vgene call </span>
<span class="sd">				if len(Dgene.split(&#39; &#39;))&gt;1:</span>
<span class="sd">					for subd in Dgene.split(&#39; &#39;):</span>
<span class="sd">						if &#39;*&#39; in subd or &#39;-&#39; in subd:						</span>
<span class="sd">							Dgene = subd.split(&#39;*&#39;)[0]</span>
<span class="sd">							break</span>
<span class="sd">				else:</span>
<span class="sd">					Dgene = Dgene.split(&#39;*&#39;)[0]				</span>
<span class="sd">			</span>
<span class="sd">			if Jgene:				</span>
<span class="sd">				if len(Jgene.split(&#39; &#39;))&gt;1:</span>
<span class="sd">					for subj in Jgene.split(&#39; &#39;):</span>
<span class="sd">						if &#39;*&#39; in subj or &#39;-&#39; in subj:						</span>
<span class="sd">							Jgene = subj.split(&#39;*&#39;)[0]</span>
<span class="sd">							break</span>
<span class="sd">				else:</span>
<span class="sd">					Jgene = Jgene.split(&#39;*&#39;)[0]				</span>
<span class="sd">			</span>
<span class="sd">			if Vgene:</span>
<span class="sd">				#use vgene to determine locus </span>
<span class="sd">				locus = Vgene[:3].upper()						</span>
<span class="sd">			elif Jgene:</span>
<span class="sd">				#if no vgene is present, then use jgene</span>
<span class="sd">				locus = Jgene[:3].upper()</span>
<span class="sd">			else:</span>
<span class="sd">				locus=&#39;&#39;</span>
<span class="sd">			</span>
<span class="sd">			chain = &#39;N/A&#39;			</span>
<span class="sd">			#shoudl return &#39;VDJ&#39; or &#39;VJ&#39; based on LOCUS var</span>
<span class="sd">			for possible_chains,values in chain_call.iteritems():			</span>
<span class="sd">				if locus in values:</span>
<span class="sd">					chain = possible_chains.upper()</span>
<span class="sd">					break		</span>
<span class="sd">			</span>
<span class="sd">			#chain could not be determind with provided locus </span>
<span class="sd">			if chain == &#39;N/A&#39;:										</span>
<span class="sd">				invalid_chain+=1</span>
<span class="sd">				print &#39;Error type 1&#39; #isotype is mislabeled				</span>
<span class="sd">				print locus</span>
<span class="sd">				print Vgene </span>
<span class="sd">				print Jgene</span>
<span class="sd">				#print my_line		</span>
<span class="sd">				print chain_call</span>
<span class="sd">				codeDict_badSeqs[fullcode] = 0</span>
<span class="sd">				#remvoe its potential corresponding read from the codeDict var</span>
<span class="sd">				corresponding_r_data = codeDict.pop(fullcode,None)</span>
<span class="sd">				rtype=&#39;&#39;</span>
<span class="sd">				if corresponding_r_data:</span>
<span class="sd">					bad_r1_pair+=1</span>
<span class="sd">					if corresponding_r_data[ab_field_loc[&#39;CHAIN_CALL&#39;]] == &#39;VDJ&#39;:						</span>
<span class="sd">						#write this R1-R2 pair, in json format, to the codeDict_save file 									</span>
<span class="sd">						codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([corresponding_r_data,[]*num_elem_stored,&#39;CORRESPONDING READ FILE HAD INVALID CHAIN&#39;])+&#39;,\n&#39;)						</span>
<span class="sd">						rtype=&#39;VJ&#39;</span>
<span class="sd">					elif corresponding_r_data[ab_field_loc[&#39;CHAIN_CALL&#39;]] == &#39;VJ&#39;:							</span>
<span class="sd">						#write this R1-R2 pair, in json format, to the codeDict_save file 									</span>
<span class="sd">						codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([[]*num_elem_stored,corresponding_r_data,&#39;CORRESPONDING READ FILE HAD INVALID CHAIN&#39;])+&#39;,\n&#39;)</span>
<span class="sd">						rytpe=&#39;VDJ&#39;</span>
<span class="sd">				annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,my_line[seq_field],id,rtype,fullcode,&#39;&#39;])+&#39;\n&#39;)						</span>
<span class="sd">				continue</span>
<span class="sd">			</span>
<span class="sd">			rtype=chain</span>
<span class="sd">			#unproductive</span>
<span class="sd">			if productivity_function_call(my_line)==False:								</span>
<span class="sd">				codeDict_badSeqs[fullcode] = 0				</span>
<span class="sd">				#remvoe its potential corresponding read from the codeDict var</span>
<span class="sd">				corresponding_r_data = codeDict.pop(fullcode,None)</span>
<span class="sd">				if corresponding_r_data:					</span>
<span class="sd">					bad_r1_pair+=1</span>
<span class="sd">					if corresponding_r_data[ab_field_loc[&#39;CHAIN_CALL&#39;]] == &#39;VDJ&#39;:											</span>
<span class="sd">						#write this R1-R2 pair, in json format, to the codeDict_save file </span>
<span class="sd">						codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([corresponding_r_data,[]*num_elem_stored,&#39;CORRESPONDING READ FILE HAD UNPRODUCTIVE SEQUENCE&#39;])+&#39;,\n&#39;)						</span>
<span class="sd">					elif corresponding_r_data[ab_field_loc[&#39;CHAIN_CALL&#39;]] == &#39;VJ&#39;:						</span>
<span class="sd">						#write this R1-R2 pair, in json format, to the codeDict_save file 									</span>
<span class="sd">						codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([[]*num_elem_stored,corresponding_r_data,&#39;CORRESPONDING READ FILE HAD UNPRODUCTIVE SEQUENCE&#39;])+&#39;,\n&#39;)</span>
<span class="sd">				#write to temperoary file </span>
<span class="sd">				annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,my_line[seq_field],id,rtype,fullcode,&#39;&#39;])+&#39;\n&#39;)						</span>
<span class="sd">				not_productive+=1</span>
<span class="sd">				continue</span>
<span class="sd">			</span>
<span class="sd">			#no cdr3 found </span>
<span class="sd">			if not(my_line[cdr3_field]):							</span>
<span class="sd">				codeDict_badSeqs[fullcode] = 0</span>
<span class="sd">				corresponding_r_data = codeDict.pop(fullcode,None)</span>
<span class="sd">				#remvoe its potential corresponding read from the codeDict var</span>
<span class="sd">				if corresponding_r_data:	</span>
<span class="sd">					bad_r1_pair+=1</span>
<span class="sd">					if corresponding_r_data[ab_field_loc[&#39;CHAIN_CALL&#39;]] == &#39;VDJ&#39;:						</span>
<span class="sd">						#write this R1-R2 pair, in json format, to the codeDict_save file 									</span>
<span class="sd">						codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([corresponding_r_data,[]*num_elem_stored,&#39;CORRESPONDING READ FILE LACKED CDR3&#39;])+&#39;,\n&#39;)						</span>
<span class="sd">					elif corresponding_r_data[ab_field_loc[&#39;CHAIN_CALL&#39;]] == &#39;VJ&#39;:					</span>
<span class="sd">						#write this R1-R2 pair, in json format, to the codeDict_save file 									</span>
<span class="sd">						codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([[]*num_elem_stored,corresponding_r_data,&#39;CORRESPONDING READ FILE LACKED CDR3&#39;])+&#39;,\n&#39;)</span>
<span class="sd">				#write to temperoary file </span>
<span class="sd">				annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,my_line[seq_field],id,rtype,fullcode,&#39;&#39;])+&#39;\n&#39;)						</span>
<span class="sd">				no_cdr3_error+=1</span>
<span class="sd">				continue</span>
<span class="sd">												</span>
<span class="sd">			CDR3 = my_line[cdr3_field].upper()</span>
<span class="sd">			Len = len(CDR3)/3</span>
<span class="sd">			#get SHM info </span>
<span class="sd">			try:</span>
<span class="sd">				Mut = round(float(my_line[mut_field]),3)</span>
<span class="sd">			except:</span>
<span class="sd">				if &#39;(&#39; in my_line[mut_field]:</span>
<span class="sd">					try:</span>
<span class="sd">						Mut = round(float(my_line[mut_field].split(&#39;(&#39;)[0].strip()),3)</span>
<span class="sd">					except:</span>
<span class="sd">						Mut = &#39;none&#39;</span>
<span class="sd">				else:				</span>
<span class="sd">					Mut = &#39;none&#39;		</span>
<span class="sd">			</span>
<span class="sd">			isotype = my_line[isotype_field].strip()</span>

<span class="sd">			seq=my_line[seq_field]</span>
<span class="sd">						</span>
<span class="sd">			passed_filter+=1</span>
<span class="sd">			</span>
<span class="sd">			annotation_file_writing[fnum][&#39;buffer&#39;].write(&#39;\t&#39;.join([header,my_line[seq_field],id,rtype,fullcode,&#39;&#39;])+&#39;\n&#39;)						</span>
<span class="sd">			</span>
<span class="sd">			#no need to put data in codeDict since we already know that its R1/R2 pair data did not work </span>
<span class="sd">			if fullcode in codeDict_badSeqs:	</span>
<span class="sd">				bad_r1_pair+=1				</span>
<span class="sd">				codeDict_badSeqs.pop(fullcode)		</span>
<span class="sd">				</span>
<span class="sd">				#save results to file, but dont add it to codeDict</span>
<span class="sd">				temp_array = [None]*num_elem_stored</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CDR3_SEQ&#39;]] = CDR3</span>
<span class="sd">				temp_array[ab_field_loc[&#39;VGENE&#39;]]=Vgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;DGENE&#39;]]=Dgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;JGENE&#39;]]=Jgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;LOCUS&#39;]]=locus</span>
<span class="sd">				temp_array[ab_field_loc[&#39;MUT&#39;]]=Mut</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CDR3_LEN&#39;]]=Len</span>
<span class="sd">				temp_array[ab_field_loc[&#39;AB_SEQ&#39;]]=seq</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CHAIN_CALL&#39;]]=chain</span>
<span class="sd">				temp_array[ab_field_loc[&#39;ISOTYPE&#39;]] = isotype</span>

<span class="sd">				</span>
<span class="sd">				if chain==&#39;VDJ&#39;:				</span>
<span class="sd">					codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([temp_array,[]*num_elem_stored,&#39;CORRESPONDING READ FILE DID NOT PASS FILTERS&#39;])+&#39;,\n&#39;)						</span>
<span class="sd">				else:</span>
<span class="sd">					codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([[]*num_elem_stored,temp_array,&#39;CORRESPONDING READ FILE DID NOT PASS FILTERS&#39;])+&#39;,\n&#39;)						</span>
<span class="sd">				</span>
<span class="sd">				continue</span>
<span class="sd">						</span>
<span class="sd">			</span>
<span class="sd">			if fullcode not in codeDict:												</span>
<span class="sd">				#this is the first time an R1/R2 read for a particular sequence was found that passed above filters 				</span>
<span class="sd">				</span>
<span class="sd">				#stores all the relevant fields for pairing </span>
<span class="sd">				#ab_field_loc=&gt; points to the index location in each array for each field sstored. i.e. CDR3 is always stored in 0 position of array 				</span>
<span class="sd">				temp_array = [None]*num_elem_stored</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CDR3_SEQ&#39;]] = CDR3</span>
<span class="sd">				temp_array[ab_field_loc[&#39;VGENE&#39;]]=Vgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;DGENE&#39;]]=Dgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;JGENE&#39;]]=Jgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;LOCUS&#39;]]=locus</span>
<span class="sd">				temp_array[ab_field_loc[&#39;MUT&#39;]]=Mut</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CDR3_LEN&#39;]]=Len</span>
<span class="sd">				temp_array[ab_field_loc[&#39;AB_SEQ&#39;]]=seq</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CHAIN_CALL&#39;]]=chain 									</span>
<span class="sd">				temp_array[ab_field_loc[&#39;ISOTYPE&#39;]] = isotype</span>
<span class="sd">					</span>
<span class="sd">				codeDict[fullcode] = temp_array													</span>
<span class="sd">			else:				</span>
<span class="sd">				#we found an R1/R2 pair that passed filters </span>
<span class="sd">				num_r1_r2_found+=1</span>
<span class="sd">				</span>
<span class="sd">				#lets just pop the data/remove data from the codeDict variable because we have found the H/L pair </span>
<span class="sd">				pair_data = codeDict.pop(fullcode)</span>
<span class="sd">				</span>
<span class="sd">				#SEPARETE VDJ(HEAVY) AND VJ(LIGHT) DATA 				</span>
<span class="sd">				pair_error = False								</span>
<span class="sd">				</span>
<span class="sd">				temp_array = [None]*num_elem_stored</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CDR3_SEQ&#39;]] = CDR3</span>
<span class="sd">				temp_array[ab_field_loc[&#39;VGENE&#39;]]=Vgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;DGENE&#39;]]=Dgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;JGENE&#39;]]=Jgene</span>
<span class="sd">				temp_array[ab_field_loc[&#39;LOCUS&#39;]]=locus</span>
<span class="sd">				temp_array[ab_field_loc[&#39;MUT&#39;]]=Mut</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CDR3_LEN&#39;]]=Len</span>
<span class="sd">				temp_array[ab_field_loc[&#39;AB_SEQ&#39;]]=seq	</span>
<span class="sd">				temp_array[ab_field_loc[&#39;CHAIN_CALL&#39;]]=chain 		</span>
<span class="sd">				temp_array[ab_field_loc[&#39;ISOTYPE&#39;]] = isotype</span>

<span class="sd">				</span>
<span class="sd">				error_string = &#39;&#39;</span>
<span class="sd">				if chain == &#39;VDJ&#39;: # the current sequence is heavy 					</span>
<span class="sd">					#the receptor call (IG/TR) of the R1/R2 reads did not match, we assume thsi cannot happen 				</span>
<span class="sd">					if locus[:2]!=pair_data[ab_field_loc[&#39;LOCUS&#39;]][:2]: </span>
<span class="sd">						locus_pairing_error+=1</span>
<span class="sd">						#pair_data.append(&#39;ReceptorError&#39;)		</span>
<span class="sd">						error_string = &#39;ReceptorError&#39;</span>
<span class="sd">						error.write(&#39;Receptors calls for R1/R2 reads do not match: %s\n&#39; %(fullcode))</span>
<span class="sd">													</span>

<span class="sd">						vdj = temp_array</span>
<span class="sd">						vj = pair_data#[:-1]	</span>
<span class="sd">						pair_error = True					</span>
<span class="sd">					#already have heavy data for this sequence </span>
<span class="sd">					elif pair_data[ab_field_loc[&#39;CHAIN_CALL&#39;]]==&#39;VDJ&#39;:#=&#39;none&#39;: #VDJ!=None:</span>
<span class="sd">						error.write(&#39;Heavy chain overlap: %s\n&#39; %(fullcode)) #there are multiple heavy chains with the same NGS barcode</span>
<span class="sd">						Hchain_pairing_error+=1</span>
<span class="sd">						pair_error = True</span>
<span class="sd">						error_string = &#39;OverlapError&#39;</span>
<span class="sd">						#pair_data.append(&#39;OverlapError&#39;)</span>
<span class="sd">						vdj = pair_data</span>
<span class="sd">						vj = []					</span>
<span class="sd">					else:</span>
<span class="sd">						#stores all the relevant fields for pairing </span>
<span class="sd">						#ab_field_loc=&gt; points to the index location in each array for each field sstored. i.e. CDR3 is always stored in 0 position of array </span>
<span class="sd">						temp_array = [None]*num_elem_stored</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CDR3_SEQ&#39;]] = CDR3</span>
<span class="sd">						temp_array[ab_field_loc[&#39;VGENE&#39;]]=Vgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;DGENE&#39;]]=Dgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;JGENE&#39;]]=Jgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;LOCUS&#39;]]=locus</span>
<span class="sd">						temp_array[ab_field_loc[&#39;MUT&#39;]]=Mut</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CDR3_LEN&#39;]]=Len</span>
<span class="sd">						temp_array[ab_field_loc[&#39;AB_SEQ&#39;]]=seq	</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CHAIN_CALL&#39;]]=chain 									</span>
<span class="sd">						temp_array[ab_field_loc[&#39;ISOTYPE&#39;]] = isotype</span>
<span class="sd">		</span>
<span class="sd">						vdj = temp_array</span>
<span class="sd">						vj = pair_data#[:-1]	</span>
<span class="sd">						temp_array=[]</span>
<span class="sd">				</span>
<span class="sd">				elif (chain==&#39;VJ&#39;):		</span>
<span class="sd">					#the receptor call (IG/TR) of the R1/R2 reads did not match, we assume thsi cannot happen 				</span>
<span class="sd">					if locus[:2]!=pair_data[ab_field_loc[&#39;LOCUS&#39;]][:2]: #the locus of the R1/R2 reads did not match, we assume thsi cannot happen 				</span>
<span class="sd">						locus_pairing_error+=1</span>
<span class="sd">						#pair_data.append(&#39;ReceptorError&#39;)	</span>
<span class="sd">						error_string = &#39;ReceptorError&#39;</span>

<span class="sd">						error.write(&#39;Receptors calls for R1/R2 reads do not match: %s\n&#39; %(fullcode))</span>
<span class="sd">						pair_error = True</span>
<span class="sd">						</span>
<span class="sd">						temp_array = [None]*num_elem_stored</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CDR3_SEQ&#39;]] = CDR3</span>
<span class="sd">						temp_array[ab_field_loc[&#39;VGENE&#39;]]=Vgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;DGENE&#39;]]=Dgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;JGENE&#39;]]=Jgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;LOCUS&#39;]]=locus</span>
<span class="sd">						temp_array[ab_field_loc[&#39;MUT&#39;]]=Mut</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CDR3_LEN&#39;]]=Len</span>
<span class="sd">						temp_array[ab_field_loc[&#39;AB_SEQ&#39;]]=seq</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CHAIN_CALL&#39;]]=chain 									</span>
<span class="sd">						temp_array[ab_field_loc[&#39;ISOTYPE&#39;]] = isotype</span>


<span class="sd">						vj = temp_array</span>
<span class="sd">						vdj = pair_data#[:-1]</span>
<span class="sd">					</span>
<span class="sd">					elif pair_data[ab_field_loc[&#39;CHAIN_CALL&#39;]]==&#39;VJ&#39;: 				</span>
<span class="sd">						error.write(&#39;Light chain overlap: %s\n&#39; %(fullcode)) #there are multiple light chains with the same NGS barcode</span>
<span class="sd">						Lchain_pairing_error+=1</span>
<span class="sd">						pair_error = True</span>
<span class="sd">						error_string = &#39;OverlapError&#39;</span>
<span class="sd">						#pair_data.append(&#39;OverlapError&#39;)		</span>
<span class="sd">						vdj = []</span>
<span class="sd">						vj = pair_data		</span>
<span class="sd">					</span>
<span class="sd">					else:</span>
<span class="sd">						temp_array = [None]*num_elem_stored</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CDR3_SEQ&#39;]] = CDR3</span>
<span class="sd">						temp_array[ab_field_loc[&#39;VGENE&#39;]]=Vgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;DGENE&#39;]]=Dgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;JGENE&#39;]]=Jgene</span>
<span class="sd">						temp_array[ab_field_loc[&#39;LOCUS&#39;]]=locus</span>
<span class="sd">						temp_array[ab_field_loc[&#39;MUT&#39;]]=Mut</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CDR3_LEN&#39;]]=Len</span>
<span class="sd">						temp_array[ab_field_loc[&#39;AB_SEQ&#39;]]=seq</span>
<span class="sd">						temp_array[ab_field_loc[&#39;CHAIN_CALL&#39;]]=chain 									</span>
<span class="sd">						temp_array[ab_field_loc[&#39;ISOTYPE&#39;]] = isotype</span>

<span class="sd">						</span>
<span class="sd">						vdj = pair_data#[:-1]</span>
<span class="sd">						vj = temp_array						</span>
<span class="sd">				</span>
<span class="sd">				</span>
<span class="sd">				#write this R1-R2 pair, in json format, to the codeDict_save file 				</span>
<span class="sd">				codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([vdj,vj,error_string])+&#39;,\n&#39;)</span>
<span class="sd">				</span>
<span class="sd">				#add a CDRH3-CDRL3 pair to the collapsed dict var </span>
<span class="sd">				if pair_error==False:	</span>
<span class="sd">					#for writing line by line json results of paired sequences</span>
<span class="sd">					write_dict_summary.write(json.dumps([{field:vdj[index_val] for field,index_val in ab_field_loc.iteritems()},{field:vj[index_val] for field,index_val in ab_field_loc.iteritems()}])+&#39;\n&#39;)						</span>

<span class="sd">					#write_dict_summary.write(json.dumps([vdj,vj])+&#39;\n&#39;)</span>
<span class="sd">					successful_pair+=1</span>
<span class="sd">					barcode = vdj[ab_field_loc[&#39;CDR3_SEQ&#39;]]+&#39;:&#39;+vj[ab_field_loc[&#39;CDR3_SEQ&#39;]]					</span>
<span class="sd">					barcode_aa = str(Seq(vdj[ab_field_loc[&#39;CDR3_SEQ&#39;]],generic_dna).translate())+&#39;:&#39;+str(Seq(vj[ab_field_loc[&#39;CDR3_SEQ&#39;]],generic_dna).translate())</span>
<span class="sd">					if barcode not in collapsed_dict:</span>
<span class="sd">						vdj.extend([0,0,0])</span>
<span class="sd">						vj.extend([0,0,0])																		</span>
<span class="sd">						collapsed_dict[barcode] = [vdj,vj,0]</span>
<span class="sd">					</span>
<span class="sd">					#add barcode to collapsed_dict. also include information for MEAN SHM and VARIANCE SHM</span>
<span class="sd">					if vdj[ab_field_loc[&#39;MUT&#39;]] != &#39;none&#39;:						</span>
<span class="sd">						collapsed_dict[barcode][0][-3] +=1 #add to the number of sequences contianing SHM data </span>
<span class="sd">						collapsed_dict[barcode][0][-2] +=vdj[ab_field_loc[&#39;MUT&#39;]] #add to SUM SHM </span>
<span class="sd">						collapsed_dict[barcode][0][-1] +=pow(vdj[ab_field_loc[&#39;MUT&#39;]],2) #add to SUM SHM^2							</span>
<span class="sd">											</span>
<span class="sd">					if vj[ab_field_loc[&#39;MUT&#39;]] != &#39;none&#39;:						</span>
<span class="sd">						collapsed_dict[barcode][1][-3] +=1 #add to the number of sequences contianing SHM data </span>
<span class="sd">						collapsed_dict[barcode][1][-2] +=vj[ab_field_loc[&#39;MUT&#39;]] #add to SUM SHM </span>
<span class="sd">						collapsed_dict[barcode][1][-1] +=pow(vj[ab_field_loc[&#39;MUT&#39;]],2) #add to SUM SHM^2																																</span>
<span class="sd">					</span>
<span class="sd">					collapsed_dict[barcode][-1]+=1</span>
<span class="sd">					mapping_dict[fullcode] = barcode</span>
<span class="sd">				</span>
<span class="sd">		if num_eof==len(list_of_files):#all files have been read through</span>
<span class="sd">			at_least_one_file_open=False </span>
<span class="sd">				</span>
<span class="sd">	</span>
<span class="sd">	#any sequences remaining in codeDict were sequencse whose R1/R2 paired read was missing </span>
<span class="sd">	nonpaired_len = len(codeDict)</span>
<span class="sd">	</span>
<span class="sd">	for non_paired_keys in codeDict.keys():</span>
<span class="sd">		chain_data = codeDict.pop(non_paired_keys)</span>
<span class="sd">		</span>
<span class="sd">		if chain_data[ab_field_loc[&#39;CHAIN_CALL&#39;]]==&#39;VDJ&#39;:</span>
<span class="sd">			codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([chain_data,[]*num_elem_stored,&#39;A corresponding r1/r2 read was not found&#39;])+&#39;,\n&#39;)</span>
<span class="sd">		else:</span>
<span class="sd">			codeDict_save.write(&#39;\t&quot;&#39;+fullcode+&#39;&quot;:&#39;+json.dumps([[]*num_elem_stored,chain_data,&#39;A corresponding r1/r2 read was not found&#39;])+&#39;,\n&#39;)			</span>
<span class="sd">		del chain_data			</span>
<span class="sd">	</span>
<span class="sd">	#FINISH off saving of codeDict. have to do this to ensure that json.load function will work on file lateron</span>
<span class="sd">	if num_r1_r2_found&gt;0:</span>
<span class="sd">		codeDict_save.seek(-2,os.SEEK_END) #search for last character in file </span>
<span class="sd">		codeDict_save.truncate() #remove the last character (should be a &#39;,&#39;)</span>
<span class="sd">		codeDict_save.write(&#39;\n}&#39;)#replace last characer with a }</span>
<span class="sd">	else:</span>
<span class="sd">		codeDict_save.write(&#39;\n}&#39;)#replace last characer with a }</span>
<span class="sd">	</span>
<span class="sd">	#save collapsed_dict var to file </span>
<span class="sd">	#stores collapsed dict into a json file</span>
<span class="sd">	print &quot;Saving collapsed dictionary.\n&quot;</span>
<span class="sd">	json.dump(collapsed_dict, collapsed_save)</span>
<span class="sd">	</span>
<span class="sd">	#Collapsing identical reads</span>
<span class="sd">	print &#39;Compiling collapsed reads file.\n&#39;</span>
<span class="sd">	</span>
<span class="sd">	clustered_input=open(usearch_cluster_file,&#39;w&#39;)</span>
<span class="sd">			</span>
<span class="sd">	num_unique_cdrh3_l3_pair=len(collapsed_dict)</span>
<span class="sd">	</span>
<span class="sd">	#sort keys in collapsed_dict by their counts (element 2)</span>
<span class="sd">	sorted_keys = sorted(collapsed_dict, key=lambda i:collapsed_dict[i][2], reverse=True)</span>
<span class="sd">	summed_counts=0</span>
<span class="sd">	s2=0</span>
<span class="sd">	for key in sorted_keys:</span>
<span class="sd">		#first element of row = &gt; heavy chain data </span>
<span class="sd">		#second element of row =&gt; light chain data </span>
<span class="sd">		#third element =&gt; counts</span>
<span class="sd">		row = collapsed_dict.pop(key)		</span>
<span class="sd">		</span>
<span class="sd">		#the variable ab_field_loc stores the index position for each antibody region in the array </span>
<span class="sd">		CDRH3=row[0][ab_field_loc[&#39;CDR3_SEQ&#39;]]</span>
<span class="sd">		VHgene=row[0][ab_field_loc[&#39;VGENE&#39;]]</span>
<span class="sd">		DHgene=row[0][ab_field_loc[&#39;DGENE&#39;]]</span>
<span class="sd">		JHgene=row[0][ab_field_loc[&#39;JGENE&#39;]]		</span>
<span class="sd">		CDRL3=row[1][ab_field_loc[&#39;CDR3_SEQ&#39;]]#[4]</span>
<span class="sd">		VLgene=row[1][ab_field_loc[&#39;VGENE&#39;]]#[5]</span>
<span class="sd">		JLgene=row[1][ab_field_loc[&#39;JGENE&#39;]]#[6]</span>
<span class="sd">		IgH=row[0][ab_field_loc[&#39;LOCUS&#39;]]#[7]</span>
<span class="sd">		IgL=row[1][ab_field_loc[&#39;LOCUS&#39;]]#[8]</span>
<span class="sd">							</span>
<span class="sd">		HLen=row[0][ab_field_loc[&#39;CDR3_LEN&#39;]]</span>
<span class="sd">		LLen=row[1][ab_field_loc[&#39;CDR3_LEN&#39;]]</span>
<span class="sd">		</span>
<span class="sd">		h_iso = row[0][ab_field_loc[&#39;ISOTYPE&#39;]]</span>
<span class="sd">		l_iso = row[1][ab_field_loc[&#39;ISOTYPE&#39;]]			</span>
<span class="sd">		counts=row[2]</span>
<span class="sd">		summed_counts+=counts</span>
<span class="sd">		</span>
<span class="sd">		</span>
<span class="sd">		if row[0][-3]&gt;0:					</span>
<span class="sd">			Hmut_sum = row[0][-2]</span>
<span class="sd">			Hmut_sum_sq = row[0][-1]</span>
<span class="sd">			Hmut_count = row[0][-3]</span>
<span class="sd">			</span>
<span class="sd">			#average shm</span>
<span class="sd">			Hmut_avg = round(Hmut_sum/Hmut_count,3)</span>
<span class="sd">			#shm variance -&gt; sum of squares formulat =&gt; sum(vals^2)-(sum(vals)^2/counts)</span>
<span class="sd">			if Hmut_count&gt;1:</span>
<span class="sd">				Hmut_var = round(pow((Hmut_sum_sq-(pow(Hmut_sum,2)/Hmut_count))/(Hmut_count-1),0.5),3)</span>
<span class="sd">			else:</span>
<span class="sd">				Hmut_var = &#39;none&#39;</span>
<span class="sd">			</span>
<span class="sd">		else:</span>
<span class="sd">			Hmut_avg = &#39;none&#39;</span>
<span class="sd">			Hmut_var = &#39;none&#39;</span>
<span class="sd">			Hmut_sum = 0</span>
<span class="sd">			Hmut_sum_sq = 0</span>
<span class="sd">			Hmut_count = 0			</span>
<span class="sd">			</span>
<span class="sd">		if row[1][-3]&gt;0:			</span>
<span class="sd">			Lmut_sum = row[1][-2]</span>
<span class="sd">			Lmut_sum_sq = row[1][-1]</span>
<span class="sd">			Lmut_count = row[1][-3]</span>
<span class="sd">			</span>
<span class="sd">			Lmut_avg = round(Lmut_sum/Lmut_count,3)</span>
<span class="sd">			#shm variance -&gt; sum of squares formulat =&gt; sum(vals^2)-(sum(vals)^2)/counts)</span>
<span class="sd">			if Lmut_count&gt;1:</span>
<span class="sd">				Lmut_var = round(pow((Lmut_sum_sq-(pow(Lmut_sum,2))/Lmut_count)/(Lmut_count-1),0.5),3)</span>
<span class="sd">			else:</span>
<span class="sd">				Lmut_var = &#39;none&#39;</span>
<span class="sd">			</span>
<span class="sd">		else:</span>
<span class="sd">			Lmut_avg= &#39;none&#39;</span>
<span class="sd">			Lmut_var= &#39;none&#39;</span>
<span class="sd">			Lmut_sum = 0</span>
<span class="sd">			Lmut_sum_sq = 0</span>
<span class="sd">			Lmut_count = 0</span>
<span class="sd">						</span>
<span class="sd">		try: </span>
<span class="sd">			CDRH3_trans=str((Seq(CDRH3,generic_dna)).translate())</span>
<span class="sd">		except Exception as e: </span>
<span class="sd">			CDRH3= &#39;translation error&#39;</span>
<span class="sd">			print &#39;Error translating: &#39;+str(e)		</span>
<span class="sd">		try: </span>
<span class="sd">			CDRL3_trans=str((Seq(CDRL3,generic_dna)).translate())</span>
<span class="sd">		except Exception as e: </span>
<span class="sd">			CDRL3= &#39;translation error&#39;</span>
<span class="sd">			print &#39;Error translating: &#39;+str(e)		</span>
<span class="sd">				</span>
<span class="sd">		</span>
<span class="sd">		results = [counts,CDRH3_trans,CDRL3_trans,CDRH3,CDRL3,VHgene,DHgene,JHgene,VLgene,JLgene,IgH,IgL,Hmut_avg,Hmut_var,Lmut_avg,Lmut_var,HLen,LLen,h_iso,l_iso,Hmut_sum,Hmut_sum_sq,Hmut_count,Lmut_sum,Lmut_sum_sq,Lmut_count]</span>
<span class="sd">		results = [str(r) for r in results]</span>
<span class="sd">		</span>
<span class="sd">		collapsed_output.write(&quot;\t&quot;.join(results)+&#39;\n&#39;)</span>

<span class="sd">		if counts&gt;1: #drop all sequences that are never repeated - this reduces PCR error</span>
<span class="sd">			num_unique_cdrh3_l3_pair_above1+=1</span>
<span class="sd">			header=&quot;:&quot;.join(results)</span>
<span class="sd">			clustered_input.write(&quot;&gt;%s\n%s\n&quot; %(header,CDRH3))			</span>
<span class="sd">			s2+=counts										</span>
<span class="sd">		del row	</span>
<span class="sd">	</span>
<span class="sd">	#trying to free memory..but doesnt work </span>
<span class="sd">	collapsed_dict = {}</span>
<span class="sd">	#del collapsed_dict	</span>
<span class="sd">	for k in codeDict_badSeqs.keys():</span>
<span class="sd">		a = codeDict_badSeqs.pop(k)</span>
<span class="sd">		del a</span>
<span class="sd">	del codeDict_badSeqs</span>
<span class="sd">	del codeDict</span>
<span class="sd">	gc.collect()</span>
<span class="sd">	gc.collect()</span>
<span class="sd">	gc.collect()</span>

<span class="sd">	</span>
<span class="sd">	#close all input files</span>
<span class="sd">	write_dict_summary.close()</span>
<span class="sd">	codeDict_save.close()</span>
<span class="sd">	clustered_input.close()</span>
<span class="sd">	collapsed_save.close()</span>
<span class="sd">	error.close()</span>
<span class="sd">	</span>
<span class="sd">	nonpaired_len+=bad_r1_pair</span>
<span class="sd">		</span>
<span class="sd">	print &#39;Summary: &#39;</span>
<span class="sd">	print &#39;Parsed through {0} sequences&#39;.format(str(total_seqs))</span>
<span class="sd">	print &#39;{0} ({1}%) sequences did not pass filters: &#39;.format(str(total_seqs-passed_filter),str( round(float(  (100*(total_seqs-passed_filter))/total_seqs),1)) if total_seqs&gt;0 else &#39;0&#39; )</span>
<span class="sd">	print &#39;		{0} sequences did not have an antibody sequence&#39;.format(str(no_result))</span>
<span class="sd">	print &#39;		{0} sequences did not have a cdr3&#39;.format(str(no_cdr3_error))</span>
<span class="sd">	print &#39;		{0} sequences were not productive&#39;.format(str(not_productive))</span>
<span class="sd">	print &#39;		{0} sequences had an unidentifiable chain type&#39;.format(str(invalid_chain))</span>
<span class="sd">	</span>
<span class="sd">	print &#39;{0} ({1}%) sequences were not paired successfully: &#39;.format(str(passed_filter-2*successful_pair),str( round(float(  100* ((passed_filter-2*successful_pair))  /total_seqs) ,1)) if total_seqs&gt;0 else &#39;0&#39;)</span>
<span class="sd">	print &#39;		{0} sequences had different LOCUS calls&#39;.format(str(2*locus_pairing_error))</span>
<span class="sd">	print &#39;		{0} sequences were paired as VH-VH&#39;.format(str(2*Hchain_pairing_error))</span>
<span class="sd">	print &#39;		{0} sequences were paired as VL-VL&#39;.format(str(2*Lchain_pairing_error))		</span>
<span class="sd">	print &#39;		{0} sequences did not have a corresponding R1-R2 pair read&#39;.format(str(nonpaired_len))</span>
<span class="sd">	#print &#39;		{0} sequences did not have a corresponding R1-R2 pair read that passed filters&#39;.format(str(bad_r1_pair))</span>
<span class="sd">	</span>
<span class="sd">	print &#39;{0} ({1}%) sequences were successfully paired: &#39;.format(str(2*successful_pair),str( round(float(100*(2*successful_pair)/total_seqs),1)) if total_seqs&gt;0 else &#39;0&#39;)</span>
<span class="sd">	print &#39;This leaves {0} identified VH-VL sequence-pairs: &#39;.format(str(successful_pair))</span>
<span class="sd">	print &#39;VH-VL sequence-pairs were collapsed into {0} sequences containing unique CDRH3-CDRL3 pairs: &#39;.format(str(num_unique_cdrh3_l3_pair))</span>
<span class="sd">	print &#39;{0} ({1}%) of these unique pairs were observed more than once&#39;.format(num_unique_cdrh3_l3_pair_above1,str(round(float(100*num_unique_cdrh3_l3_pair_above1/num_unique_cdrh3_l3_pair),1)) if num_unique_cdrh3_l3_pair&gt;0 else &#39;0&#39;)</span>
<span class="sd">	</span>
<span class="sd">	for anot_files in annotation_file_writing:</span>
<span class="sd">		anot_files[&#39;buffer&#39;].close()</span>
<span class="sd">	</span>
<span class="sd">	return [total_seqs,passed_filter,no_result,no_cdr3_error,not_productive,invalid_chain,successful_pair,Hchain_pairing_error,Lchain_pairing_error,nonpaired_len,num_unique_cdrh3_l3_pair,num_unique_cdrh3_l3_pair_above1,locus_pairing_error,annotation_file_writing,mapping_dict]		</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Costas.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>